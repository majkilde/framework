'++LotusScript Development Environment:2:5:(Options):0:74
%REM
**************************************************************************************************************************'
COPYRIGHT 2003-2013 by MAJKILDE
**************************************************************************************************************************'
This library is programmed and owned by MAJKILDE
Under the copyright laws, neither the documentation nor the software may be copied, photocopied, 
reproduced, translated, resold, or reduced to any electronic medium or machine-readable form, 
in whole or in part, without the prior written consent of MAJKILDE, except in the manner described 
in the documentation or the applicable licensing agreement governing the use of the software.
**************************************************************************************************************************'
%ENDREM

Option Public
Option Declare

Use "cls.system"
Use "cls.fw.language"
Use "cls.os.win"
Use "cls.fw"
Use "cls.fw.memo.ui"
Use "cls.xml"


'++LotusScript Development Environment:2:5:(Forward):0:1
Declare Class Attachmate As AbstractObject
Declare Public Class AttachmateSettings As AbstractObject
Declare Class AttachmateTemplate As AbstractObject
Declare Public Class AttachmateStorage As AbstractObject
Declare Public Class AttachmateDocument As AbstractObject
Declare Public Class SourceCollections As AbstractObject
Declare Public Class AbstractHandle As AbstractObject
Declare Class OtherHandle As AbstractHandle
Declare Class ExcelHandle As OtherHandle 'AbstractHandle
Declare Class Path As AbstractObject
Declare Class AttachmateMerger As AbstractObject
Declare Class SigmaHandle As AbstractHandle
Declare Class OneClickExport As AbstractObject
Declare Private Class XMLHandler As AbstractObject
Declare Class AttachmateViewControls As AbstractObject
Declare Class WordHandle As OtherHandle 'AbstractHandle
Declare Public Class AttachmateMergedata As AbstractObject
Declare Sub Initialize
Declare Static Function getAttachmate As Attachmate
Declare Function attachmate_doAttach( attachmate As Attachmate )
Declare Function attachmate_doCheckOut( attachmate As Attachmate )
Declare Function attachmate_doRemoveCheckOut( attachmate As Attachmate )
Declare Function attachmate_doEdit( attachmate As Attachmate )
Declare Function attachmate_doCheckIn( attachmate As Attachmate )
Declare Public Function getLanTxt( id As String ) As String
Declare Function isFileOpen( filename ) As Boolean
Declare Function attachmate_doOpenCheckout( attachmate As Attachmate )
Declare Function debug() As Boolean
Declare Function attachmate_doConvert( attachmate As Attachmate )
Declare Function attachmate_doRead( attachmate As Attachmate )
Declare Function loadLanguagePack()
Declare Function X_PrintDebugInfo(msg As string) As String
Declare Function attachmate_doCreate( attachmate As Attachmate )
Declare Function attachmate_doOptions( attachmate As Attachmate )

'++LotusScript Development Environment:2:5:(Declarations):0:10
Private globalAttachmate As Attachmate  'this makes it possible to share the same object between the form and subform. Use the GetAttachmate function to retrieve the object
Private Const VERSION = "08.02.2013"


'Transfer variables used by the Excute statement
Public sourceDocument As NotesDocument
Public sourceObject As Variant
Public sourceHandle As AbstractHandle
Public returnString As String

'CONST
Public Const ATTACHMATE_CONVERT_NO = 1 'use the original file format (2 files if a mergefile exist)
Public Const ATTACHMATE_CONVERT_PDF = 2 'convert to PDF
Public Const ATTACHMATE_CONVERT_MERGE = 3 'original file, any mergefiles will be merged 

Public Const ATTACHMATE_FILETYPE_OTHER = 1
Public Const ATTACHMATE_FILETYPE_WORD = 2
Public Const ATTACHMATE_FILETYPE_EXCEL = 3
Public Const ATTACHMATE_FILETYPE_SIGMA = 10

Public Const ATTACHMATE_ITEM = "attachmate_1" 'filetype
Public Const ATTACHMATE_TEMPLATE_ITEM = "attachmate_1_template" 'template id 
Public Const ATTACHMATE_FILE_ITEM = "attachmate_1_file" 'RTF with the document attacment
Public Const ATTACHMATE_FILENAME_ITEM = "attachmate_1_filename" 'the filename
Public Const ATTACHMATE_MERGEFILE_ITEM = "attachmate_1_mergefile" 'RTF with the mergefile attachment
Public Const ATTACHMATE_LOG_ITEM = "attachmate_1_log" 'log field
Public Const ATTACHMATE_TITLE_ITEM = "attachmate_1_title" 'document title - editable for the user
Public Const ATTACHMATE_EXTERNALREF_ITEM = "attachmate_1_ref" 'ref to document in external archive, syntax: unid=;dbconfig=;server=;replicaid=;filepath=;
Public Const ATTACHMATE_VERSION_ITEM = "attachmate_version" 'the version number
Public Const ATTACHMATE_ICON_ITEM = "attachmate_icon"

Private Const ATTACHMATE_ERR_APPLICATION_BUSY = 9999

Public timerObject As Variant 'used for debugging


%REM
	Rev 6.16-17 majkilde 8.02.2013
	- Some small bugs in the Excel module has been fixed
	Rev 6.15 majkilde 6.02.2013
	- IsResponsive removed again. ExcelHandle.IsOpen not throws an error is Excel is busy
	Rev 6.14 majkilde 1.02.2013
	- Added AbstractHandle.IsResponsive to secure better Excel handling
	Rev 6.13 majkilde 29.01.2013
	- Better error handling (AbstractHandle.ExecuteScript)
	- Send mail feature based on template: Don't ask if there is only one template to select from
	Rev 6.12 majkilde 21.01.2013
	- Excel setFocus now works with Office 2013 
	Rev 6.11 majkilde 11.01.2013
	- OneClickExport now supports multiple sources (with new class SourceCollections)
	Rev 6.10.1 majkilde 4.1.2013
	- Handling of Excel numerics
	Rev 6.10 majkilde 8.12.2012
	- OneClickExport added
	Rev 6.9.6 majkilde 6.12.2012
	- Excel, better handling of multiple sheets
	Rev 6.9.5 majkilde 19.04.2012
	- Excel, new option: merge in read mode 
	Rev 6.9.4 majkilde 23-03-2012
	- Dont execute script or macros when opening the template file ...
	Rev 6.9.3 majkilde 18.03.2012
	- Final fix for E&P
	Rev 6.9 majkilde 4.03.2012
	- SigmaHandle now supports value replace and select by attribute when merging
	Rev 6.8.5 majkilde 25.02.2012
	- Problem when merging with an unsaved document - fixed
	Rev 6.8.4 majkilde 24.02.2012
	- more stable word handling (without the word.visble toggles)
	Rev 6.8.3 majkilde 10.02.2012
	- Applied a small fix to the mergefile handling. 
	Note: If you get problems with a 'Word Conversion' dialog, then try this setting in the RegRedit:
	HKEY_CURRENT_USER\Software\Microsoft\Office\12.0\Word\Options  DefaultCPG=1252 (DWORD, 1252 in decimal value or 4e4 in Hex)
	http://answers.microsoft.com/en-us/office/forum/office_2007-word/when-opening-a-text-document-got-ms-word-message/7172f130-16ed-4c2f-8307-846b318661bc
	Rev 6.8.2 majkilde 03.02.2012
	- Another fix in the word mergefile handling - think it works now...
	Rev 6.8.1 majkilde 25.01.2012
	- Fixed a critical error in the word mergefile handling
	Rev 6.8 majkilde 20.01.2012
	- More stable word mergefile handling (new abstractHandle.beforeLaunch method introduced)
	Rev 6.7.5 majkilde 5.01.2012
	- Don't detach the mergedat file if we are going to recreate 
	Rev 6.7.4 majkilde 22.12.2011
	- Attachmate_doXXXX functions moved from subform to this script lib.
	Rev 6.7.2 majkilde 18.11.2011
	- Problem with open files and checkin solved
	Rev 6.7.1 majkilde 17.10.2011
	- Added a ;H option - to create sections in multivalue tables in word
	- Note: ;H bookmark must be in the first column in the table - but after the other ;@ mergefields in the settings
	Rev 6.6.8 majkilde 23-5-2011
	- Evil bug in WordHandle.updateProperties fixed
	Rev 6.6.7 majkilde 13.05.2011
	- Attachmatedocument.saveas/copyas: added a handle.closefile() after the merge 
	- Problem with Computet for Display fields solved
	Rev 6.6.5 majkilde 9.05.2011
	- Sigma handle: remove + from the filename
	- Show correct open/save button in file dialogs
	Rev 6.6 majkilde 29.04.2011
	- Small bugfix in the AttachmateStorage.init method
	Rev 6.5.5 majkilde 25.03.2011
	- Misc. updates
	Rev 6.5.4 majkilde 21-3-2011
	- Check-in/Check-Out feature added
	Rev 6.5.3 majkilde 5.02.2011
	- Updated messages
	- Fixed som minor errors
	- Store multiple attachments in responses
	Rev 6.5.2 majkilde 4.2.2011
	- Added support for Word bookmarks
	Rev 6.5.1 majkilde 28.1.2011
	- @ option added: Word multivalue tables cells
	Rev 6.4.2 majkilde 3.1.2011
	- Sigma: Couldn't attach a new file from disc without saving it in Sigma
	Rev 6.4 majkilde 29.11.2010
	- Sigma integration finalized (more pure XML support added)
	- Optional external log
	Rev 6.3 majkilde 15.11.2010
	- 'Convert to Flat/merged file' option added
	Rev 6.2.2. majkilde 5.11.2010
	- documents (labels) did not save correctly when creating (wordhandle.show and wordhandle.activeWordFilemerge)
	Rev 6.2.1 majkilde 1.11.2010
	- Fix a problem in the resolve function ('Erase params' added )
	Rev 6.2 majkilde 6.09.2010
	- AttachmateDocument.mailAs now supports the new AttachmateMemoTemplates field (create a mail based on a memo template)
	Rev 6.1.4 majkilde 23-08-2010
	- Attaching a file when the document is in readmode now works (without opening the file) 
	- File was lost when attachment ware deleted and then recreated
	Rev 6.1.3 majkilde 20-8-2010
	- WordHandle.show: added a save after mailmerge to avoid dialog (SK)
	Rev 6.1.2 majkilde 16.08.2010
	- Fixed a problem with the word mergecodes 
	Rev 6.1.1 majkilde 9.08.2010
	- Excel.mergecollection failed when evaluation invalid fields
	Rev 6.1 majkilde 13.07.2010
	- Sigma support added (http://codegroup.jirty.dk/pages/default.aspx)
	- Sigma data retriever (using xpath's)
	Rev 6.0.8 majkilde 7.06.2010
	- OnCreate macro ran to often
	- MergeCollection didn't close the last document
	Rev 6.0.7 majkilde 31.05.2010
	- Performance optimation (attachmateTemplate.setTemplate)
	- AttachmateDocument.mailAs: fixed a problem with the body field initialization
	- Fixed an Excel bug (can't launch if user is editing a field in Excel)
	Rev 6.06 majkilde 28.05.2010
	- Added: AttachmateDocument.restore()
	Rev 6.05 majkilde 3.05.2010
	- Added: AttachmateDocument.copyAs()
	Rev 6.0.4 majkilde 19.04.2010
	- Fixed some excel issues; setfocus, settings properties (custom+builtin), named target sheet
	- SetFocus fix (Windows: Hide extentions from known filetypes gave a problem)
	Rev 6.0.3. 
	- Fixed a small problem in the AttachmateMerger class
	Rev 6.0.2
	- New OpenTemplate action
	Rev 6.0.1
	- New field added: AttachmateMergeUnid (used in AttamateMergedata.loadMergeDocument )
%END REM


%REM
	The main object
	
%END REM
Class Attachmate As AbstractObject
	Private ws As NotesUIWorkspace
	Private db As NotesDatabase 'the current database
	
	Public document As AttachmateDocument
	Public settings As AttachmateSettings	
	Public mergedata As AttachmateMergedata
	'Public storage As AttachmateStorage
	Public template As AttachmateTemplate
	
	Private randomString As String
	
	Private p_silentmode As Boolean
	
%REM
		Sub new
		Description: Comments for Sub
%END REM
	Sub New
		Set ws = New NotesUIWorkspace
		Set db = session.Currentdatabase
		Randomize
		randomString = Format( Now, "mmdd-hhnnss" )
		silentmode = False
	End Sub
	
%REM
		Property Get silentmode
		Description: Comments for Property Get
%END REM
	Property Get silentmode() As Boolean
		silentmode = p_silentmode
	End Property
	
%REM
		Property Set silentmode
		Description: Comments for Property Set
%END REM
	Property Set silentmode() As Boolean
		p_silentmode = silentmode	
	End Property
	
%REM
		Function init
		Description: Comments for Function
%END REM
	Function init()
		Set Me.settings = New AttachmateSettings(Me)
		Set Me.document = New AttachmateDocument(Me)
		Set Me.mergedata = New AttachmateMergedata(Me)
		Set Me.template = New AttachmateTemplate(Me)
	End Function
	
%REM
		Function replaceFile
		Attach the filename to the document
%END REM
	Function attachFile( doc As NotesDocument, filename As String )
		Call document.setDocument(doc)
		
		Dim storage As AttachmateStorage
		Set storage = document.storage
		
		If storage.hasFile() Then Call template.clear() 'delete any existing files
		
		Call document.logAttachmateAction( "attach new" )
		Call storage.attachFile(filename)
		
		Dim handle As AbstractHandle
		Set handle = getHandle( filename )
		Call doc.Replaceitemvalue( ATTACHMATE_ITEM, handle.getType())
		Call doc.Replaceitemvalue( ATTACHMATE_TEMPLATE_ITEM, "" )
		Call doc.Replaceitemvalue( ATTACHMATE_TITLE_ITEM, cTitle( filename ))
		
		
		Call document.recalc()	
		
		Call storage.save()	
%REM
			* don't launch the application/COM (getHandle)
			* do the QuerySave from Attachmate document to set the correct icon
%END REM
		
		
		
	End Function
	
%REM
Returns the filetype (by looking at the file extension)
%END REM
	Private Function getFiletype( filename As String ) As Integer
		Dim ext As String
		ext = Lcase( Strrightback( filename, "." ))
		
		Select Case Lcase( ext )
		Case "doc","dot","docx","docm","dotm","dotx"
			getFiletype = ATTACHMATE_FILETYPE_WORD
			
		Case "xls","xlt","xlsx", "xlsm", "xltm"
			getFiletype = ATTACHMATE_FILETYPE_EXCEL
			
		Case "sig", "sit"
			getFiletype = ATTACHMATE_FILETYPE_SIGMA
			
		Case Else
			getFiletype = ATTACHMATE_FILETYPE_OTHER
		End Select
		
	End Function
	
	Public Function getHandle( filename As String ) As AbstractHandle
		If Not debug Then On Error Goto eh
		Dim handle As AbstractHandle
		
		If isOLEDisabled() Then
			Set handle = New OtherHandle(Me)
		Else
			Select Case getFiletype( filename )
			Case ATTACHMATE_FILETYPE_WORD
				Set handle = New WordHandle(Me)
				
			Case ATTACHMATE_FILETYPE_EXCEL
				Set handle = New ExcelHandle(Me)
				
			Case ATTACHMATE_FILETYPE_SIGMA
				Set handle = New SigmaHandle(Me)
				
			Case Else
				Set handle = New OtherHandle(Me)
			End Select
		End If
		
		Call handle.createFromFile( filename )
		Set getHandle = handle
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Public params List As String 'last resolved params
%REM
		Function resolve
		Resolve link in text format (server=;dbconfig=;unid=;filepath=;replicaid=;) and returns
		the NotesDatabase and optional a NotesDocument object
		Returns false if the resolve failed
%END REM
	Function resolve( paramString As Variant, returnDatabase As NotesDatabase, returnDocument As NotesDocument ) As Boolean
		If Not debug Then On Error Goto eh
		
		resolve = False
		'convert params to readable list
		Dim v As Variant
		Dim server As String
		
		If Isarray( paramString ) Then
			If Ubound( paramString ) = 0 Then paramString = paramString( 0 )
		End If
		
		If Isarray( paramString ) Then
			v = paramString
		Else
			If Left( paramString, 1 ) = "<" Then paramString = Mid( paramString, 2, Len( paramString )-2 )
			v = Split( paramString, ";" )
		End If
		
		Erase params
		
		Forall entry In v
			If entry <> "" Then params( Lcase( Strleft( entry, "=" ))) = Strright( entry, "=" )
		End Forall
		
		'open the database
		Set returnDatabase = Nothing
		If Iselement( params( "dbconfig" )) Then
			Dim config As New DbConfig
			Set returnDatabase = config.getDatabase( params( "dbconfig" ))
		End If
		
		If returnDatabase Is Nothing Then 'dbconfig not found or not specified -> try the replica id
			If Iselement( params( "server" )) Then server = params( "server" )
			
			Set returnDatabase = New NotesDatabase( "", "" )
			If Iselement( params( "replicaid" )) Then
				Call returnDatabase.Openbyreplicaid( server, params( "replicaid" ))
			End If
		End If
		
		If Not returnDatabase.isopen Then 'not found yet? -> try the filepath
			Set returnDatabase = New NotesDatabase( "", "" )
			If Iselement( params( "filepath" )) Then
				Call returnDatabase.Openwithfailover( server, params( "filepath" ))
			End If
		End If
		
		If Not Iselement( params( "dbconfig" )) And Not Iselement( params( "filepath" )) And Not Iselement( params( "replicaid" )) Then
			'no database specified. Use current database
			Set returnDatabase = session.Currentdatabase
		End If
		
		
		If returnDatabase Is Nothing Then Exit Function
		If Not returnDatabase.Isopen Then Exit Function
		
		If Iselement( params( "unid" )) Then 'find the document
			'found the database - now locate the document
			On Error Resume Next
			Set returnDocument = returnDatabase.getDocumentByUnid( params( "unid" ))
			If Not debug Then On Error Goto eh
			
			If returnDocument Is Nothing Then Exit Function 'not found
		End If	
		
		resolve = True 'success :-)
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
	Converts a filename to a document title
%END REM
	Function cTitle( filename As String ) As String
		Dim s As String
		s = filename
		If Instr( s, "\" ) > 0 Then s = Strrightback( s, "\" )
		If Instr( s, "/" ) > 0 Then s = Strrightback( s, "/" )
		If Instr( s, "." ) > 0 Then s = Strleftback( s, "." )
		
		cTitle = s
	End Function
	
%REM
		Function hasMergefile
		Returns true if a mergefile exist on the disk
%END REM
	Function hasMergefile() As Boolean
		hasMergefile = ( Dir( getMergefilename ) <> "" )
	End Function
	
%REM
		Function isOLEDisabled
		Description: Comments for Function
%END REM
	Private Function isOLEDisabled() As Boolean
		isOLEDisabled = False
		If Not template Is Nothing Then
			If template.getFieldString( "disableOLE" ) = "1" Then
				isOLEDisabled = True
				Exit Function
			End If
		End If 
		
		If document.hasDocument() Then
			With document.Getdocument()
				If Not Isnull( Arraygetindex( .AttachmateDisabledFeatures, "OLE", 5 )) Then
					isOLEDisabled = True
					Exit Function
				End If
			End With
		End If
		
	End Function
	
%REM
		Function getMergeFilename
		Description: Comments For Function
%END REM
	Function getMergeFilename()
		getMergeFilename = getAttachmatePath() & "mergedat.doc"
	End Function
	
%REM
		Function cMergetext
		Remove Any unsafe chars
%END REM
	Function cMergetext( source As String ) As String
		Dim unsafe( 3 ) As String
		unsafe( 0 ) = ";"
		unsafe( 1 ) = Chr( 10 )
		unsafe( 2 ) = Chr( 13 )
		
		Dim s As String
		Dim i As Integer
		Dim char As String
		For i = 1 To Len( source )
			char = Mid( source, i, 1 )
			If Isnull( Arraygetindex( unsafe, char )) Then
				s = s & char
			End If
		Next
		
		cMergeText = s
	End Function
	
%REM
		Function getTempPath
		Description: Comments for Function
%END REM
	Function getAttachmatePath() As String
		If Not debug Then On Error Goto eh
		
		Dim tmpPath As String
		Dim path As Path
		
		tmpPath = Environ( "Temp" ) & "\Attachmate\" & db.Replicaid & "\" 'note: same path used in the cleanup method (make changes both places)
		Dim doc As NotesDocument
		Set doc = document.getDocument()
		If doc Is Nothing Then Set doc = template.getDocument()
		If Not doc Is Nothing Then
			If doc.noteid = "0" Or doc.noteid="" Then 
				'new document
				tmpPath = tmpPath & randomString & "\"
			Else
				tmpPath = tmpPath & doc.Noteid & "\"
			End If
		End If
		
		Set path = New Path( tmpPath )
		Call path.create()' create if path doesn't exist
		
		getAttachmatePath = tmpPath
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function cleanup
		Description: Deletes all temporary files according to settings on the profile document
%END REM
	Function cleanup()
		Call cleandisc( Environ( "temp" ) & "\Attachmate\" & db.replicaid, settings.keepfiles())
	End Function
	
	Private Function cleandisc( path As String, days As Integer )
		On Error Resume  Next 'dont fail
		If path = "" Then Exit Function
		
		Dim filename As String
		Dim d As String
		Dim folders As New AbstractArray( Null )
		d = Dir( path & "\*.*", 16 ) 'ATTR_DIRECTORY
		Do Until d = ""
			If d = "." Then Goto NEXTFOLDER
			If d = ".." Then Goto NEXTFOLDER
			
			filename = path & "\" & d
			If Getfileattr( filename ) = 16 Then 'ATTR_DIRECTORY 
				Call folders.add( filename )
			Else
				If Cdat( Filedatetime( filename )) < ( Now-days ) Then
					Setfileattr filename, 0 'remove any 'readonly' flags
					Kill filename					
					If debug Then 
						Print "Cleanup: " & path & "\" & d & " (temporary file deleted from disc)"
					End If
				End If
			End If
			
NEXTFOLDER:
			d = Dir
		Loop
		
		'process subs
		Forall folder In folders.elements
			Call cleandisc( Cstr( folder ), days )
			Rmdir folder
		End Forall
		
	End Function
	
%REM
		'select a single file from OS. 
		'copy=true - copies the file to the Win temp dir	
		'button: "Open" or "Save"	
%END REM
	Public Function selectOSFile( copy As Boolean, Button As String ) As String
		If Not debug Then On Error Goto eh
		
		Dim ws As New NotesUIWorkspace
		Dim filename As Variant
		Dim copytoFilename As String
		
		Dim defaultFilepath As String
		defaultFilepath = session.getEnvironmentString( "Attachmate.lastpath", False )
		
		'ws.Savefiledialog(Directoriesonly, Title, Filters, Initialdir, Initialfile)
		'ws.Openfiledialog(Multipleselection, Title, Filters, Initialdir, Initialfile)
		
		Select Case Lcase( Button )
		Case "open":
			filename = ws.Openfiledialog( False, getLanTxt( "SELECTFILE_TITLE" ), getLanTxt( "SELECTFILE" ), defaultFilepath, "*.*" )
		Case Else:
			filename = ws.SaveFileDialog( False, getLanTxt( "SELECTFILE_TITLE" ), getLanTxt( "SELECTFILE" ), defaultFilepath, "*.*" )
		End Select
		
		If Not Isempty( filename ) Then
			Call session.setEnvironmentVar( "Attachmate.lastpath", Strleftback( filename( 0 ), "\" ))
			If copy Then
				
				copytoFilename = getAttachmatePath() & Strrightback( filename( 0 ), "\" )
				
				If Lcase( filename( 0 )) <> Lcase( copyToFilename ) Then 'dont overwirte my self
					On Error Goto copyerr
					Filecopy filename( 0 ), copytoFilename
					If Not debug Then On Error Goto eh
				End If
				selectOSFile = copytoFilename
			Else
				selectOSFile = filename( 0 )
			End If
		Else
			selectOSFile = ""
		End If
		
done:
		Exit Function
copyerr: 
		selectOSFile = filename( 0 )
		Resume done
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function isFileOpen
		Description: Comments for Function
%END REM
	Function isFileOpen( filename As String ) As Boolean
		On Error Goto eh
		
		Dim f As Integer
		f = Freefile
		Open filename For Input Lock Read As f 'open and lock the file
		
		'success
		isFileOpen = False
done:
		Close f
		Exit Function
eh:
		'failed. File doesn't exist or is allready open and locked
		isFileOpen = True
		Resume done
	End Function
	
	
End Class

%REM
	Class AttachmateSettings
	The profile document with all the global settings
	e.g. where to find templates, storage file, cleanup settings etc
%END REM
Public Class AttachmateSettings As AbstractObject
	Private attachmate As Attachmate
	Private db As NotesDatabase
	Private profile As NotesDocument
	
%REM
		Sub New
		Description: Comments for Sub
%END REM
	Sub New(attachmate As Attachmate)
		Set Me.attachmate = attachmate
		Set Me.db = session.Currentdatabase
		Set profile = db.Getprofiledocument("Setup")
	End Sub
	
	
%REM
		Function useExternalArchive
		Description: Comments for Function
%END REM
	Public Function useExternalArchive() As Boolean
		useExternalArchive = (profile.attachmateArchive( 0 ) = "1")
	End Function
	
%REM
		Function doBackup
		Returns true if a backup copy of the file should be created
%END REM
	Function doBackup() As Boolean
		If keepfiles = 0 Then
			doBackup = False
		Else
			doBackup = (profile.attachmateBackup( 0 ) = "1")
		End If
	End Function
	
%REM
		Function getExternalDatabase
		Description: Comments for Function
%END REM
	Function getExternalDatabase() As NotesDatabase
		Dim storageDb As NotesDatabase
		If attachmate.resolve(profile.attachmateArchiveLinkTxt( 0 ), storageDb, Nothing ) Then
			Set getExternalDatabase = storageDb
		Else
			Set getExternalDatabase = Nothing
		End If
	End Function
	
%REM
		Function getDocument
		Description: Comments For Function
%END REM
	Function getDocument() As NotesDocument
		Set getDocument = profile
	End Function
	
	
%REM
		Function getTemplateViewName
		Description: Comments for Function
%END REM
	Function getTemplateViewName() As String
		getTemplateViewName = profile.attachmateTemplateView( 0 )
	End Function
	
	
%REM
		Function getExternalId
		Description: Comments for Function
%END REM
	Function getExternalConfigId() As String
		Dim item As Variant
		Set item = profile.getFirstItem( "attachmateArchiveLink" )
		If Not item Is Nothing Then
			getExternalConfigId = item.text
		End If
	End Function
	
%REM
		Function archiveFields
		Returns a list of fields that should be inherited to the external archive document
%END REM
	Function archiveFields() As Variant
		archiveFields = profile.attachmateArchiveFields
	End Function
	
%REM
		Function keepfiles
		Description: Returns the number of days to keep files on disk
%END REM
	Function keepfiles() As Integer
		If profile.attachmateKeep( 0 ) = "1" Then
			keepfiles = profile.attachmateKeepDays( 0 )
			
			If attachmate.template.disableBackup() Then keepfiles = 0
		Else
			keepfiles = 0
		End If
		
	End Function
End Class


%REM
	Class AttachmateTemplate
	The template document (with the template object, e.g. word or excel template)
	Settings about how and which data to transfer (sync)
%END REM
Class AttachmateTemplate As AbstractObject
	Private attachmate As Attachmate
	Private template As NotesDocument
	Private reusedTemplate As NotesDocument 'mapping data can be resued from another document
	Private localSettings List As Variant 'mapping data on the local datadocument, stored in the attachmateTemplateSettings field
	Private viewname As String 'name of the pickview
	
	Private db As notesDatabase
	
%REM
		Sub new
		Description: Comments for Sub
%END REM
	Sub New(attachmate As Attachmate)
		Set Me.attachmate = attachmate
		Set db = session.Currentdatabase
	End Sub
	
%REM
		Function hasTemplate
		Description: Comments for Function
%END REM
	Function hasTemplate() As Boolean
		hasTemplate = Not ( template Is Nothing )
	End Function
	
%REM
		Function getDocument
		Description: Comments for Function
%END REM
	Function getDocument() As NotesDocument
		Set getDocument = template
	End Function
	
%REM
		Function getViewname
		Description: Comments for Function
%END REM
	Function getViewname() As String
		If viewname <> "" Then 
			getViewname = viewname 
			Exit Function
		End If
		
		Dim lan As String 'the current user language
		lan = language.getLanguage()
		
		viewname = "pick.attachmateTemplate6" 'default view
		If attachmate.settings.getTemplateViewName() <> "" Then viewname = attachmate.settings.getTemplateViewName()
		If attachmate.document.hasDocument() Then
			If attachmate.document.getDocument().attachmateViewname( 0 ) <> "" Then viewname = attachmate.document.getDocument.attachmateViewname( 0 )
		End If
		
		'search for a languahe specific view
		Dim view As NotesView
		Set view = CacheManager.getView( "*", viewname & "." & lan )
		If Not view Is Nothing Then viewname = viewname & "." & lan
		
		getViewname = viewname
	End Function
	
%REM
		Function setViewname
		Description: Comments for Function
%END REM
	Function setViewname( viewname As String )
		Me.viewname = viewname
	End Function
	
%REM
		Function getItemValue
		Text fields only. Data from the reuse doc is appended
%END REM
	Function getField( itemname As String ) As Variant
		
		If Iselement( localSettings( Lcase( itemname ))) Then
			'use the local settings
			getField = localSettings(Lcase( itemname )) 
			Exit Function 
		End If
		
		If Not hasTemplate Then Exit Function
		Dim v As Variant
		v = template.getItemValue( itemname )
		
		If Not reusedTemplate Is Nothing Then
			If reusedTemplate.getItemValue( itemname )( 0 ) <> "" Then
				If v( 0 ) = "" Then
					v = reusedTemplate.getItemValue( itemname )
				Else
					v = Arrayappend( v, reusedTemplate.getItemValue( itemname ))
				End If
			End If
		End If
		
		getField = v
	End Function
	
%REM
		Function getFieldString
		Description: Comments for Function
%END REM
	Function getFieldString( itemname As String ) As String
		Dim v As Variant
		Dim s As String
		v = getField( itemname )
		If Isarray( v ) Then
			Forall entry In v
				If s <> Cstr( entry ) Then
					s = s & Cstr( entry )
				End If
			End Forall
			getFieldString = s
		Else
			getFieldString = Cstr( v )
		End If
	End Function
	
%REM
		Function clear
		Description: Comments for Function
%END REM
	Function clear()
		'reset/remove template
		Set template = Nothing
	End Function
	
%REM
		Function setTemplate
		Description: Comments for Function
%END REM
	Function setTemplate( newTemplate As Variant ) As Boolean
		If Not debug Then On Error Goto eh
		setTemplate = False
		
		Select Case Typename( newTemplate )
		Case "NOTESDOCUMENT"
			Set template = newTemplate
			setTemplate = True
		Case "STRING"
			If newTemplate = "*" Then
				Set template = attachmate.document.getDocument() 'use the current document (with localSettings)
				setTemplate = True
			Elseif newTemplate ="" Then
				setTemplate = pickTemplate()
			Else
				Dim coll As NotesDocumentCollection
				Dim qry As String
				
				'view lookup
				Dim view As NotesView
				Set view = db.getView( "admin.lookup" )
				If view Is Nothing Then Set view = db.getView( "attachmate.lookup.template" )
				If Not view Is Nothing Then 
					Set template = view.Getdocumentbykey(newTemplate, True )
				End If
				
				Set template = CacheManager.getDocument( db, "admin.lookup", Cstr( newTemplate ))
				If template Is Nothing Then
					Set template = CacheManager.getDocument( db, "attachmate.lookup.template", Cstr( newTemplate ))
				End If
				
				'if lookup failed - try a dbsearch				
				If template Is Nothing Then
					Call Me.logAction(LOG_VERBOSE, "Attachmate: template lookup view is missing - using a slower db.search instead", Nothing)
					qry = |@contains( form; "attachmate.template" ) & @lowercase( id )="| & Lcase( newTemplate ) & |"|
					Set coll = db.Search( qry, Nothing, 0 )
					If coll.Count > 0 Then
						Set template =  coll.GetFirstDocument
						setTemplate = True
					End If
				Else
					setTemplate = True
				End If
			End If
		Case Else
			setTemplate = pickTemplate()
			setTemplate = True			
		End Select
		
		'<reuse>
		If hasTemplate() Then
			If template.attachmateMappingLinkTxt( 0 ) = "" Then
				Set reusedTemplate = Nothing
			Else
				'reuse mappings from another template
				Dim tmpDb As NotesDatabase
				Dim tmpDoc As NotesDocument
				If attachmate.resolve( template.attachmateMappingLinkTxt( 0 ), tmpDb, tmpDoc ) Then
					If tmpDoc Is Nothing Then Error 9000, "Mapping data is reused from another document - but I can not find it (invalid unid)"
				Else
					Error 9000, "Mapping data is reused from another document - but I can not open the database"
				End If
				Set reusedTemplate = tmpDoc
			End If
		End If
		'</reuse>
		
		'<localsettings>
		Dim itemname As String
		Dim value As String
		If Not attachmate.document.getDocument Is Nothing Then
			With attachmate.document.getDocument()
				Forall entry In .attachmateTemplateSettings
					If entry = "" Then Goto nextentry
					itemname = Lcase( Strleft( entry, "=" ))
					value = Strright( entry, "=" )
					localSettings( itemname ) = Split( value, "^<BR>^" )
nextentry:
				End Forall
			End With
		End If
		'</localsettings>
		
		'<default values>
		If hasTemplate() Then
			If template.defaultValues( 0 ) <> "" Then
				Forall entry In template.defaultValues
					Dim formula As String
					itemname = Fulltrim( Strleft( entry, ":=" ))
					formula = Strright( entry, ":=" )
					
					If formula<>"" And itemname <> "" Then
						Dim doc As NotesDocument
						Set doc = attachmate.document.getDocument()
						If Not doc Is Nothing Then
							Call doc.replaceItemvalue( itemname, Evaluate( formula, doc ))							
						End If
					End If
				End Forall
			End If
		End If
		'</default values>
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	Function pickTemplate() As Boolean
		Dim ws As New NotesUIWorkspace
		Dim coll As NotesDocumentCollection
		
		pickTemplate = False
		
%REM
		Dim platform As String
		Dim v As Variant
		v = Evaluate( |@Platform([Specific])| )
		If v( 1 ) >= "6.1" Then 
			platform = "win7"
		Else
			platform = "before7"
		End If
%ENDREM
		
		'get the view name
		Set coll = ws.PickListCollection( PICKLIST_CUSTOM, False, db.server, db.filepath, getViewname(), getLanTxt( "SELECTTEMPLATE_TITLE" ), getLanTxt( "SELECTTEMPLATE" )) ', platform )
		If coll Is Nothing Then Exit Function
		Set template = coll.GetFirstDocument
		pickTemplate = Not ( template Is Nothing )
	End Function
	
%REM
		Function getId
		Description: Comments for Function
%END REM
	Function getId() As String
		If template Is Nothing Then Exit Function
		
		getId = template.id( 0 )
	End Function
	
%REM
		Function disableBackup
		Description: Comments for Function
%END REM
	Function disableBackup() As Boolean
		If template Is Nothing Then
			disableBackup = False
		Else
			disableBackup = ( template.disableBackup( 0 ) = "1" )
		End If
	End Function
	
%REM
		Function detach
		Detach file and return the filename
%END REM
	Function detach() As String
		If Not debug Then On Error Goto eh
		If template Is Nothing Then Exit Function
		Dim templateStorage As New AttachmateStorage(attachmate)
		
		If template.attachmateFileLinkTxt( 0 ) = "" Then
			Call templateStorage.setDocument( template, "" )
		Else
			'reuse attachment from another template
			Dim tmpDb As NotesDatabase
			Dim tmpDoc As NotesDocument
			If attachmate.resolve( template.attachmateFileLinkTxt( 0 ), tmpDb, tmpDoc ) Then
				If tmpDoc Is Nothing Then Error 9000, "Template file is reused from another document - but I can not find it (invalid unid)"
			Else
				Error 9000, "Template file is reused from another document - but I can not open the database"
			End If
			Call templateStorage.setDocument( tmpDoc, template.attachmateFileItem( 0 ))
		End If
		
		detach = templateStorage.detach() 'detach the template file
		
		Exit Function		
eh:
		Error Err, getErrorInfo( Me )
		
	End Function
	
End Class

%REM
	Class AttachmateStorage
	Ref to the storage document
%END REM
Public Class AttachmateStorage As AbstractObject
	Private attachmate As Attachmate
	Private db As NotesDatabase 'the storage database
	Private sourceDoc As NotesDocument 'the source document
	Private doc As NotesDocument 'the storage document
	Private rtf As NotesRichTextItem 'the richtext field used to hold the attachments
	
	Private isExternalFlag As Boolean
	
	Sub New(attachmate As Attachmate)
		Set Me.attachmate = attachmate
	End Sub
	
%REM
	Function getIsExternal
	Description: Comments for Function
%END REM
	Public Function IsExternal() As Boolean
		isExternal = isExternalFlag
	End Function
	
%REM
	Function getDocument
	Description: Comments for Function
%END REM
	Public Function getDocument()
		Set getDocument = doc
	End Function
	
%REM
		Function isReady
		Returns true if storage is ready
%END REM
	Private Function isReady() As Boolean
		isReady = ( Not doc Is Nothing And Not rtf Is Nothing ) 
	End Function
	
%REM
		Function setDocument
		Description: same as init - but with no logic at all (just set as specified - used from the AttachmateTemplate.detech function)
%END REM
	Function setDocument( sourceDoc As NotesDocument, sourceItemname As String )
		If Not debug Then On Error Goto eh
		
		isExternalFlag = False
		Set Me.sourceDoc = sourceDoc
		Set doc = sourceDoc
		Set db = sourceDoc.Parentdatabase
		If sourceItemname = "" Then sourceItemname = ATTACHMATE_FILE_ITEM
		Set rtf = sourceDoc.GetFirstItem( sourceItemname )
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function init
		Checks the Attachmatedocument and the Settings to find the right place for the file
%END REM
	Function init( sourceDoc As NotesDocument, sourceItemname As String )
		If Not debug Then On Error Goto eh
		
		If isReady() Then Exit Function 'has allready been initialized
		
		Set Me.sourceDoc = sourceDoc
		If sourceDoc Is Nothing Then Set Me.sourceDoc = attachmate.document.getDocument()
		If sourceItemname = "" Then sourceItemname = ATTACHMATE_FILE_ITEM
		
		'assume local
		isExternalFlag = False
		Set doc = sourceDoc
		Set db = sourceDoc.Parentdatabase
		Set rtf = sourceDoc.GetFirstItem( sourceItemname )
		
		If attachmate.document.isTemplate() Then Goto done 'template files is always local
		
		'use external?
		Dim v As Variant
		v = sourceDoc.Getitemvalue(ATTACHMATE_EXTERNALREF_ITEM)
		Dim params List As String
		If v(0) <> "" Then 'external archive
			If attachmate.resolve( v, db, doc ) Then
				If doc Is Nothing Then Error 9000, "Can not find the document in the external archive"
			Else
				Error 9000, "Can not locate the external archive (or the document)"
			End If
			
			If doc.Getitemvalue("attachmateFileItem")( 0 ) <> "" Then
				sourceItemname = doc.Getitemvalue("attachmateFileItem")( 0 )
			End If
			
			Set rtf = doc.GetFirstItem( sourceItemname )
			
			If rtf Is Nothing Then
				If attachmate.settings.getDocument().attachmateFileItem( 0 ) <> "" Then
					sourceItemname = attachmate.settings.getDocument().attachmateFileItem( 0 )
				End If
			End If
			
			If rtf Is Nothing Then
				Set rtf = doc.GetFirstItem( ATTACHMATE_FILE_ITEM )
			End If
			
			If rtf Is Nothing Then
				Set rtf = doc.GetFirstItem( "body" )
			End If
			
			isExternalFlag = True
		Elseif Not rtf Is Nothing Then
			'we have an existing RTF field - just reuse this 
			If Not Isarray ( rtf.embeddedObjects ) Then
				'but field is empty -> it might be a new document (or doc with a deleted attachment)
				Goto newdocument
			End If 
			
		Else 'new document?
newdocument:
			If attachmate.settings.useExternalArchive() Then
				'create a new storage document in the external archive
				Set db = attachmate.settings.getExternalDatabase()
				If Not db Is Nothing Then
					Set doc = db.createDocument()
					doc.form = "Attachment"
					doc.date = sourceDoc.Created
					doc.id = sourceDoc.UniversalID
					doc.replicaid = sourceDoc.Parentdatabase.ReplicaID
					
					If attachmate.settings.getDocument().attachmateFileItem( 0 ) <> "" Then
						sourceItemname = attachmate.settings.getDocument().attachmateFileItem( 0 )
						Call doc.Replaceitemvalue("attachmateFileItem", sourceItemname)
					End If
					
					Set rtf = doc.CreateRichTextItem( sourceItemname )
					
					'set the reference
					Dim ref As String
					ref = "unid=" & doc.universalId & ";"
					ref = ref & "filepath=" & db.filepath & ";"
					ref = ref & "server=" & db.server & ";"
					ref = ref & "replicaid=" & db.replicaid & ";" 
					v = attachmate.settings.getExternalConfigId()
					If v <> "" Then
						ref = ref & "dbconfig=" & v & ";"
					End If
					Call sourceDoc.Replaceitemvalue( ATTACHMATE_EXTERNALREF_ITEM, ref )
					
					isExternalFlag = True
				Else
					Set rtf = sourceDoc.CreateRichTextItem( sourceItemname ) 'default
				End If
			Else
				If rtf Is Nothing Then
					Set rtf = sourceDoc.CreateRichTextItem( sourceItemname ) 'default
				End If	
			End If
		End If
		
done:
		If isExternalFlag Then
			If debug Then Print "Using external archive: " & db.title & " (" & db.Filepath & ")"
			'If Not isReady Then Call init( sourceDoc, sourceItemname )
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function appendLog
		Description: the local document log (can only log edits)
%END REM
	Function appendFieldLog( action As String )
		If Not debug Then On Error Goto eh
		
		If Not isReady Then Call init( sourceDoc, "" )
		If doc Is Nothing Then Exit Function
		
		'update log
		Dim item As NotesItem
		Dim entry As String
		Dim n As New NotesName( session.username )
		
		entry = Format( Now, "yyyy.mm.dd hh:mm" ) & "; " & action & "; " & n.Abbreviated
		
		Set item = doc.GetFirstItem( ATTACHMATE_LOG_ITEM )
		If item Is Nothing Then
			Set item = doc.ReplaceItemValue( ATTACHMATE_LOG_ITEM, entry )
		Else
			Call item.AppendToTextList( entry )
		End If
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
%REM
		Function hasFile
		Description: Comments for Function
%END REM
	Function hasFile() As Boolean
		If Not isReady Then Call init( sourceDoc, "" )
		If rtf Is Nothing Then 
			hasFile = False 
			Exit Function
		End If
		hasFile = Isarray ( rtf.Embeddedobjects )
	End Function
	
%REM
		Function save
		Description: Comments for Function
%END REM
	Function save()
		Call sourceDoc.Replaceitemvalue(ATTACHMATE_VERSION_ITEM, VERSION)
		If isExternalFlag Then
			Call doc.save( True, False ) 
			Call sourceDoc.save( True, False )
		Else
			Call sourceDoc.save( True, False )
		End If
		
		Call attachmate.document.logAttachmateAction("saved")
	End Function
	
%REM
		Function detachTo
		Detach file to a named position. Use empty params to use default values
		if filename starts with 
		@: It is a notes function
		%: A date will be added to the default filename
%END REM
	Function detachTo( path As String, filename As String ) As String
		If Not debug Then On Error Goto eh
		If Not isReady Then Call init( sourceDoc, "" )
		Dim s As String
		Dim v As Variant
		Dim d As String
		
		If path = "" Then path = attachmate.getAttachmatePath()
		If Right( path, 1 ) <> "\" Then path = path & "\"
		
		Dim e As NotesEmbeddedObject
		If Isarray( rtf.Embeddedobjects ) Then
			Set e = rtf.Embeddedobjects( 0 )
			
			Select Case Left( filename, "1" )
			Case "", "@", "#"
				If Left( filename, 1 ) = "#" Then
					d = "_" & Format( Now, "yyyymmdd_hhnn" )
					filename = ""
				End If	
				
				s = cFilename( attachmate.document.getDocument().Getitemvalue(ATTACHMATE_TITLE_ITEM)( 0 ))
				If s = "" Then
					If Not attachmate.template.getDocument() Is Nothing Then
						s = cFilename( attachmate.template.getDocument().Getitemvalue(ATTACHMATE_TITLE_ITEM)( 0 ))
					End If
				End If
				If s <> "" Then
					filename = s & d & "." & Strrightback( e.source, "." ) 'append the extension
				End If
			End Select
			
			If filename = "" Then 'no filename yet - use the name of the attachment
				filename = e.Source 
			End If
			
			filename = path & filename
			
			If Dir( filename ) = "" Then
				Call e.Extractfile(filename)
			Else
				'file exits
				If isFileopen( filename ) Then
					'file is open - just reuse
				Elseif attachmate.settings.keepfiles = 0 Or doc.disableBackup( 0 ) = "1"  Then
					'don't keep files - just delete
					Kill filename
					Call e.Extractfile(filename)
				Else
					'<backup> backup existing file
					Dim newname As String
					Dim i As Integer
					d = Dir( filename )
					If d <> "" Then
NEXTNAME:
						i = i + 1
						newname = Strleftback( filename, "." ) & " (" & i & ")." & Strrightback( filename, "." )
						If Dir( newname ) <> "" Then Goto NEXTNAME
						Name filename As newname
					End If
					'</backup>
					Call e.Extractfile(filename)
				End If
			End If
			
			detachTo = filename
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function detach
		Detach file to the attachmate temp lib using the current filename
%END REM
	Function detach() As String
		If Not debug Then On Error Goto eh
		
		detach = detachTo( "", "" )
		
		'<detach mergefile>
		If Not attachmate.hasMergefile() Then
			If Not attachmate.mergedata.hasCollection() Then '05.01.2012 only detach if we are not going to recreate with existing data
				Dim e As NotesEmbeddedObject
				Dim tmpRtf As NotesRichTextItem
				Set tmpRtf = doc.Getfirstitem(ATTACHMATE_MERGEFILE_ITEM)
				If Not tmpRtf Is Nothing Then
					If Isarray( tmpRtf.Embeddedobjects ) Then
						Set e = tmpRtf.Embeddedobjects( 0 )
						Call e.extractFile( attachmate.getMergefilename() )
					End If
				End If
			End If
		End If
		'</detach>
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function getFilename
		Returns the filename of the attached file (if any)
%END REM
	Function getFilename() As String
		On Error Goto eh
		If Not isReady Then Call init( sourceDoc, "" )
		Dim e As NotesEmbeddedObject
		If Isarray( rtf.Embeddedobjects ) Then
			Set e = rtf.Embeddedobjects( 0 )
			getFilename = e.source
		Else
			getFilename = ""
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Converts a title to a filename (removing illegal charecters). Prefix with @ to specify a formula
%END REM
	Private Function cFilename( source As String ) As String
		Const ILLEGAL_CHARS = {/\:*?"<>|}
		Dim s As String
		Dim char As String
		Dim i As Integer
		
		Dim sourceDoc As NotesDocument
		Set sourceDoc = attachmate.mergedata.getDocument()
		If sourceDoc Is Nothing Then Set sourceDoc = attachmate.document.getDocument()
		
		If Left( source, 1 ) = "@" Then
			source = cString( Evaluate( Mid( source, 2 ), sourceDoc ))
		End If
		
		For i = 1 To Len( source )
			char = Mid( source, i, 1 )
			If Instr( ILLEGAL_CHARS, char ) = 0 Then
				s = s & char
			End If
		Next
		
		cFilename = s
	End Function
	
	Function attach() As Boolean
		Dim handle As AbstractHandle
		Set handle = attachmate.document.getHandle()
		attach = attachFile( handle.getFilename())
		
		'<attach the mergefile (if any)>
		If Not attachmate.document.isTemplate Then
			Dim mergefile As String
			If attachmate.hasMergefile() Then
				mergefile = attachmate.getMergefilename()
				Call doc.RemoveItem( ATTACHMATE_MERGEFILE_ITEM )
				Dim tmpRtf As NotesRichTextItem
				Set tmpRtf = doc.createRichTextItem( ATTACHMATE_MERGEFILE_ITEM )
				Call tmpRtf.Embedobject( EMBED_ATTACHMENT, "", mergefile )
			End If
		End If
		'</attach>
	End Function
	
	
	Function attachFile( filename As String ) As Boolean
		If Not debug Then On Error Goto eh
		
		If Not isReady Then Call init( sourceDoc, "" )
		
		'remove the old field (and attachments)
		Dim fieldname As String
		fieldname = rtf.name
		Call doc.RemoveItem( fieldname )
		'recreate the field
		Set rtf = doc.CreateRichTextItem( fieldname )
		
		
		'add new file
		Call rtf.EmbedObject( EMBED_ATTACHMENT, "", filename )
		Call doc.Replaceitemvalue(ATTACHMATE_FILENAME_ITEM, Strrightback( Replace(filename, "/", "\" ), "\" ))
		'Call setInfoStr(  filename2type( filename ), filename2title( filename ), Null, "" )
		
		If isExternalFlag Then
			'update the inherited fields
			Forall item In attachmate.settings.archiveFields()
				If item <> "" Then Call doc.Replaceitemvalue( item, sourceDoc.Getitemvalue( item ))
			End Forall
		End If
		
		
		attachFile = True
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Returns true if the file has been removed/deleted
%END REM
	Function remove() As Boolean
		If Not debug Then On Error Goto eh 
		If Not isReady Then Call init( sourceDoc, "" )
		
		If isExternalFlag And (doc.noteid <> sourcedoc.noteid) Then
			Call doc.remove( True )
		Else
			'delete the merge file
			Call doc.Removeitem(ATTACHMATE_MERGEFILE_ITEM)
			Call doc.createRichTextItem( ATTACHMATE_MERGEFILE_ITEM )
			
			Dim fieldname As String
			fieldname = rtf.name
			If Isarray( rtf.Embeddedobjects ) Then
				Forall e In rtf.Embeddedobjects
					Call e.remove()
				End Forall
			End If
			Call rtf.Update()
			
			Dim ws As New NotesUIWorkspace
			Call ws.currentDocument.fieldClear(ATTACHMATE_MERGEFILE_ITEM)
			Call ws.currentDocument.fieldClear(ATTACHMATE_FILE_ITEM)
			Call ws.currentDocument.save()
			
		End If
		'Set rtf = Nothing
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
End Class


%REM
	Class AttachmateDocument
	Handles the attachments stored on document (edit, add, delete etc)
	Used from the Attachmate6 subform
%END REM
Public Class AttachmateDocument As AbstractObject
	Private attachmate As Attachmate
	Private db As NotesDatabase
	Private uidoc As NotesUIDocument
	Private doc As NotesDocument
	Private ws As NotesUIWorkspace
	Public storage As AttachmateStorage
	Public options List As String
	
	Private isSaved As Boolean 'true if the Notes document has been saved
	
	Private handle As AbstractHandle 'the current file  
	
	
	Private isAttachmateSubform As Boolean
	Private isAttachmateTemplate As Boolean
	
	
%REM
		Sub new
		Description: Comments for Sub
%END REM
	Sub New( attachmate As Attachmate )
		Set Me.attachmate = attachmate
		Set ws = New NotesUIWorkspace
		Set db = session.Currentdatabase
		isSaved = False
		logDisabled = False
	End Sub
	
%REM
		Function readOptions
		Description: Comments for Function
%END REM
	Private Function readOptions()
		'read the AttachmateOptions
		If doc Is Nothing Then Exit Function
		
		Dim v As Variant
		If Ubound( doc.AttachmateOptions ) = 0 Then
			v = Split( doc.AttachmateOptions( 0 ), ";" )
		Else
			v = doc.AttachmateOptions
		End If
		Dim s As String
		Forall entry In v
			If Instr( entry, "=" ) > 0 Then
				s = Strright( entry, "=" )
				s = Replace( s, Chr( 10 ), "" )
				s = Replace( s, Chr( 13 ), "" )
				
				options( Lcase( Strleft( entry, "=" ))) = s
			Else
				options( Lcase( entry )) = "1"
			End If
		End Forall
		
	End Function
	
	
	Private p_logDisabled As Boolean
	
%REM
	Property Set logDisabled
	Description: Comments for Property Set
%END REM
	Property Set logDisabled As Boolean
		p_logDisabled = logDisabled
	End Property
	
%REM
	Property Get logDisabled
	Description: Comments for Property Get
%END REM
	Property Get logDisabled As Boolean
		logDisabled = p_logDisabled
	End Property
	
%REM
		Function createLogDocument
		Description: Comments for Function
%END REM
	Function logAttachmateAction( action As String )
		If logDisabled Then Exit Function
		
		If Not Iselement( options( "log" )) Then
			Call storage.appendFieldLog(action) 
			Exit Function 'log not enabled
		End If
		
		Dim logDb As NotesDatabase
		Set logDb = CacheManager.getDatabase( options( "log" ))
		
		If logDb Is Nothing Then 
			Set logDb = session.currentDatabase 'can't find the log database - just log in the local database
		End If
		
		Dim item As NotesItem
		Dim logDoc As notesDocument 
		Set logDoc = logDb.createDocument
		With logDoc
			Call .replaceItemValue( "form", "Log" )
			Set item = .Replaceitemvalue("author", session.Username)
			item.Isauthors = True
			Call .replaceItemValue( "date", Now )
			Call .Replaceitemvalue( "$PublicAccess", "1" )
			Call .replaceItemValue( "action", action )
			
			Call .replaceItemValue( "sourceDbId", db.replicaId )
			Call .replaceItemValue( "sourceDbTitle", db.title )
			Call .replaceItemValue( "sourceDbServer", db.server )
			Call .replaceItemValue( "sourceDbFilepath", db.filepath )
			
			Call .replaceItemValue( "sourceDocUnid", getDocument().universalId )
			Call .replaceitemvalue( "sourceFiles", Evaluate(|@attachmentnames|, getDocument()))
			
			Dim rtf As NotesRichTextItem
			Set rtf = .Createrichtextitem("link")
			Call rtf.Appenddoclink( getDocument, getLinkComment( getDocument()) )
		End With
		
		Call logDoc.save( True, False ) 
		
	End Function
	
	Function getDocument() As NotesDocument
		Set getDocument = doc
	End Function
	
%REM
		Function hasDocument
		Description: Comments for Function
%END REM
	Function hasDocument() As Boolean
		hasDocument = Not (doc Is Nothing)
	End Function
	
%REM
		Function setDocument
		Description: Comments for Function
%END REM
	Function setDocument( doc As NotesDocument )
		Set Me.doc = doc
		'computet for display field might be destroyed by an uidoc.refresh (possible Notes bug). So we save the values here
		isAttachmateSubform = ( Cstr( doc.isAttachmateSubform( 0 )) = "1" )
		isAttachmateTemplate = ( Cstr( doc.attachmateTemplate( 0 )) = "1" ) And doc.Isuidocopen
		
		If doc.Getitemvalue(ATTACHMATE_TEMPLATE_ITEM)( 0 ) <> "" Then
			Call attachmate.template.setTemplate( doc.Getitemvalue(ATTACHMATE_TEMPLATE_ITEM)( 0 ))
		End If
		
		Set storage = New AttachmateStorage(attachmate)
		Call storage.init( doc, "" )
		
		If Not handle Is Nothing Then 
			Call handle.closefile()
			Set handle = Nothing
		End If
	End Function
	
%REM
		Function hasHandle
		Description: Comments for Function
%END REM
	Function hasHandle() As Boolean
		hasHandle = Not (handle Is Nothing)
	End Function
	
%REM
		Function getHandle
		Description: Comments for Function
%END REM
	Function getHandle() As AbstractHandle
		If Not debug Then On Error Goto eh
		
		If handle Is Nothing Then
			Dim filename As String
			filename = storage.detach()
			If filename = "" Then 
				Msgbox "Can't detach file", 64, "MISSING" 
				Exit Function
			End If
			
			'make a backup file
			If attachmate.settings.doBackup() Then
				On Error Resume Next
				Dim backupfile As String
				backupfile = Strleftback( filename, "." ) & "-bak." & Strrightback( filename, "." )
				Filecopy filename, backupfile
				If Err > 0 Then Print Err, getErrorInfo( Me ) 
				If Not debug Then On Error Goto eh
			End If
			
			Set handle = attachmate.getHandle( filename )
			
			If Not attachmate.template.hasTemplate And Not isTemplate() Then
				If doc.Getitemvalue(ATTACHMATE_TEMPLATE_ITEM)( 0 ) <> "" Then
					Call attachmate.template.setTemplate( doc.Getitemvalue(ATTACHMATE_TEMPLATE_ITEM)( 0 ))
				End If
			End If
		End If
		
		Set getHandle = handle
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function createFromTemplate
		Description: Comments for Function
%END REM
	Public Function createFromTemplate( template As Variant )
		If uidoc.editmode Then Call uidoc.Refresh()
		
		If Not debug Then On Error Goto eh
		createFromTemplate = False
		
		If storage.hasFile() Or Not handle Is Nothing Then
			'There is a file allready. Overwrite?
			If Not replaceFile Then Exit Function
			If Not handle Is Nothing Then Call handle.closefile()
			Call attachmate.template.clear()
			Call doc.Replaceitemvalue( ATTACHMATE_TEMPLATE_ITEM, "" )
		End If
		
		If attachmate.template.setTemplate( template ) Then
			Dim filename As String
			filename = attachmate.template.detach()
			
			If filename <> "" Then
				createFromTemplate = createFromFile( filename, True )
			End If
		End If
		
		If uidoc.Editmode Then Call uidoc.Refresh()
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function replaceFile
		Description: Comments for Function
%END REM
	Private Function replaceFile() As Boolean
		If attachmate.silentmode Then
			replaceFile = True
		Else
			replaceFile = ( ws.Prompt( PROMPT_YESNO, getLanTxt( "REPLACEFILE_TITLE" ), getLanTxt( "REPLACEFILE" )) = 1 )
		End If
	End Function
	
%REM
		Function createFromFile
		Description: Comments for Function
%END REM
	Public Function createFromFile( filename As String, doLaunch As Boolean )
		If Not debug Then On Error Goto eh
		
		If storage.hasFile() Or Not handle Is Nothing Then
			'There is a file allready. Overwrite?
			If Not replaceFile Then Exit Function
			If Not handle Is Nothing Then Call handle.closefile()
			Call attachmate.template.clear()
			Call doc.Replaceitemvalue( ATTACHMATE_TEMPLATE_ITEM, "" )
		End If
		
		'Dim filename As String
		If filename = "" Then
			filename = attachmate.selectOSFile( True, "open" )
		End If
		If filename = "" Then Exit Function
		
		Call logAttachmateAction( "create" )
		Call attachmate.mergedata.loadMergeDocument(doc)
		
		Set handle = attachmate.getHandle( filename )
		
		If Not attachmate.mergedata.hasCollection() Then
			Call attachmate.mergedata.loadMergeCollection(doc.attachmateMergeUnids)
		End If
		
		handle.isnew = True
		handle.editmode = True
		If uidoc.Editmode And doLaunch Then
			Call handle.launch() 'dont launch file, if notes document is in readmode
		End If
		
		
		Call doc.Replaceitemvalue( ATTACHMATE_ITEM, handle.getType() )
		Call doc.Replaceitemvalue( ATTACHMATE_TEMPLATE_ITEM, attachmate.template.getId())
		Call doc.Replaceitemvalue( ATTACHMATE_TITLE_ITEM, attachmate.cTitle( handle.getFilename()))
		
		If uidoc.editmode Then 
			Call uidoc.Refresh()
		Else
			'document is in readmode - but please save the attachment
			Call storage.attach()
			Call storage.save()
			handle.isnew = False
			handle.editmode = False
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function attachFile
		Description: Comments for Function
%END REM
	Function attachFile( filename As String )
		
	End Function
	
	
%REM
		Function isTemplate
		Returns true if a attachmate template document is open
%END REM
	Function isTemplate() As Boolean
		If Not hasDocument Then 
			isTemplate = False 
			Exit Function
		End If
		isTemplate = isAttachmateTemplate
		
	End Function
	
%REM
		Function isSubformOpen
		Description: Comments for Function
%END REM
	Function isSubformOpen() As Boolean
		isSubformOpen = isAttachmateSubform
	End Function
	
%REM
		Function openFolder
		Description: Comments for Function
%END REM
	Public Function openFolder()
		Dim path As String
		path = attachmate.getAttachmatePath()
		
		Dim w As New WinFiles
		Call w.shellExecute( path, "open", SW_SHOWNORMAL )
		
	End Function
	
%REM
		Function restore
		Description: Replace the attachment with a file from the attachmate folder
%END REM
	Function restore()
		If Not debug Then On Error Goto eh
		
		'Overwrite existing file?
		If storage.hasFile() Or Not handle Is Nothing Then
			If Not replaceFile Then Exit Function
			If Not handle Is Nothing Then Call handle.closefile()
			Call attachmate.template.clear()
			Call doc.Replaceitemvalue( ATTACHMATE_TEMPLATE_ITEM, "" )
		End If
		
		'select a new file		
		Call session.setEnvironmentVar( "Attachmate.lastpath", attachmate.getAttachmatePath())
		filename = attachmate.selectOSFile( True, "save" )
		If filename = "" Then Exit Function
		
		Call attachmate.mergedata.loadMergeDocument(doc)
		Set handle = attachmate.getHandle( filename )
		
		If Not attachmate.mergedata.hasCollection() Then
			Call attachmate.mergedata.loadMergeCollection(doc.attachmateMergeUnids)
		End If
		
		handle.isnew = True
		handle.editmode = True
		Call handle.launch()
		
		Call logAttachmateAction( "Attachment restored" )
		
		Call doc.Replaceitemvalue( ATTACHMATE_ITEM, handle.getType() )
		'Call doc.Replaceitemvalue( ATTACHMATE_TEMPLATE_ITEM, attachmate.template.getId())
		'Call doc.Replaceitemvalue( ATTACHMATE_TITLE_ITEM, attachmate.cTitle( handle.getFilename()))
		
		If uidoc.editmode Then Call uidoc.Refresh()
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function openTemplate
		Description: Comments for Function
%END REM
	Public Function openTemplate()
		Dim tmpDoc As NotesDocument
		
		If Not attachmate.template.hasTemplate And Not isTemplate() Then
			If doc.Getitemvalue(ATTACHMATE_TEMPLATE_ITEM)( 0 ) <> "" Then
				Call attachmate.template.setTemplate( doc.Getitemvalue(ATTACHMATE_TEMPLATE_ITEM)( 0 ))
			End If
		End If
		
		Set tmpdoc = attachmate.template.getDocument()
		If tmpDoc Is Nothing Then
			Print "Error - no template found"
		Else
			Call ws.Editdocument( False, tmpDoc )
		End If
	End Function
	
%REM
		Delete the file from the document
%END REM
	Public Function remove()
		If attachmate.silentmode Then Goto removefile
		
		If Not handle Is Nothing Then
			If handle.isChanged() Then
				'Document has been changed
				If ws.Prompt( PROMPT_YESNO, getLanTxt( "DELETEFILES_TITLE" ), getLanTxt( "DELETECHANGEDFILES" )) = 0 Then Me.remove = False: Exit Function
			Elseif handle.isOpen() Then
				'document is open
				If handle.editmode Then
					If ws.Prompt( PROMPT_YESNO, getLanTxt( "DELETEFILES_TITLE" ), getLanTxt( "DELETEOPENFILES" )) = 0 Then Me.remove = False: Exit Function
				Else
					'open in read mode: default msg
					If ws.Prompt( PROMPT_YESNO, getLanTxt( "DELETEFILES_TITLE" ), getLanTxt( "DELETEFILES" )) = 0 Then Me.remove = False: Exit Function
				End If
			Else
				'not open: default msg
				If ws.Prompt( PROMPT_YESNO, getLanTxt( "DELETEFILES_TITLE" ), getLanTxt( "DELETEFILES" )) = 0 Then Me.remove = False: Exit Function
			End If
		Else
			'not open: default msg
			If ws.Prompt( PROMPT_YESNO, getLanTxt( "DELETEFILES_TITLE" ), getLanTxt( "DELETEFILES" )) = 0 Then Me.remove = False: Exit Function
		End If	
		
removefile:
		
		'clear attachment
		Call logAttachmateAction( "remove" )
		Call storage.remove()
		'Call storage.appendLog( "Document deleted" )
		
		'clear fields
		Call doc.Replaceitemvalue( ATTACHMATE_ITEM, "" )
		Call doc.Replaceitemvalue( ATTACHMATE_TEMPLATE_ITEM, "" )
		Call doc.Replaceitemvalue( ATTACHMATE_TITLE_ITEM, "" )
		Call doc.Replaceitemvalue( ATTACHMATE_EXTERNALREF_ITEM, "" )
		Call doc.Replaceitemvalue( ATTACHMATE_ICON_ITEM, "" )
		
		'clear other
		Set handle = Nothing
		Call uidoc.Refreshhideformulas()
	End Function
	
%REM
		Function edit
		Description: Comments for Function
%END REM
	Function edit()
		If isTemplate Then 
			Call attachmate.template.setTemplate( doc )
		Elseif doc.getItemValue( ATTACHMATE_TEMPLATE_ITEM )( 0 )<>"" Then
			Call attachmate.template.setTemplate( doc.getItemValue( ATTACHMATE_TEMPLATE_ITEM )( 0 ))
		End If
		
		If uidoc.editmode Then Call uidoc.Refresh()
		
		Call logAttachmateAction( "edit" )
		Call openfile( True )
	End Function
	
	Function read()
		Call logAttachmateAction( "read" )
		Call openfile( False )
	End Function
	
%REM
		Function openfile
		Description: Comments for Function
%END REM
	Private Function openfile( editmode As Boolean )
		If Not debug Then On Error Goto eh
		On Error ATTACHMATE_ERR_APPLICATION_BUSY GoTo BUSY
		
		If isSubformOpen() Then
			Call attachmate.mergedata.loadMergeDocument(doc)
		End If
		
		Call getHandle()
		
		If Not handle Is Nothing Then
			If Not handle.editmode Then handle.editmode = editmode
			
			If handle.isOpen() Then
				Call handle.show()
			Else
				Call handle.launch()
			End If
		End If
		
done:
		Exit Function
BUSY:
		MsgBox parseParams( getLanTxt( "NOTRESPONDING" ), StrRightBack( handle.getFilename(), "\" ), handle.getType(), "", "" ), 64, getLanTxt( "NOTRESPONDING_TITLE" )
		Resume done
eh:
		Error Err, getErrorInfo( Me )
		Resume done
	End Function
	
	Function print()
		Call getHandle()
		If Not handle Is Nothing Then
			Call logAttachmateAction( "print" )
			Call handle.Print()
			If Not isSubformOpen() Then Call handle.closefile()
		End If
	End Function
	
%REM
		Function saveAs
		Filetype: 1=Save attachment/detach (ATTACHMATE_CONVERT_NO) or 2=save as PDF (ATTACHMATE_CONVERT_PFD)
%END REM
	Function saveAs( conversion As Integer ) As String
		Dim tmpFilename As String
		Call logAttachmateAction( "save as" )
		
		Select Case conversion
		Case ATTACHMATE_CONVERT_NO: 'detach file
				'select a folder and filename
			Dim v As Variant
			Dim ws As New NotesUIWorkspace
			v = ws.Savefiledialog(False, "Save as...", "", Environ("HOMEPATH"), storage.getFilename())
			
			If Not Isempty( v ) Then
				tmpFilename = storage.detachTo( Strleftback(v( 0 ), "\" ), Strrightback(v( 0 ), "\" ) )
				Print "File saved as: " & tmpFilename
			End If
			
				'select a folder
%REM
				Dim path As String
				path = getDirDlg( )
				
				If path <> "" Then
					tmpFilename = storage.detachTo( path, "" )
					Print "File saved as: " & tmpFilename
				End If
%ENDREM
		Case Else:
			Call getHandle()
			If Not getHandle Is Nothing Then
				tmpFilename = handle.convertFile( conversion )
				Call handle.closefile()
			End If
		End Select
		
		saveAs = tmpFilename
	End Function
	
%REM
		Function copyAs
		Description: Copy the attachmate file to a RichText item as a normal file attachment 
%END REM
	Function copyAs( destDoc As NotesDocument, itemname As String, conversion As Integer ) As Boolean
		Dim filename As String
		Dim body As NotesRichTextItem
		copyAs = False
		
		Call logAttachmateAction( "copy" )
		
		Set body = destDoc.Getfirstitem(Itemname)
		If body Is Nothing Then Set body = destDoc.Createrichtextitem(Itemname)
		
		Select Case conversion
		Case ATTACHMATE_CONVERT_NO: 'detach file
			If handle Is Nothing Then
				filename = storage.detach()
			Else
				filename = handle.getFilename()
			End If
			
			If filename <> "" Then
				Call body.Addnewline(1)
				Call body.Embedobject(EMBED_ATTACHMENT, "", filename)
				copyAs = True
				
				If attachmate.hasMergefile() Then
					Call body.Embedobject(EMBED_ATTACHMENT, "", attachmate.getMergefilename())
					destDoc.attachmateFile = Strrightback( filename, "\" )
				End If
				If handle Is Nothing Then Kill filename
			End If
			
		Case Else
			Call getHandle()
			If Not handle Is Nothing Then
				filename = handle.convertFile( conversion ) 
				If filename <> "" Then
					Call body.Addnewline(1)
					Call body.Embedobject(EMBED_ATTACHMENT, "", filename)
					destDoc.attachmateFile = Strrightback( filename, "\" )
					copyAs = True
					Kill filename
				End If
				Call handle.closefile()
			End If
		End Select
	End Function
	
%REM
		Function CreateMail
		Description: Comments for Function
		
		Returns true is a mail is create/sent
%END REM
	Private Function createMailFromTemplate( conversion As Integer, memoTemplates As Variant ) As Boolean
		createMailFromTemplate = False
		If memoTemplates( 0 ) = "" Then Exit Function
		
%REM
		Dim script As String
		script = |
use "cls.fw.memo.ui"
dim mt as new MemoTemplateManager()
dim memo as new MemoUI()
call CacheManager.pushObject( "MemoTemplateManager", mt )
call CacheManager.pushObject( "Memo", memo )
|
		Dim v As Variant
		v = Execute( script )
		
		Dim template As NotesDocument
		Set template = CacheManager.getObject("MemoTemplateManager").getTemplate( session.Currentdatabase, memoTemplates )
		
		Dim memo As Variant
		Set memo = CacheManager.getObject( "Memo" )
		Call memo.setTemplate( session.Currentdatabase, template )
		Call memo.create( ws.Currentdocument.document, Nothing )
		If copyAs( memo.getDocument(), "body", conversion ) Then
			Call memo.process()
			createMailFromTemplate = True
		End If
%ENDREM
		
		Dim mt As New MemoTemplate()
		Dim template As NotesDocument
		If Ubound( memoTemplates ) = 0 Then
			Set template = mt.getTemplate( session.Currentdatabase, memoTemplates( 0 ) )
		Else
			Set template = mt.getTemplate( session.Currentdatabase, memoTemplates )
		End If
		
		If template Is Nothing Then
			createMailFromTemplate = True 'user cancelled
			'or just: End
			Exit Function
		End If
		
		Dim memo As New MemoUI
		Call memo.setTemplate( session.Currentdatabase, template )
		Call memo.create( ws.Currentdocument.document, Nothing )
		If copyAs( memo.getDocument(), "body", conversion ) Then
			Call memo.process()
			createMailFromTemplate = True
		End If
		
	End Function
	
%REM
	Function convert
	Description: Comments for Function
	Returns the filename
%END REM
	Public Function convert( conversion As Integer ) As String
		Dim convertedFilename As String
		Call getHandle()
		If Not handle Is Nothing Then
			convert = handle.convertFile( conversion ) 
		End If
	End Function
	
	Function mailAs( conversion As Integer )
		Call logAttachmateAction( "mail as" )
		
		If createMailFromTemplate( conversion, doc.Getitemvalue("AttachmateMemoTemplates")) Then
			Exit Function
		End If
		
		'no template found - just create a plain mail		
		Dim filename As String
		Dim mailDb As New NotesDatabase( "", "" )
		Dim memo As NotesDocument
		Dim body As NotesRichTextItem
		
		Call mailDb.openMail()
		If Not mailDb.isopen Then Error 9000, "Can't open the mail database"
		Set memo = mailDB.Createdocument()
		memo.form = "Memo"
		
		If copyAs( memo, "body", conversion ) Then
			memo.subject = "File: " & memo.attachmateFile( 0 )
		End If
		Set body = memo.Getfirstitem("body")
		If body Is Nothing Then Set body = memo.Createrichtextitem("body")
		
		'append signature
		Dim calendarProfile As NotesDocument 
		Set calendarProfile = mailDb.GetProfileDocument("CalendarProfile")
		If calendarProfile.EnableSignature( 0 ) = "1" Then  
			If calendarProfile.HasItem("Signature_Rich") Then 'new 8.5 signature
				Dim tmpRtf As NotesRichTextItem
				Set tmpRtf = calendarProfile.Getfirstitem("Signature_Rich")
				Call body.Appendrtitem(tmpRtf)
			Else
				If calendarProfile.SignatureOption( 0 ) = "1" Then
					Call body.AppendText( calendarProfile.signature( 0 ))
				End If
			End If
		End If
		
		'open the mail
		Call memo.save( True, False )
		Call ws.Editdocument(True, memo)
	End Function
	
	Sub QuerySave(Source As NotesUIDocument, continue As Variant)
		On Error ATTACHMATE_ERR_APPLICATION_BUSY GoTo BUSY
		Call recalc()
		If Not handle Is Nothing Then
			
			'If handle.IsOpen() Then
				Call handle.executeScript( "onsave" )
			'End If
		End If
		
done:
		Exit Sub
BUSY:
		MsgBox parseParams( getLanTxt( "NOTRESPONDING" ), StrRightBack( handle.getFilename(), "\" ), handle.getType(), "", "" ), 64, getLanTxt( "NOTRESPONDING_TITLE" )
		continue = False
		Resume done	
	End Sub
	
%REM
		Function recalc
		Description: Comments for Function
%END REM
	Function recalc()
		If doc.disabled( 0 ) ="1" Then
			Call doc.replaceItemValue( ATTACHMATE_ICON_ITEM, 81 )
		Else
			Select Case Lcase( doc.attachmate_1( 0 ))
			Case "word", "excel", "pdf", "powerpoint", "project", "sigma":
				Call doc.replaceItemValue( ATTACHMATE_ICON_ITEM, "icon." & Lcase( doc.attachmate_1( 0 )) & ".jpg" )
			Case Else 
				Call doc.replaceItemValue( ATTACHMATE_ICON_ITEM, "" )
			End Select
		End If
	End Function
	
	Sub Querymodechange(Source As NotesUIDocument, Continue As Variant)
		On Error ATTACHMATE_ERR_APPLICATION_BUSY GoTo BUSY
		If source.editmode Then 'user goes from edit to read
			If Not handle Is Nothing Then	
				If handle.isOpen Then 'is file still open
					'document in edit mode and file is open -> please close the file before the document	
					Msgbox parseParams( getLanTxt( "OPENDOCS" ), Strrightback( handle.getFilename(), "\" ), handle.getType(), "", "" ), 64, getLanTxt( "OPENDOCS_TITLE" )
					Continue = False
					Print "Readmode cancelled"
					Exit Sub
				End If
			End If
		End If
		
done:
		Exit sub
BUSY:
		MsgBox parseParams( getLanTxt( "NOTRESPONDING" ), StrRightBack( handle.getFilename(), "\" ), handle.getType(), "", "" ), 64, getLanTxt( "NOTRESPONDING_TITLE" )
		continue = false
		Resume done
	End Sub
	
	Sub Postmodechange(Source As NotesUIDocument)
		
	End Sub
	
	Sub Queryrecalc(Source As NotesUIDocument, Continue As Variant)
		
	End Sub
	
	Sub Postopen(Source As NotesUIDocument)
		If source.Isnewdoc Then Call readOptions
		
		Call setDocument( source.document )
		
		If Iselement( options( "autoread" )) Then 
			If Not source.editmode Then Call Me.read()
		End If
		If Iselement( options( "autoedit" )) Then Call Me.edit() 
	End Sub
	
	Sub Postrecalc(Source As NotesUIDocument)
		
	End Sub
	
	Sub Postsave(Source As NotesUIDocument)
		isSaved = True
	End Sub
	
	Sub Querysend(Source As NotesUIDocument, Continue As Variant)
		
	End Sub
	
	Sub Postsend(Source As NotesUIDocument)
		
	End Sub
	
	Sub Queryopen(Source As NotesUIDocument, Mode As Integer, Isnewdoc As Variant, Continue As Variant)
		Set uidoc = source
		Set doc = uidoc.Document
		
		Set storage = New AttachmateStorage(attachmate)
		
		'On Event QueryOpen From uidoc Call QueryOpen
		On Event QuerySave From uidoc Call QuerySave
		'On Event QuerySend From uidoc Call QuerySend
		On Event QueryClose From uidoc Call QueryClose
		On Event QueryModechange From uidoc Call QueryModechange
		'On Event QueryRecalc From uidoc Call QueryRecalc
		
		On Event PostOpen From uidoc Call PostOpen
		'On Event PostModeChange From uidoc Call PostModeChange
		'On Event PostRecalc From uidoc Call PostRecalc
		On Event PostSave From uidoc Call PostSave
		'On Event PostSend From uidoc Call PostSend
		
		'QueryOpen
		Call readOptions()
		If Iselement( options( "autoread" )) Then 
			If Not source.Editmode Then
				Call Me.read()
				continue = False
			End If
		End If
	End Sub
	
%REM
		Function isEditDisabled
		Description: Comments for Function
%END REM
	Private Function isEditDisabled() As Boolean
		If Not Isnull( Arraygetindex( doc.AttachmateDisabledFeatures, "edit", 5 )) Then
			isEditDisabled = True
		Elseif doc.attachmate_1_checkinout( 0 ) <> "" Then
			isEditDisabled = True
		Else
			isEditDisabled = False
		End If
	End Function
	
	Sub QueryClose(Source As NotesUIDocument, Continue As Variant)
		On Error ATTACHMATE_ERR_APPLICATION_BUSY GoTo BUSY
		Dim doSave As Boolean
		If handle Is Nothing Then Goto done 'no files
		
		Dim editDisabled As Boolean
		editDisabled = isEditDisabled()
		
		If handle.isOpen Then 'the file is still open
			If source.Editmode Then
				If editDisabled Then Goto done 'user not allowed to edit (just reading the document), so it is safe to close the notes document
				'document in edit mode and file is open -> please close the file before the document			
				Msgbox parseParams( getLanTxt( "OPENDOCS" ), Strrightback( handle.getFilename(), "\" ), handle.getType(), "", "" ), 64, getLanTxt( "OPENDOCS_TITLE" )
				Continue = False
				Print "Close cancelled"
				Exit Sub
			Elseif Not handle.editmode And Not handle.isChanged Then
				'no changes to the file -> it is safe to close
				Goto done
			Else 'file is open and has/might be changed // document is in read mode -> ask the user
				Goto whatnow
			End If
		Else 'file is closed
			If handle.isChanged() Then 'file is changed
				If isSaved Then
					If editDisabled Then
						'edit disabled -> we can't save
						Goto whatnow
					Else
						'document has been save -> we assume that the user wants to save the file as well
						Goto attach
					End If
					
				Else
					If source.editmode Or handle.editmode Then 
						If ws.Prompt( PROMPT_YESNO, getLanTxt( "SAVEDOC_TITLE" ), parseParams( getLanTxt( "SAVEDOC" ), Strrightback( handle.getFilename(), "\" ), handle.getType(), db.Title, "" )) = 1 Then
							If editDisabled Then 
								Goto whatnow
							Else
								Goto attach
							End If
						Else
							Goto done
						End If
					Else
						'document is in read mode and file has been changed -> ask the user
						Goto whatnow
					End If
				End If
			Else 'no changes to file -> just close
				Goto done
			End If
		End If
		
		Goto done
		
whatnow:
		Dim q As Variant
		q = Split( getLanTxt( "CHANGEDFILE_OPTIONS" ), "," )
		
		If editDisabled Then
			'dont allow document to be saved back
			q( 0 ) = ""
			q = Fulltrim( q )
		End If
		
		Dim a As String
		Set ws = New NotesUIWorkspace
		a = ws.Prompt(PROMPT_OKCANCELLIST, getLanTxt( "CHANGEDFILE_TITLE" ), parseParam( getLanTxt( "CHANGEDFILE" ), Strrightback( handle.getFilename(), "\" )),  q( 0 ), q )
		
		If editDisabled Then
			Select Case a
			Case q( 0 ): Call mailMe( handle.getFilename())
			Case q( 1 ): Goto done
			Case Else
				Continue = False
				Print "Close cancelled"
				Goto done
			End Select
		Else
			Select Case a
			Case q( 0 ): Goto attach
			Case q( 1 ): Call mailMe( handle.getFilename())
			Case q( 2 ): Goto done
			Case Else
				Continue = False
				Print "Close cancelled"
				Goto done
			End Select
		End If
		Goto done
attach:	
		'save attachments
		doSave = storage.attach()
		
		'save document
		If doSave Then
			Call storage.save()
			'Call doc.Save( True, False )
			isSaved = True
			Print "File saved: " & Strrightback( handle.getFilename(), "\" )
		End If
done:
		If Not handle Is Nothing Then 
			If Not handle.isOpen Then
				Call handle.closefile() 'close the file
			End If
			Call attachmate.cleanup() 'delete temporary files on disk
		End If
		
		
terminate:
		Exit Sub
BUSY:
		MsgBox parseParams( getLanTxt( "NOTRESPONDING" ), StrRightBack( handle.getFilename(), "\" ), handle.getType(), "", "" ), 64, getLanTxt( "NOTRESPONDING_TITLE" )
		continue = False
		Resume terminate	
	End Sub
	
%REM
		Function mailMe
		Send the current file to the user
%END REM
	Private Function mailMe( filename As String )
		Dim mail As NotesDocument
		Set mail = db.Createdocument()
		mail.form = "Memo"
		mail.subject = "Saved filed: " & Strrightback( filename, "\" )
		mail.sendto = session.Username
		
		Dim body As NotesRichTextItem
		Set body = mail.Createrichtextitem("body")
		
		Call body.AppendText( "Saved file attached" & Chr( 10 ))
		Call body.AppendText( Chr( 9 ) & "Source database: " )
		Call body.Appenddoclink( db, "Click me" )
		Call body.Appendtext( " " & db.title & Chr( 10 ))
		Call body.AppendText( Chr( 9 ) & "Source document: " )
		Call body.Appenddoclink( doc, "Click me" )
		Call body.Appendtext( " " & doc.subject( 0 ) & Chr( 10 ))
		
		Call body.Addnewline(1)
		Call body.Embedobject( EMBED_ATTACHMENT, "", filename )
		
		Call mail.send( False )
	End Function
End Class
Public Class SourceCollections As AbstractObject
	
	Private sourceDb List As NotesDatabase 'for the sourceColl
	Private sourceColl List As NotesDocumentCollection 
	
	Private collCount As Integer
	
	Private currentColl As Integer
	Private currentDoc As NotesDocument
	
	Private attachmate As Attachmate
	Private progress As Progress
	
	Sub New( attachmate As Attachmate )
		Set Me.attachmate = attachmate
	End Sub
	
%REM
		Function hasData
		Description: Comments for Function
%END REM
	Function hasData() As Boolean
		On Error Goto eh
		hasData = False
		If collCount = 0 Then Exit Function
		
		Dim i As Integer
		Forall coll In sourceColl
			If Not coll Is Nothing Then
				Select Case Typename( coll )
				Case "NOTESVIEW"
					hasData = True
					Exit Function
					
				Case "NOTESDOCUMENTCOLLECTION"
					If coll.count > 0 Then
						hasData = True
						Exit Function
					End If
					
				End Select
			End If
			
		End Forall
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function getCollection
		Description: Comments for Function
%END REM
	Function getCollection( id As Integer ) As NotesDocumentCollection
		On Error Goto eh
		Set getCollection = sourceColl( id )
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function clear
		Description: Comments for Function
%END REM
	Function clear()
		On Error Goto eh
		Erase sourceDb
		Erase sourceColl
		collCount = 0
		currentColl = 0
		Set currentDoc = Nothing
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function add
		Description: Comments for Function
%END REM
	Function addCollection( coll As Variant )
		On Error Goto eh
		If coll Is Nothing Then Exit Function
		If coll.count = 0 Then Exit Function
		
		Set sourceDb( collCount ) = coll.Parent
		Set sourceColl( collCount ) = coll
		collCount = collCount+1
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function addView
		Description: Comments for Function
%END REM
	Function addView( view As Variant )
		Dim coll As NotesDocumentCollection
		Dim doc As NotesDocument
		
		Set coll = view.Parent.createDocumentCollection()
		Set doc = view.getFirstDocument
		Do Until doc Is Nothing
			If doc.Isdeleted Then Goto nextdoc
			If Not doc.isvalid Then Goto nextdoc
			
			Call coll.Adddocument(doc)			
nextdoc:
			Set doc = view.getNextDocument( doc )
		Loop		
		Call addCollection( coll )
	End Function
	
%REM
		Function addDocument
		Description: Comments for Function
%END REM
	Function addDocument( doc As Variant )
		Dim coll As NotesDocumentCollection
		Set coll = doc.Parentdatabase.createDocumentCollection()
		Call coll.Adddocument(doc)
		Call addCollection( coll )
	End Function
	
%REM
		Function addQuery
		Description: Comments for Function
%END REM
	Function addQuery( database As Variant, query As String )
		Dim sourceDb As NotesDatabase
		Set sourceDb = CacheManager.getDatabase( database )
		
		If sourceDb Is Nothing Then
			Print "Can't find the source database: " & cString( database )
		Else
			Dim coll As NotesDocumentCollection
			Set coll = sourceDb.Search(query, Nothing, 0)
			
			Call addCollection( coll )
		End If
	End Function
	
%REM
		Function addUnids
		Description: Comments for Function
%END REM
	Function addUnids( source As Variant )
		On Error Goto eh
		If Not Isarray( source ) Then
			Error 9000, "function AddUnids requires an array"
		End If
		
		Dim sourceDb As NotesDatabase
		Set sourceDb = session.currentDatabase
		Dim tmpSourceColl As NotesDocumentCollection
		Set tmpSourceColl = sourceDb.createDocumentCollection()
		
			'list of document unids
		If source( 0 ) = "" Then Exit Function 'no data
		Dim tmpDoc As NotesDocument
		
		Dim columns As Variant
		Dim unidColumn As Integer 'default = 0 (only one column with the unid)
		columns = Split( "unid", "#" )
		
		If Left(source( 0 ),1)="<" Or Instr( source( 0 ), "=" ) > 0 Then
			If attachmate.resolve(source(0), sourceDb, Nothing ) Then
					'everything is fine
					'<extra columns> (E&P)
				Dim i As Integer
				If Iselement( attachmate.params( "columns" )) Then
					columns = Split( attachmate.params( "columns" ), "#")
					For i = 0 To Ubound( columns )
						If Lcase( columns( i )) = "unid" Then unidColumn = i : Exit For
					Next			
				End If
					'</extra columns>
			Else
				Error Err, "Can't find the source database: " & source( 0 )
			End If
		End If
		
			'Set sourceColl = sourceDb.Getprofiledoccollection("Give me an empty collection")
		On Error Resume Next 'don't fail on invalid unids
		Dim data As Variant
		Dim unid As String
		Forall entry In source
			data = Split( entry, "#" )
			unid = data( unidColumn )				
			If unid = "" Then Goto nextunid
			If Left( unid, 1 ) = "<" Then Goto nextunid
			If Len( unid ) <> 32 Then Goto nextunid
			
			On Error Resume Next
			If attachmate.document.getDocument().Universalid = unid Then
				Set tmpDoc = attachmate.document.getDocument() 'this is the current document (can't be found by the .getDocumentByUnid if it is a new note)
				If tmpDoc.Isnewnote Then 
					If tmpDoc.Isuidocopen Then
						Dim ws As New NotesUIWorkspace
						Call ws.currentDocument.save()
					Else
						Call tmpDoc.save( True, False ) 'must be saved in order to merge data
					End If
					
					Print "Saving the document (can't merge with unsaved documents)"
					Print ""
				End If
			Else
				Set tmpDoc = sourceDb.Getdocumentbyunid(unid)
			End If
			On Error Goto eh
			If tmpDoc Is Nothing Then
				Print "Error: Source document unid not found: " & unid
			Else
					'<add extra columns>
				If Ubound( columns ) > 0 Then 'there is extra columns
					For i = 0 To Ubound( columns )
						If i <> unidColumn Then
							Call tmpDoc.Replaceitemvalue( columns( i ), data( i ))
						End If
					Next
					
						'Set docCache( tmpDoc.noteid ) = tmpDoc 'store the document - otherwise the extra columns is lost 
				End If
					'</add extra columns>
				If Not tmpSourceColl.contains( tmpDoc ) Then
					Call tmpSourceColl.addDocument( tmpDoc )
				End If
			End If
nextunid:
		End Forall
		
		Call addCollection( tmpSourceColl )
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function getFirst
		Description: Comments for Function
%END REM
	Function getFirst() As NotesDocument
		On Error Goto eh
		
		currentColl = 0
		Set getFirst = getFirstInCurrentCollection()
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function getFirstInCurrentCollection
		Description: Comments for Function
%END REM
	Private Function getFirstInCurrentCollection() As NotesDocument
		On Error Goto eh
		Set currentDoc = sourceColl( currentColl ).getFirstDocument()
		Set getFirstInCurrentCollection = currentDoc
		
		Set progress = New Progress( sourceColl( currentColl ).count )
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function getNext
		Description: Comments for Function
%END REM
	Function getNext() As NotesDocument
		On Error Goto eh
		Set currentDoc = sourceColl( currentColl ).getNextDocument(currentDoc)
		
		Dim msg As String
		msg = "Processed: %1"
		If collCount > 1 Then
			msg = msg & parseParams( " (source: %1/%2)", currentcoll+1, collCount, "", "" )
		End If
		Call progress.print( msg, progress.increment())
		
		If currentDoc Is Nothing Then
			If ( currentColl+1 ) < collCount Then
				currentColl = currentColl+1
				Set getNext = getFirstInCurrentCollection()
				Exit Function
			End If
		End If
		
		Set getNext = currentDoc
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
End Class

%REM
	This class controls the file on the disk
	- Launch file (using OLE with with MS Office)
	- Merge data
%END REM

Public Class AbstractHandle As AbstractObject
	Private attachmate As Attachmate
	Private obj As Variant 'OLE handle to the file
	Private filename As String 'the filename
	Private filedate As Variant 'date/time of the file when detached
	
	Public editmode As Boolean 'used by the AttachmateDocument to track the mode
	Public isnew As Boolean  'used by the AttachmateDocument to track the mode
	
	Sub New(attachmate As Attachmate)
		Set Me.attachmate = attachmate
		Set obj = Nothing
		editmode = False
		isnew = False
		
		If debug Then Print parseParam( "New %1 handle", getType() )
	End Sub
	
	Function isOpen() As Boolean
		isOpen = False 
	End Function
	
	Function isChanged() As Boolean
		isChanged = False 'default
		On Error Resume Next 'don't stop if file is missing
		isChanged = ( Filedatetime( filename ) <> filedate	) Or isNew
	End Function
	
%REM
		Function ExecuteFeature
		Description: Comments for Function
%END REM
	Function ExecuteFeature( id As String, params As Variant ) As Variant
		Error 9000, "Features not supported by " & getType()
	End Function
	
	
	Function setFilename( filename As String ) 
		If Not debug Then On Error Goto eh
		Me.filename = filename
		On Error Resume Next
		
		If Me.filedate = "" Then
			Me.filedate = Filedatetime( filename )
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Public Function getAttachmate() As Attachmate
		Set getAttachmate = attachmate
	End Function
	
	Function getFilename() As String
		getFilename = filename
	End Function
	
	Function getType() As String
		getType = "Abstract"
	End Function
	
	
%REM
		Returns the COM object
%END REM
	Function getObjectRef As Variant
		Set getObjectRef = obj
	End Function
	
%REM
		Return true if we have  a valid COM object
%END REM
	Function hasObject() As Boolean
		hasObject = True
	End Function
	
%REM
		Create a new object in memory
%END REM
	Function create() As Boolean
		
	End Function
	
%REM
		Create object, the load file
%END REM
	Function createFromFile( filename As String ) As Boolean
		Call setFilename( filename )
	End Function
	
%REM
		Saves the file using the current filename
%END REM
	Function save() As Boolean
		
	End Function
	
%REM
		Saves the file using a new filename
%END REM
	Function saveAs( filename As String ) As Boolean
		Call setFilename( filename )
		
	End Function
	
%REM
		Function merge
		Description: Comments for Function
%END REM
	Function merge() As Boolean
		merge = True
	End Function
	
%REM
		Function beforeLaunch
		Override this - typically used to prepare a merge file
%END REM
	Function beforeLaunch()
		
	End Function
	
%REM
		Opens the current file (visible = true)
%END REM
	Function launch() As Boolean
		'Call executeScript( "queryopen" )
		'Call executeScript( "postopen" )
		'Call executeMacro( "queryopen" )
		'Call executeMacro( "postopen" )
	End Function
	
%REM
		Give focus to the application
%END REM
	Function show() As Boolean
		show = True
	End Function
	
	Private isExecutingScript As Boolean
	Private currentEvent As string
	
%REM
		Function executeScript
		Description: Comments for Function
%END REM
	Function executeScript( eventname As String )
		If Not debug Then On Error Goto eh
		Dim v As Variant
		Dim scriptcode As String
		isExecutingScript = True
		currentEvent = eventname
		
		If attachmate.document.isTemplate() Then Exit Function
		
		If attachmate.template.hasTemplate() Then
			Forall script In attachmate.template.getField( eventname & "Script" )
				If Fulltrim( script ) <> "" Then
					Set sourceDocument = attachmate.mergedata.getDocument()
					If sourceDocument Is Nothing Then Set sourceDocument = attachmate.document.getDocument()
					Set sourceObject = obj
					'If hasObject() Then Print "OK - " 
					Set sourceHandle = Me
					scriptcode = script
					v = Execute( script )
				End If
			End Forall
		End If
		
		isExecutingScript = false
		Exit Function
eh:
		Print scriptcode
		Msgbox "Error in " & eventname & " script, line " & Erl, 64, "Execute Script Error"
		Resume Next
		Error Err, getErrorInfo( Me )		
	End Function
	
	
%REM
		Function executeMacro
		Description: Comments for Function
%END REM
	Function executeMacro( eventname As String )
		If Not debug Then On Error Goto eh
		
		If attachmate.document.isTemplate() Then Exit Function
		
		If attachmate.template.hasTemplate()  Then
			Forall macro In attachmate.template.getField( eventname & "Macro" )
				If Fulltrim( macro ) <> "" Then
					Call runMacro( Fulltrim( Cstr( macro )))
				End If
			End Forall
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	
%REM
		Will execute the specified macros
%END REM
	Function runMacro( macro As String )
		
	End Function
	
%REM
		Prints the document
%END REM
	Function Print() As Boolean
	End Function
	
%REM
		Function getFile
		Returns the filename of the converted filed
%END REM
	Function convertFile( conversion As Integer ) As String
		
	End Function
	
%REM
		Function setFocus
		Description: Comments for Function
%END REM
	Function setFocus()
	End Function
	
%REM
		Close the object / clean up
%END REM
	Function closefile()
		Call executeScript( "onclose" )
		Call cleanup()
	End Function
	
	
%REM
		Deletes the file on disk according to settings on the profile document
%END REM
	Private Function cleanup()
		On Error Goto eh
		Dim days As Integer
		days = attachmate.settings.keepfiles
		If days = 0 Then
			Kill filename
			If debug Then Print "Temporary file deleted: " & filename
		Else
			'let somebody else do the cleanup
		End If
		
done:
		Exit Function
eh:
		If debug Then Print getErrorInfo( Me )
		Resume done 'errors wont stop us
	End Function
	
	Function eval( formula As String, source As NotesDocument ) As Variant
		Dim v As Variant
		On Error Goto ERRORHANDLER
		
		If Lcase( Left( formula, 7 )) = "@script" Then
			Dim library As String
			Dim functionname As String
			Dim script As String
			library = Strleft( Strright( Strleft( formula, "," ), |"| ), |"| )
			functionname = Strleft( Strright( Strright( formula, "," ), |"| ), |"| )
			script = |use "| & library & |"| & Chr( 10 ) & |returnString = | & functionname & |( sourceDocument, sourceObject )| 
			Set sourceDocument = source
			Set sourceObject = obj
			v = Execute( script )
			eval = returnString
		Else
			v = Evaluate( formula, source )
			eval = Join( v	 )			
		End If		
		
DONE:
		Exit Function
ERRORHANDLER:
		v = parseParam( "Error in formula: %1", Error )
		Call Me.logAction( LOG_WARNING_LOW, Cstr( v ), Nothing )
		eval = v
		Resume DONE
	End Function
	
End Class
Class OtherHandle As AbstractHandle
	Private win As WinFiles
	
	Private stayAliveTimer As Variant 'don't close file before this time (needed to secure printing from view)
	
	Sub New(attachmate As Attachmate)
		stayAliveTimer = Now 'close at anytime
	End Sub
	
	Function getType() As String
		Dim ext As String
		ext = Lcase( Strrightback( filename, "." ))
		
		Select Case ext
		Case "": getType = "Other"
		Case "mpp" : getType = "Project"
		Case "ppt", "pptm", "pptx", "pot", "potm", "potx" : getType = "Powerpoint"
		Case "gif", "tif", "jpg", "bmp" : getType = "Image"
		Case Else
			getType = ext
		End Select
	End Function
	
	Function closefile()
		Do While stayAliveTimer > Now
			Yield
		Loop
		Call AbstractHandle..closefile() 'delete the files
	End Function
	
	
%REM
		Function convertFile
		Description: Comments for Function
%END REM
	Function convertFile( conversion As Integer ) As String
		convertFile = filename
	End Function
	
	Function isOpen() As Boolean
		isOpen = False 
		If Dir( filename ) = "" Then Goto DONE 'no file
		If Getfileattr( filename ) = 1 Then Goto DONE 'File is open in readonly mode / ATTR_READONLY
		
		On Error Goto ERRORHANDLER
		On Error 101 Goto ERROR_OPEN
		
		'check if file is open
		Dim f As Integer
		f = Freefile
		Open filename For Input Access Read Lock Read Write As f
		Close
DONE:
		Exit Function
		
ERROR_OPEN:
		isOpen = True
		Resume DONE
		
ERRORHANDLER:
		Print Err, getErrorInfo( Me ) & " (" & filename & ")"
		isOpen = True
		Resume DONE
	End Function
	
	
%REM
		Function openfile
		Description: Comments for Function
%END REM
	Private Function openfile( action As String ) As Boolean
		If Not debug Then On Error Goto eh
		
		Call AbstractHandle..launch()
		
		Select Case session.platform
		Case "Windows/32"
			Dim rc As Long
			Set win = New WinFiles
			rc = win.shellExecute( filename, action, SW_SHOWMAXIMIZED)
			
			If rc <= 32 And rc > 0 Then
				Error Cint(rc), LastDllErrorInfo( Cint( rc ))
			End If
		Case Else
			Error 0, "Unsupported platform (" & session.Platform & ")"
		End Select
		
		openfile = True
done:
		Exit Function
eh:
		openfile = False
		'	Error Err, getErrorInfo( Me )
		Print Err, getErrorInfo( Me )
		Resume done	
	End Function
	
	Function launch( ) As Boolean
		If Not debug Then On Error Goto eh
		Call AbstractHandle..launch()
		launch = openFile( "open" )
		
		Call executeScript( "queryopen" )
		Call executeScript( "postopen" )
		Call executeMacro( "queryopen" )
		Call executeMacro( "postopen" )
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function Print() As Boolean
		If Not debug Then On Error Goto eh
		Me.print = openFile( "print" )
		stayAliveTimer = Now+(1/86400) 'need sometime to open and print the file
		If debug Then Print "Don't terminate before: " & stayAliveTimer
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function setFocus
		Description: Comments For Function
%END REM
	Function setFocus()
		Call win.giveFocus()
	End Function
End Class

%REM
	Class ExcelHandle
	Description: Comments for Class
%END REM
Class ExcelHandle As OtherHandle 'AbstractHandle
	Private book As Variant
	Private sheet As Variant
	
	%REM
		Sub New
		Description: Comments for Sub
	%END REM
	Sub New(attachmate As Attachmate)
		
	End Sub
	
	Function getType() As String
		getType = "Excel"
	End Function
	
	Function hasObject() As Boolean
		hasObject = False
		If obj Is Nothing Then Exit Function
		If Not Isobject( book ) Then Exit Function
		If book Is Nothing Then Exit Function
		If Not Isobject( sheet ) Then Exit Function
		If sheet Is Nothing Then Exit Function
		On Error Goto ERRORHANDLER
		
		
		If obj.Worksheets( 1 ) Is Nothing Then hasObject = False : Exit Function ''this is needed 06.02.2013 majkilde
		hasObject = True
DONE:
		Exit Function
		
ERRORHANDLER:
		hasObject = False
		Resume DONE
	End Function
	
	
	Function isOpen() As Boolean
		On Error GoTo eh
		If Dir( filename ) = "" Then isOpen = False : Exit Function 'no file
		
		If hasObject() Then
			Dim books As Variant
			Set books = obj.workbooks
			ForAll b In books
				If b Is book Then
					isOpen = True
					Exit Function
				End If
			End ForAll
			
			'sheet not found - must be closed
			isOpen = False
'			Exit Function
			
'checksheet:
'			Dim v As Variant
'			v = sheet.visible 'this will fail if the worksheet is closed
'			isOpen = obj.Visible
		Else
			isOpen = False
		End If
		
done:
		Exit Function
eh:
		Print "Stopped in " & Erl
		Error ATTACHMATE_ERR_APPLICATION_BUSY, "Excel is busy"
	End Function
	
	
%REM
		Function create() As Boolean
		Set obj = CreateObject("Excel.Application")
		obj.Visible = False
		Set book = obj.Workbooks.add()
		Set sheet = obj.Worksheets( 1 ) 
		
		create = True
		End Function
%ENDREM
	
	Function createFromFile( filename As String ) As Boolean
		If Not debug Then On Error Goto eh
		Call AbstractHandle..createFromFile( filename ) 'set the filename
		Dim d As String
		d = Dir( filename, 0 ) 'ATTR_NORMAL
		If d = "" Then Error 9000, "File not found: " & filename
		
		'create new excel object
		On Error Resume Next
		Set obj = GetObject("","Excel.Application")
		If obj Is Nothing Then
			Set obj = CreateObject("Excel.Application")
		End If
		If Not debug Then On Error Goto eh
		'load the document
		'check if the document is allready open
		If Not obj.workbooks Is Nothing Then
			Forall excelBook In obj.workbooks
				If excelBook.fullname = filename Then 
					Set book = excelBook
					If Not Isobject( book ) Then 
						Msgbox getLanTxt( "NOTRESPONDING_EXCEL" ), 64, getLanTxt( "NOTRESPONDING_EXCEL_TITLE" )
						
						createFromFile = False
						Call Show() 'give focus to excel
						End
					End If
					Goto found
				End If
			End Forall
		End If
		
		'open file
		Print "Excel is loading the file ... "
		Set book = obj.Workbooks.open( filename )
		Print ""
		
		'disable alerts (6.12.2012)
		obj.DisplayAlerts = False
found:
		Set sheet = Nothing
		If attachmate.template.hasTemplate() Then
			Dim sheetname As String
			sheetname = attachmate.template.getDocument().getItemValue("excelDefaultSheet")(0)
			If sheetname <> "" Then
				Set sheet = book.Worksheets( sheetname )
			End If
		End If
		If sheet Is Nothing Then
			Set sheet = book.Worksheets( 1 )
		End If
		
		If Not isExecutingScript then
			Call show()
		End if
		createFromFile = True
done: 
		Exit Function 
eh: 
		Print Err, getErrorInfo( Me ) 
		Msgbox "Lost the connection to Excel. Please close the open document in both Lotus Notes and Excel and try again" , 64, "Excel connection error" 
		createFromFile = False 
		Resume done 
	End Function

	
	Function convertFile( conversion As Integer ) As String
		On Error Goto eh
		
		Select Case conversion
		Case ATTACHMATE_CONVERT_PDF:
			If Not hasObject() Then
				Call createFromFile( filename )
			End If
			
			Dim pdfFilename As String
			Const xlTypePDF = 0
			Const xlQualityStandard = 0
			Const IncludeDocProperties = True
			Const IgnorePrintAreas = False
			Const OpenAfterPublish = False
			
			pdfFilename = Strleftback( filename, "." ) & ".pdf"
			
			Call sheet.ExportAsFixedFormat( xlTypePDF, pdfFilename, xlQualityStandard, IncludeDocProperties, IgnorePrintAreas )', OpenAfterPublish )
			
			convertFile = pdfFilename
			
		Case Else
			convertFile = filename
		End Select
		
done:
		Exit Function
eh:
		Print Err, getErrorInfo( Me )
		convertFile = ""
		Resume done
	End Function
	
	
	
	Function save() As Boolean
		If obj Is Nothing Then save = False : Exit Function
		Call AbstractHandle..save()
		Call book.save()
	End Function
	
	Function saveAs( filename As String ) As Boolean
		Call AbstractHandle..saveAs( filename )
		If obj Is Nothing Then saveAs = False : Exit Function
		Call book.saveAs( filename )
	End Function
	
	Function launch( ) As Boolean
		If Not debug Then On Error Goto eh
		Call AbstractHandle..launch() 
		
		If Not hasObject() Then
			If Not createFromFile( filename ) Then Print "Can't create the Excel object?" 
		End If
		
		If hasObject() Then	
			Call merge()
			
			Call executeScript( "queryopen" )
			Call executeScript( "postopen" )
			launch = show()
			If isNew Then
				Call executeScript( "oncreate" )
				Call executeMacro( "oncreate" )
				'isNew = False 'removed 3.01.2011 by majkilde
			End If
			
			Call executeMacro( "queryopen" )
			Call executeMacro( "postopen" )
			
		Else
			Print "Launch failed"
			launch = False
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function show() As Boolean
		If Not debug Then On Error Goto eh
		If hasObject() Then
			obj.Visible = True
			Call setFocus() 'give focus to excel
			
			show = True
		Else
			show = False
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
%REM
		Function setFocus
		Description: Comments for Function
%END REM
	Function setFocus()
		On Error Resume Next
		Activateapp obj.caption
	End Function
	
	
	Function runMacro( macro As String )
		If Not debug Then On Error Goto eh
		If macro <> "" Then
			Call obj.run( macro )
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
%REM
		Function updateProperties
		Fieldname: "excelCells" or "excelProperties"
%END REM
	Private Function updateProperties( sourceDoc As NotesDocument, template As AttachmateTemplate, fieldname As String )
		On Error Goto eh
		Dim Field As String
		Dim formula As String
		Dim value As Variant
		
		Forall entry In template.getField( fieldname )
			If entry = "" Then Goto nextentry
			
			field = Fulltrim( Strleft( entry, ":=" ))
			formula = Fulltrim( Strright( entry, ":=" ))
			
			If field = "" Then Goto nextentry
			If formula = "" Then Goto nextentry
			
			value = Evaluate( formula, sourceDoc )	
			value = Join( value, ", " )
			
			If value="" Then
				If attachmate.document.isTemplate Then
					value = "<<" & Field & ">>"
				End If
			End If
			
			'update
			Call insert( Field, Cstr( value ), Lcase( fieldname ) = "excelproperties")
			
nextentry:	
		End Forall
		
		Exit Function	
eh:
		Print "Error: " & getErrorInfo( Me )
		Resume Next 'don't fail on this...
	End Function
	
	Function insert( position As Variant, value As Variant, isProperty As Boolean )
		On Error Goto eh
		If Isarray( position ) Then
			sheet.Cells( position( 0 ), position( 1 )).value = value
		Else
			If isProperty Then 'setting the properties
				
				'checking for a builtin property
				Forall p In book.BuiltinDocumentProperties
					If Strcomp( p.name, position, 5 ) = 0 Then
						'builtin property found
						'Print "Updating builtin, " & p.name & ":=" & value
						p.value = value
						Goto done
					End If
				End Forall
				
				'custom property
				Forall p In book.CustomDocumentProperties
					'Print "Custom property: " & p.name & ":=" & p.value
					If Strcomp( p.name, position, 5 ) = 0 Then
						'custom property found
						'Print "Updating custom, " & p.name & ":=" & value
						p.value = value
						Goto done
					End If
				End Forall	
				
				'Print "Adding a new custom property, " & position & ":=" & value
				Call book.CustomDocumentProperties.add( Cstr( position ), False, 4, value ) 'msoPropertyTypeString=4
				
			Else 'cell
				If Instr( position, "!" ) > 0 Then
					Dim sheetname As String
					Dim rangename As String
					sheetname = Strleft( position, "!" )
					rangename = Strright( position, "!" )
					If Isnumeric( value ) Then 
						obj.sheets( sheetname ).range( rangename ).value = Replace( Cstr( value ), ",", "." ) 
					Else 
						obj.sheets( sheetname ).range( rangename ).value = value 
					End If
				Else
					sheet.range( position ).value = value
				End If
			End If
		End If
done:
		Exit Function
eh:
		Print parseParams( "Error (%1:=%2) %3", position, value, getErrorInfo( Me ), "" )
		Resume Next
	End Function
	
%REM
		Function merge
		Description: Comments for Function
%END REM
	Function merge() As Boolean
		Dim mergeInReadMode As Boolean
		Dim template As NotesDocument
		Set template = attachmate.template.getDocument()
		If Not template Is Nothing Then
			mergeInReadMode = template.getItemValue( "excelMergeInReadMode" )( 0 ) = "1"
		End If
		
		If editmode Or isNew Or mergeInReadMode Then 'don't update a document in read mode
			If Not attachmate.template.hasTemplate Then Exit Function 'need a template 
			
			If attachmate.mergedata.hasDocument() Then
				'update document properties 
				Call updateProperties( attachmate.mergedata.getDocument(), attachmate.template, "excelCells" )
				Call updateProperties( attachmate.mergedata.getDocument(), attachmate.template, "excelProperties" )
			End If
			
			
			If attachmate.document.isTemplate Then
				Call attachmate.mergedata.loadMergeCollection( attachmate.document.getDocument() )
			End If
			
			If attachmate.mergedata.hasCollection() Then
				Call mergeCollection()
			End If
		End If
		
		merge = True
	End Function
	
%REM
		Function mergeCollection
		Description: Comments for Function
%END REM
	Function mergeCollection()
		If Not debug Then On Error Goto eh
		
		Dim data() As Variant 'the final data (to push to excel)
		Redim data( 0 )
		Dim count As Integer 'number of rows
		
		Dim columns List  As String 'the column
		Dim c As Integer 'column counter
		
		Dim hasHeader As Boolean
		hasHeader = ( attachmate.template.getFieldString( "excelIncludeHeader" ) = "1" )
		
		'get the column formulas
		Forall entry In attachmate.template.getField( "excelMergeFields" )
			If entry = "" Then Goto nextentry
			c = c+1
			Dim Field As String
			Dim formula As String
			If Instr( entry, ":=" ) > 0 Then
				Field = Fulltrim( Strleft( entry, ":=" ))
				formula = Fulltrim( Strright( entry, ":=" ))
			Else
				Field = "Column " & c
				formula = Fulltrim( entry )
			End If
			columns( Field ) = formula
			
nextentry:
		End Forall
		
		If c = 0 Then Goto done 'no data
		
		Dim record() As Variant
		Redim record( c-1 )
		Dim i As Integer
		
		If hasHeader Then
			'build header record
			Forall column In columns
				record( i ) = Listtag( column )
				i = i+1
			End Forall	
			
			'add header
			Redim Preserve data( count )
			data( count ) = record
			count = count+1
		End If
		
		'build the data array
		Dim v As Variant
		Dim source As NotesDocument
		Dim coll As Variant
'		Set coll = attachmate.mergedata.getCollection()
'		Set source = coll.Getfirstdocument()
		
		Set source = attachmate.mergedata.getFirst()
		Do Until source Is Nothing
			i = 0 
			Forall f In columns
				If f = "" Then
					record( i ) = ""
				Else
					On Error Resume Next 
					Err = 0 
					v = Evaluate( f, source ) 
					If Err > 0 Then 
						Print "Error in formula: " & f 
					End If
					
					If Not debug Then On Error Goto eh
					If Isarray( v ) Then 
						record( i ) = v( 0 ) 'no multivalue join - user must do this in the @formula
					Else
						record( i ) = ""
					End If
				End If
				i = i +1
			End Forall
			
			'add record
			Redim Preserve data( count )
			data( count ) = record
			count = count+1
			
			'Set source = coll.Getnextdocument(source)
			Set source = attachmate.mergedata.getNext()
		Loop
		
		
		'update excel
		Dim col As Integer
		Dim row As Integer
		
		'make the array Excel compatible (crab - hate when this is nessesary)
		Dim values() As Variant
		Redim values( count-1, c-1 ) 'values( rows, columns )
		For row = 0 To count-1
			v = data( row )
			For col = 0 To c-1
				values( row, col ) = v( col ) 		
			Next
		Next
		
		'start cell
		Dim sheetname As String
		Dim datasheet As Variant
		Dim formatTable As Boolean
		With attachmate.template.getDocument()
			sheetname = .getItemValue( "excelTableSheet")( 0 )
			If sheetname = "" Then
				Set datasheet = sheet 'use first
			Else
				On Error Resume Next
				Set datasheet = book.Worksheets( sheetname ) 'use the named sheet
				If Not debug Then On Error Goto eh
				If datasheet Is Nothing Then Set datasheet = sheet
			End If
			
			col = .getItemValue( "excelTableColumn" )( 0 )
			row = .getItemValue( "excelTableRow" )( 0 )
			
			formatTable = .getItemValue( "excelFormatTable" )( 0 ) = "1"
		End With
		
		'send all data to excel (fastest way to transfer data to excel)
		Dim range As Variant
		
		'insert
		Const templateTableHeight = 2
		If count > templateTableHeight Then
			Set range = datasheet.Range( datasheet.Cells(row+templateTableHeight, col), datasheet.Cells(row+count-1, col+c-1))
			range.insert( -4121 ) 'shift down
		End If
		
		'fill
		Set range = datasheet.Range( datasheet.Cells(row, col), datasheet.Cells(row+count-1, col+c-1))
		range.Value = values
		
		If formatTable Then
			If hasHeader Then
				datasheet.ListObjects.Add( 1, range,, 1 ).Name = "Notesdata" 
			Else
				datasheet.ListObjects.Add( 1, range,, 2 ).Name = "Notesdata"
			End If
		End If
		
		'refresh / recalculate
		book.refreshAll
		
%REM		
		'Format the table
    	DataSheet.ListObjects("Notesdata").TableStyle = "TableStyleDark4" 'note - don't use style names as these will not work with other languages
%ENDREM
		
done:
		Exit Function
eh:
		Print getErrorInfo( Me )
		Resume Next
	End Function
	
	
	Function Print() As Boolean
		Call book.PrintOut()
	End Function
	
	Function closefile()
		On Error Resume Next
		
		If Not book Is Nothing Then book.Close False
		Set book = Nothing
		Set sheet = Nothing
		
		'just minimize
		obj.visible = True
		obj.WindowState = 2 
		
		'If Not obj Is Nothing Then obj.Quit
		'Set obj = Nothing
		
		Call AbstractHandle..closefile()
	End Function
	
End Class
Class Path As AbstractObject
	Private path As String
	
%REM
	path: the default path. Use 'TEMP' or 'MY' to use the default temp or 'My Documents' path
%END REM
	Sub New( path As String )
		Select Case Ucase( path )
		Case "TEMP":
			Me.path = getTempPath()
		Case "MY":
			Me.path = getMyDocuments()
		Case Else
			Me.path = path			
		End Select
		
		Call legalize()
	End Sub
	
%REM
	Returns the 'My Documents' path
%END REM
	Private Function getMyDocuments() As String
		Dim formula As String
		formula = |@RegQueryValue( "HKEY_CURRENT_USER" ; "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders" ; "Personal" )|
		Dim v As Variant
		v = Evaluate( formula )
		getMyDocuments = v( 0 )
	End Function
	
%REM
		Function getTempPath
		Returns the temp path
%END REM
	Private Function getTempPath() As String
		getTempPath = Environ( "temp" )
	End Function
	
	Function add( subdir As String )
		On Error Goto eh
		subdir = Replace( subdir, "/", "\" )
		If Left( subdir, 1 ) = "\" Then
			path = path & Mid( subdir, 1 )
		Else
			path = path & subdir 
		End If
		Call legalize()
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function getPath() As String
		getPath = path
	End Function
	
%REM
		Convert to a legal path (remove illegal chars)
%END REM
	Private Function legalize()
		On Error Goto eh
		Const ILLEGAL_CHARS = |*?:"|
		Dim char As String
		Dim s As String
		Dim i As Integer
		
		Me.path = Replace( path, "/", "\" )
		If Right( path, 1 ) <> "\" Then path = path & "\"
		
		s = ""
		
		'Note - : is legal if in second position
		If Mid( path, 2, 1 ) = ":" Then
			s = Left( path, 2 ) 
			path = Mid( path, 3 )
		End If
		
		For i = 1 To Len( path )
			char = Mid( path,i ,1 )	
			If Instr( ILLEGAL_CHARS, char ) = 0 Then
				s = s & char
			End If
		Next
		
		path = s
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	Function create( )
		On Error Goto eh
		Dim v As Variant
		Dim p As String
		
		v = Split( path, "\" )
		
		p = v( 0 )
		Dim i As Integer
		For i = 1 To Ubound( v )
			If v( i ) <> "" Then
				p = p & "\" & v( i ) 
				If Dir( p, 16+4+2 ) = "" Then 'ATTR_DIRECTORY + ATTR_HIDDEN + ATTR_SYSTEM
					Mkdir( p )
				End If
			End If
		Next
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
End Class
%REM
	Use this to merge an existing attachmate document, with selected documents - 
	creating a new reponsedocument to each selected
%END REM
Class AttachmateMerger As AbstractObject
	Private attachmate As Attachmate
	Private doc As NotesDocument
	Private db As NotesDatabase
	Private handle As AbstractHandle 'the office document
	
	Sub New( attachmate As Attachmate, doc As NotesDocument )
		Set Me.attachmate = attachmate
		Set Me.doc = doc
		Set Me.db = doc.parentDatabase
	End Sub
	
%REM

		This will merge the current document (first attachment) with the Colletion (NotesView or NotesDocumentCollection)
%END REM
	Function mergeCollection( collection As Variant, doSave As Boolean, doPrint As Boolean )
		Dim parent As NotesDocument 'document from the collection with the merge data
		Dim letter As NotesDocument 'holds the final letter (after merging)
		Dim template As NotesDocument 'template document with mapping info (original template)
		
		Dim storage As AttachmateStorage
		'doc is the merge document (document that contains the merge letter)
		
		'detach the template / get the current file
		'		Set handle = getAttachmateManager.getHandle( 1 )
		Set handle = attachmate.document.getHandle()
		handle.editmode = True
		
		Set parent = collection.getFirstDocument()
		Do Until parent Is Nothing 'loop on all documents in the collection
			Set letter = createDocument( parent, doc )
			
			'merge
			Set attachmate.mergeData = New AttachmateMergedata( attachmate ) 'reset
			Call attachmate.mergedata.loadMergeDocument(parent)	
			Call handle.merge()
			
			'print?
			If doPrint Then
				Call handle.print()
			End If
			
			'save?
			If doSave Then
				'attach to new document
				Call handle.save()
				
				Set storage = New AttachmateStorage(attachmate)
				Call storage.init( letter, "" )
				Call storage.attach()
				
				Call letter.Replaceitemvalue( ATTACHMATE_ITEM, handle.getType())
				Call letter.Replaceitemvalue( ATTACHMATE_TEMPLATE_ITEM, attachmate.template.getId())
				Call letter.Replaceitemvalue( ATTACHMATE_TITLE_ITEM, attachmate.cTitle( handle.getFilename()))
				
				'save changes
				Call saveDocument( letter )
			End If
			
			'set markings
			Call mark( doc, parent, letter )
			
			'next document
			Set parent = collection.getNextDocument( parent )
		Loop
		
		
		'close
		Call handle.closefile()
		
		Call Me.done()
	End Function
	
	Function done()
	End Function
	
	Function mark( template As NotesDocument, parent As NotesDocument, letter As NotesDocument )
	End Function
	
	Function createDocument( parent As NotesDocument, template As NotesDocument ) As NotesDocument
		Dim letter As NotesDocument
		Set letter = db.CreateDocument
		Set createDocument = letter
	End Function
	
	Function saveDocument( letter As NotesDocument )
		Call letter.Save( True, False )
	End Function
	
End Class

Class SigmaHandle As AbstractHandle
	Private win As WinFiles
	
	Private stayAliveTimer As Variant 'don't close file before this time (needed to secure printing from view)
	
	Sub New(attachmate As Attachmate)
		stayAliveTimer = Now 'close at anytime
	End Sub
	
	Function getType() As String
		getType = "Sigma"
	End Function
	
	Function closefile()
		Do While stayAliveTimer > Now
			Yield
		Loop
		Call AbstractHandle..closefile() 'delete the files
	End Function
	
%REM
		Function merge
		Description: Comments for Function
%END REM
	Function merge() As Boolean
		On Error Goto eh
		Dim element As String
		Dim formula As String
		Dim selection As String
		Dim attribute As String
		Dim value As Variant
		Dim v As Variant
		
		If Not hasObject() Then
			Call createFromFile( filename )
		End If
		
		If editmode Or isNew Then 'don't update a document in read mode
			If Not attachmate.template.hasTemplate Then Exit Function 'need a template 
			
			If attachmate.mergedata.hasDocument() Then
				Dim stopwatch As New Stopwatch
				Call stopwatch.start("XML")	
				
				Dim xml As New XML
				Call xml.loadFile( filename )
				Forall entry In attachmate.template.getField( "sigma" )
					If entry = "" Then Goto nextentry
					
					'decifre the input
					element = Lcase( Fulltrim( Strleft( entry, ":=" )))
					If Instr( element, "," ) > 0 Then
						selection = Strright( element, "," )
						element = Strleft( element, "," )
					Else
						selection = ""
					End If
					
					If Instr( element, "@" ) > 0 Then
						attribute = Strright( element, "@" )
						element = Strleft( element, "@" )
					Else
						attribute = ""
					End If
					
					formula = Fulltrim( Strright( entry, ":=" ))
					
					If element = "" Then Goto nextentry
					If formula = ""  Then 
						value = ""
					Else
						value = Evaluate( formula, attachmate.mergedata.getDocument())	
						value = Join( value, ", " )
					End If
					
					If value="" Then
						If attachmate.document.isTemplate Then
							value = "<<" & element & ">>"
						End If
					End If
					
					'update the XML
					Dim i As Integer
					v = xml.xpath( element ) 'find the elements
					
					If selection <> "" Then 'filter
						Dim filtervalue As Variant
						filtervalue = Evaluate( Strright( selection, "=" ), attachmate.document.getDocument() )
						filtervalue = cstring( filtervalue )
						
						'find value
						If Lcase(Strleft( selection, "=" )) = "value" Then
							For i = 0 To Ubound( v )
								If Strcomp( v(i).getValue(), filtervalue, 5 ) <> 0 Then
									Set v( i ) = Nothing 'no match -> remove
								End If
							Next
						Elseif Left( selection, 1 ) = "@" Then
							Dim attribname As String
							attribname = Strright( Strleft( selection, "=" ), "@" )
							For i = 0 To Ubound( v )
								Dim ee As element
								If Strcomp( ee.getAttribute( attribname ), filtervalue, 5 ) <> 0 Then
									Set v( i ) = Nothing 'no match -> remove
								End If
							Next
						End If
					End If
					
					Forall e In v
						If Not e Is Nothing Then
							If attribute = "" Then
								Call e.setValue( Cstr( value ))
							Else
								Call e.addAttribute(attribute, Cstr( value))
							End If
						End If
					End Forall
					
nextentry:
				End Forall
				
%REM Old merge
				'get data
				'element[,selection]:=formula

				Dim data List As variant
				
				ForAll entry In attachmate.template.getField( "sigma" )
					If entry = "" Then GoTo nextentry
					
					element = LCase( FullTrim( StrLeft( entry, ":=" )))
					If InStr( element, "," ) > 0 Then
						selection = StrRight( element, "," )
						element = StrLeft( element, "," )
					Else
						selection = ""
					End If
					formula = FullTrim( StrRight( entry, ":=" ))
					
					If element = "" Then GoTo nextentry
					If formula = "" Then GoTo nextentry
					
					value = Evaluate( formula, attachmate.mergedata.getDocument())	
					value = Join( value, ", " )
					
					If value="" Then
						If attachmate.document.isTemplate Then
							value = "<<" & element & ">>"
						End If
					End If
					
					'update
					data( element ) = value
					
nextentry:	
				End ForAll
%ENDREM
				
%REM Old merge				
'				Call stopwatch.start("XML")
'				Dim xml As New XMLHandler()
'				Call xml.mergeDataToFile( filename, data )
'				Print "Merge done in: " & stopwatch.getTimeStr("XML")
'				
%ENDREM				
				
				
				Call xml.saveFile( filename )
				Print "Merge done in: " & stopwatch.getTimeStr("XML")
				Print ""
			End If
		End If
		
done:
		merge = True
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
%REM
		Function isZip
		Description: Comments for Function
%END REM
	Function isXML() As Boolean
		If filename = "" Then Exit Function
		Dim f As Integer
		Dim s As String
		
		f = Freefile
		Open filename For Input As f
		s = Input$( 5, #f )
		Close #f
		
		If Strcomp( s, "<?XML", 5 ) = 0 Then
			isXML = True
		Else
			isXML = False
		End If
		
	End Function
	
%REM
		Function convertFile
		Description: Comments for Function
%END REM
	Function convertFile( conversion As Integer ) As String
		convertFile = filename
	End Function
	
	Function isOpen() As Boolean
		isOpen = False 
		If Dir( filename ) = "" Then Goto DONE 'no file
		If Getfileattr( filename ) = 1 Then Goto DONE 'File is open in readonly mode / ATTR_READONLY
		
		On Error Goto ERRORHANDLER
		On Error 101 Goto ERROR_OPEN
		
		'check if file is open
		Dim f As Integer
		f = Freefile
		Open filename For Input Access Read Lock Read Write As f
		Close
DONE:
		Exit Function
		
ERROR_OPEN:
		isOpen = True
		Resume DONE
		
ERRORHANDLER:
		Print Err, getErrorInfo( Me ) & " (" & filename & ")"
		isOpen = True
		Resume DONE
	End Function
	
	
%REM
		Function openfile
		Description: Comments for Function
%END REM
	Private Function openfile( action As String ) As Boolean
		If Not debug Then On Error Goto eh
		
		Call AbstractHandle..launch()
		
		Select Case session.platform
		Case "Windows/32"
			Dim rc As Long
			Set win = New WinFiles
			rc = win.shellExecute( filename, action, SW_SHOWMAXIMIZED)
			
			If rc <= 32 And rc > 0 Then
				Error Cint(rc), LastDllErrorInfo( Cint( rc ))
			End If
		Case Else
			Error 0, "Unsupported platform (" & session.Platform & ")"
		End Select
		
		openfile = True
		
		Exit Function
eh:
		openfile = False
		Error Err, getErrorInfo( Me )
		
	End Function
	
%REM
		Function zip
		Description: Comments for Function
%END REM
	Function zip
		Dim xmlfilename As String
		
		'rename the file
		xmlfilename = Strleftback( filename, "." ) & ".xml"
		Name filename As xmlfilename
		
		'late binding
		
		Call CacheManager.pushValue( "filename", filename )
		Call cachemanager.pushValue( "xmlfilename", xmlfilename )
		
		Dim script As String
		script = |
Use "ZipFileManager LS"
sub initialize()
		dim filename as String
		dim xmlfilename as string
		
		filename = CacheManager.getValue("filename")
		xmlfilename = CacheManager.getValue("xmlfilename")

		Dim zipFile As New ZipFileManager( filename )
		
		Call zipfile.addEntry( xmlFilename )
		Call zipfile.close()
end sub
|
		
		Dim v As Variant
		v = Execute( script )
		'zip
%REM
		Dim zipFile As New ZipFileManager( filename )
		
		Call zipfile.addEntry( xmlFilename )
		Call zipfile.close()
%ENDREM
	End Function
	
%REM
		Function unzip
		Description: Comments for Function
%END REM
	Function unzip
		Dim zipfilename As String
		
		'rename the file
		zipfilename = Strleftback( filename, "." ) & ".zip"
		Name filename As zipfilename
		
		'late binding
		Call CacheManager.pushValue( "filename", filename )
		Call cachemanager.pushValue( "zipfilename", zipfilename )
		
		Dim script As String
		script = |
Use "ZipFileManager LS"
sub initialize()
		dim filename as String
		dim zipfilename as string
		
		filename = CacheManager.getValue("filename")
		zipfilename = CacheManager.getValue("zipfilename")

		Dim zipFile As New ZipFileManager( zipFileName )
		
		ForAll entryname In zipfile.getEntryNames()
			call zipfile.saveEntryAsFile( CStr( entryname), filename )
		End ForAll
		Call zipfile.close()
end sub
|
		
		Dim v As Variant
		v = Execute( script )
		
		'unzip
%REM
		Dim zipFile As New ZipFileManager( zipFileName )
		
		ForAll entryname In zipfile.getEntryNames()
			call zipfile.saveEntryAsFile( CStr( entryname), filename )
		End ForAll
		Call zipfile.close()
%ENDREM
		
		'update the local settings
		filedate = Filedatetime( filename )
	End Function
	
	Function launch( ) As Boolean
		If Not debug Then On Error Goto eh
		
		Call AbstractHandle..launch()
		
		If Not isXML Then
			'unzip file (can only manipulate data in the raw xml file)
			Call unzip
		End If
		
		If Lcase( Strright( filename, "." )) = "sit" Then
			Dim newfilename As String
			newfilename = Strleft( filename, "." ) & ".sig"
			Name filename As newfilename
			filename = newfilename
			Print "Renamed to " & filename
		End If
		
		If Instr( filename, "+" ) > 0 Then 'sigma doesn't support + in the filename
			newfilename = Replace( filename, "+", " " )
			Name filename As newfilename
			filename = newfilename
			Print "Renamed to " & filename
		End If
		
		'set the filedate
		filedate = Filedatetime( filename ) 
		
		If isNew Then
			Call executeScript( "oncreate" )
			Call executeMacro( "oncreate" )
			'isNew = False 'removed 3.01.2011 by majkilde
		End If
		
		If editmode Or isNew Then Call merge()
		
		Call executeScript( "queryopen" )
		Call executeMacro( "queryopen" )
		
		'Print filename
		launch = openFile( "open" )
		
		Call executeScript( "postopen" )
		Call executeMacro( "postopen" )
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function Print() As Boolean
		If Not debug Then On Error Goto eh
		Me.print = openFile( "print" )
		stayAliveTimer = Now+(1/86400) 'need sometime to open and print the file
		If debug Then Print "Don't terminate before: " & stayAliveTimer
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function setFocus
		Description: Comments For Function
%END REM
	Function setFocus()
		Call win.giveFocus()
	End Function
End Class
%REM
	Class OneClickExport
	Description: Comments for Class
%END REM
Class OneClickExport As AbstractObject
	Function run( doc As NotesDocument )
		Dim session As New NotesSession
		
		'current document/template
		Dim ws As New NotesUIWorkspace
		
		'attachmate
		Dim attachmate As Attachmate
		Set attachmate = getAttachmate()
		
		
		'Attachmate stuff
		Call attachmate.template.setTemplate(doc) 
		Call attachmate.document.setDocument( doc )
		
		Call attachmate.mergedata.loadMergeDocument(doc)
		'Call attachmate.mergedata.loadMergeCollection(coll)
		
		Call attachmate.mergedata.clear()
		Forall database In doc.exportDatabase
			Call attachmate.mergedata.addMergeQuery(database,doc.exportQuery( 0 ) )
		End Forall
		
%REM
			'get the database
		Dim db As NotesDatabase
		Set db = CacheManager.getDatabase( doc.exportDatabase( 0 ))
		
		'get the source documents
		Dim coll As NotesDocumentCollection
		Set coll = db.Search( doc.exportQuery( 0 ), Nothing, 0 )
		Print parseParam( "Found %1 matching documents", coll.count )
		
%END REM
		
		'Do the merge and launch the result
		Dim handle As AbstractHandle
		Set handle = attachmate.document.getHandle()
		handle.isNew = True 'mark as new (for events to work properly)
		handle.editmode = True
		Call handle.launch()
	End Function
End Class
%REM
	Class XML
	Description: Comments for Class
%END REM
Private Class XMLHandler As AbstractObject
	Private data As Variant
	'Private f As Integer
	
	Private domdoc As NotesDOMDocumentNode
	Private level As Integer
	Private elements() As String
	
%REM
		Sub New
		Description: Comments for Sub
%END REM
	Sub New( )
	'	f = freefile
	'	Open "c:\temp\debug.txt" For Output As f 
		level = 0 
		Redim elements( 0 )
	End Sub
	
	Sub Delete
		Close
	End Sub
	
%REM
		Function mergeDataToFile
		Data: list of elements/values
%END REM
	Function mergeDataToFile( filename As String, data As Variant )
		On Error Goto eh
		
		Me.data = data
	'	ForAll entry In data
	'		Print  #f, "Data: " & ListTag( entry ) & ":=" & entry
	'	End ForAll
		
		'start the dom parser
		Print parseParam( "Merge: Update the XML file with data from Lotus Notes (%1)", filename )
		
		'open the file	
		Print "Open the file"	
		Dim inputStream As NotesStream
		Set inputStream = session.Createstream()
		Call inputStream.Open( filename )
		
		'parse
		Print "Parse the data"
		Dim dom As NotesDOMParser
		Set dom = session.Createdomparser()
		Call dom.Parse( inputStream )
		Call inputStream.Close()
		Set domdoc = dom.Document
		
		Call writeTree( dom.Document )
		
		'output	
		Print "Save the result"
		Dim outputStream As NotesStream
		Set outputStream = session.createStream()
		Call outputStream.open( filename )
		Call outputStream.Truncate()
		Call dom.Setoutput(outputStream)
		Call dom.Serialize()
		Call outputStream.Close()
		Print ""
		
done:
		Exit Function
eh: 
		Error Err, getErrorInfo( Me )
	End Function
	
	Sub writeTree ( node As NotesDOMNode )
		On Error Goto eh
		
		Dim child As NotesDOMNode
		Dim elt As NotesDOMNode
		
		If Not node.IsNull Then  
			Select Case node.NodeType
			Case DOMNODETYPE_DOCUMENT_NODE:        ' If it is a Document node
				Set child = node.FirstChild   ' Get the first node
				Dim numChildNodes As Integer
				numChildNodes = node.NumberOfChildNodes
				
				While numChildNodes > 0 
					Set child = child.NextSibling ' Get next node
					numChildNodes = numChildNodes - 1
					Call writeTree(child)
				Wend
				
			Case DOMNODETYPE_ELEMENT_NODE:        ' Most nodes are Elements
				Set elt = node
				
				Dim element As String
				element = Lcase( node.nodename )
		'		Print #f, "Element: " & Join( elements, "\" ) & "\" &  element
				
				Dim tag As String
				tag = Join( elements, "\" ) & "\" & element
				
				'process attributes
				Dim numAttributes As Integer
				Dim numChildren As Integer
				Dim attrs As NotesDOMNamedNodeMap
				Dim a As NotesDOMAttributeNode
				
				numAttributes = elt.attributes.numberofentries
				Set attrs = elt.Attributes     ' Get attributes
				
				Dim i As Integer
				For i = 1 To numAttributes     ' Loop through them
					Set a = attrs.GetItem(i)
					' Print attr. name & value
					If Iselement( data( tag & "@" & Lcase( a.nodename ))) Then
		'				Print #f, "Setting attribute: " & a.Nodename & "=" & data( tag & "@" & LCase( a.nodename ))
						a.nodevalue = data( tag & "@" & Lcase( a.nodename ))
					End If
				Next
				
				
				'set the elemnt value?
				If Iselement( data( tag )) Then
		'			Print #f, "Setting tag: " & tag & "=" & data( tag )
					
					If node.Haschildnodes Then
						node.Firstchild.nodeValue = data( tag )
					Else
						Dim Newchild As NotesDOMNode
						Set Newchild = domdoc.CreateTextNode( data( tag ))
						Call node.Appendchild(Newchild)
					End If
				End If
				
				'process subnodes
				numChildren =  elt.NumberOfChildNodes
				Set child = elt.FirstChild     ' Get child
				While numChildren > 0
					level = level+1
					Redim Preserve elements( level )
					elements( level ) = element
					
					Call writeTree(child)
					
					level = level-1
					Redim Preserve elements( level )
					
					Set child = child.NextSibling   ' Get next child
					numChildren = numChildren - 1
				Wend
			End Select  'node.NodeType
		End If        'Not node.IsNull
		
		
done:
		Exit Sub
eh: 
		Error Err, getErrorInfo( Me )
	End Sub
	
End Class


%REM
	Class AttachmateViewControls
	These controls are used from view actions to create/add documents or 
	manage selected documents in the view (e.g. print or mail)
%END REM
Class AttachmateViewControls As AbstractObject
	Private ws As NotesUIWorkspace
	Private view As NotesUIView
	Private parent As NotesDocument
	Private selected As NotesDocumentCollection
	Private db As NotesDatabase
	
	Private attachmate As Attachmate
	
%REM
		Sub new
		Description: Comments for Sub
%END REM
	Sub New
		On Error Goto eh
		Set ws = New NotesUIWorkspace
		Set view = ws.Currentview
		Set parent = ws.Currentdocument.Document
		Set db = session.Currentdatabase
		
		If Not view Is Nothing Then
			Set selected = view.Documents
			If selected.count = 0 Then
				Select Case view.Caretnoteid
				Case "", "0"
					Call selected.AddDocument( ws.currentDocument.document )
					
				Case Else
					Dim tmpDoc As NotesDocument
					Set tmpDoc = db.Getdocumentbyid(view.Caretnoteid)
					Call selected.Adddocument( tmpDoc )
					
				End Select
				
			End If
		End If
		
		Set attachmate = getAttachmate
		
done:
		Exit Sub	
eh:
		Error Err, getErrorInfo( Me )
	End Sub
	
%REM
		Function hasSelected
		Description: Comments for Function
%END REM
	Function hasSelected() As Boolean
		hasSelected = selected.count > 0 
	End Function
	
	
%REM
		Function noSelectedError
		Description: Comments for Function
%END REM
	Function noSelectedError()
		Msgbox getLanTxt( "NOSELECTION_PROMPT" ), 64, getLanTxt( "NOSELECTION" )
	End Function
	
%REM
		Function add
		Hoover: Add multiple files from the disk. Will be created as individual response documents
		This functions works great in an embedded view (attachmate6.responses)
%END REM
	Function add()
		On Error Goto eh
		Dim doc As NotesDocument
		
		'get the default path		
		Dim path As String
		path = session.GetEnvironmentString( "AttachmateLastFolder" )
		If path = "" Then 
			path = Environ( "HOMEPATH" )
		End If
		
		'select files
		Dim files As Variant
		files = ws.OpenFileDialog( True, "Select files", "All file types|*.*|PDF files|*.pdf|Word documents|*.doc;*.dot;*.docx;*.docm;*.dotm;*.dotx|Excel Sheets|*.xls;*.xlt;*.xlsx;*.xlsm|Sigma calculations|*.sig;*.sit", path )
		If Isempty( files ) Then Exit Function
		
		'save the selected path as a new default value
		path = Strleftback( files( 0 ), "\" )
		Call session.SetEnvironmentVar( "AttachmateLastFolder", path )
		
		
		'import as new reponses documents
		Dim cnt As Integer
		Forall filename In files
			cnt = cnt+1
			Print "Importing: (" & cnt & "/" & Ubound( files )+1 & ") " & filename
			
			Set doc = createResponse
			doc.subject = Strrightback( filename, "\" )
			doc.viewDescription =  "Imported file: " & doc.subject( 0 )
			
			Call attachmate.attachFile( doc, Cstr( filename ))
			
		End Forall
		
		Call ws.ViewRefresh
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function createResponse
		Description: Comments for Function
%END REM
	Private Function createResponse() As NotesDocument
		On Error Goto eh
		Dim doc As NotesDocument
		
		Set doc = db.createDocument
		doc.form = "attachmate.response"
		Call doc.makeResponse( parent )
		doc.attachmateResponse="1"
		doc.attachmateOptions = "AutoRead"
		
		Set createResponse = doc
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function create
		Creates a new response document, based on a template
%END REM
	Function create( template As Variant )
		On Error Goto eh
		Dim doc As NotesDocument
		Dim tmpDoc As NotesDocument
		
		
		Dim filename As String
		
		'create new doc
		Set doc = createResponse
		doc.subject = "Just created: " & Now
		
		'init
		Call attachmate.document.setDocument( doc )
		If Not attachmate.template.setTemplate(template) Then Exit Function 'select a template document
		Call doc.Replaceitemvalue(ATTACHMATE_ITEM, attachmate.template.getDocument().getItemValue( ATTACHMATE_ITEM ))
		Call doc.Replaceitemvalue(ATTACHMATE_TEMPLATE_ITEM, attachmate.template.getId() + ".<new>")
		
		'edit
		Call ws.Editdocument(True, doc )
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function edit
		Open the selected (only one) document for edit in the application
%END REM
	Function edit()
		On Error Goto eh
		Dim ws As New NotesUIWorkspace
		Dim doc As NotesDocument
		
		If Not hasSelected() Then
			Call noSelectedError()
			Exit Function
		End If
		
		
		Set doc = selected.GetFirstDocument()
		
		Call ws.Editdocument(True, doc )
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function detachSelected
		Description: Comments for Function
%END REM
	Function detachSelected()
		On Error Goto eh
		Dim doc As NotesDocument
		Dim nextDoc As NotesDocument
		
		If Not hasSelected() Then
			Call noSelectedError()
			Exit Function
		End If
		
		
		Dim cnt As Integer
		Dim cntSaved As Integer
		
		Dim path As String
		path = getDirDlg( )
		If path = "" Then Exit Function
		path = Replace( path, "\", "/" )
		If Right( path, 1 ) <> "/" Then path = path & "/"
		
		Dim filename As String
		
		Set doc = selected.GetFirstDocument()
		Do Until doc Is Nothing
			Set nextDoc = selected.GetNextDocument( doc )
			If doc.IsDeleted Then Goto NEXTDOC 
			If Not doc.IsValid Then Goto NEXTDOC 
			If doc.HasItem( "$conflict" ) Then Goto NEXTDOC 
			
			cnt = cnt+1
			Print cnt & "/" & selected.count, doc.subject( 0 )
			
			Call attachmate.document.setDocument( doc )
			
			filename = attachmate.document.storage.getFilename() 
			If Dir( path & filename ) <> "" Then 'file exist
				Dim renamedFilename As String
				renamedFilename = filename
				Dim idx As Integer
				Do While Dir( path & renamedFilename ) <> ""
					idx = idx+1
					If Instr( renamedFilename, "." ) > 0 Then
						renamedFilename = Strleftback( renamedFilename, "." ) & "_" & Right( "000" & idx, 3 ) & "." & Strrightback( renamedFilename, "." )
					Else
						renamedFilename = renamedFilename & "_" & Right( "000" & idx, 3 ) 
					End If
				Loop
				
				Dim opt( 3 ) As String
				opt( 0 ) = getLanTxt("FILEEXIST_OVERWRITE")
				opt( 1 ) = parseParam( getLanTxt("FILEEXIST_RENAME"), renamedFilename )
				opt( 2 ) = getLanTxt("FILEEXIST_SKIP")
				opt( 3 ) = getLanTxt("FILEEXIST_CANCEL")
				
				Dim choice As Variant
				Dim lastChoice As Integer
				
				choice = ws.prompt(PROMPT_OKCANCELLIST, getLanTxt( "FILEEXIST" ), parseParam( getLanTxt( "FILEEXIST_PROMPT" ), filename ), opt( lastChoice ), opt )
				If Isempty( choice ) Then Goto nextdoc
				
				Select Case choice
				Case opt( 0 ): 'overwrite
					Call attachmate.document.storage.detachTo( path, filename )
					lastChoice = 0
					
				Case opt( 1 ): 'rename
					Call attachmate.document.storage.detachTo( path, renamedFilename )
					lastChoice = 1
					
				Case opt( 2 ): 'skip
					lastChoice = 2
					Goto nextdoc
					
				Case opt( 3 ): 'cancel
					lastChoice = 3
					Goto done
					
				End Select
			Else
				Call attachmate.document.storage.detachTo( path, filename )
			End If
			
			cntSaved = cntSaved+1
			
			
NEXTDOC:
			Set doc = nextDoc
		Loop
		
done:
		Msgbox parseParam( getLanTxt( "DOCUMENTSSAVED" ), cntSaved ), 64, getLanTxt( "SUCCESS" )
		Exit Function
		
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
	Prints the selected documents
%END REM
	Function printSelected()
		On Error Goto eh
		Dim doc As NotesDocument
		Dim nextDoc As NotesDocument
		
		Dim cnt As Integer
		
		If Not hasSelected() Then
			Call noSelectedError()
			Exit Function
		End If
		
		Set doc = selected.GetFirstDocument()
		Do Until doc Is Nothing
			Set nextDoc = selected.GetNextDocument( doc )
			If doc.IsDeleted Then Goto NEXTDOC 
			If Not doc.IsValid Then Goto NEXTDOC 
			If doc.HasItem( "$conflict" ) Then Goto NEXTDOC 
			
			cnt = cnt+1
			Print cnt & "/" & selected.count, doc.subject( 0 )
			
			Call attachmate.document.setDocument( doc )
			Call attachmate.document.print() 
			
NEXTDOC:
			Set doc = nextDoc
		Loop
		
		Msgbox parseParam( getLanTxt( "DOCUMENTSPRINTED" ), cnt ), 64, getLanTxt( "SUCCESS" )
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function mail
		Description: Comments for Function
%END REM
	Function createMail( conversion As Integer )
		On Error Goto eh
		Dim filename As String
		Dim mailDb As New NotesDatabase( "", "" )
		Dim memo As NotesDocument
		Dim body As NotesRichTextItem
		
		If Not hasSelected() Then
			Call noSelectedError()
			Exit Function
		End If
		
		'create a new mail
		Call mailDb.openMail()
		If Not mailDb.isopen Then Error 9000, "Can't open the mail database"
		Set memo = mailDB.Createdocument()
		memo.form = "Memo"
		
		'attach the files
		Dim doc As NotesDocument
		Dim nextDoc As NotesDocument
		
		Dim cnt As Integer
		
		Set doc = selected.GetFirstDocument()
		Do Until doc Is Nothing
			Set nextDoc = selected.GetNextDocument( doc )
			If doc.IsDeleted Then Goto NEXTDOC 
			If Not doc.IsValid Then Goto NEXTDOC 
			If doc.HasItem( "$conflict" ) Then Goto NEXTDOC 
			
			cnt = cnt+1
			Print cnt & "/" & selected.count, doc.subject( 0 )
			
			Call attachmate.document.setDocument( doc )
			Call attachmate.document.copyAs( memo, "body", conversion )
			
NEXTDOC:
			Set doc = nextDoc
		Loop
		
		'open the mail
		Call ws.Editdocument(True, memo)
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function DeleteSelected
		Description: Comments for Function
%END REM
	Function deleteSelected()
		On Error Goto eh
		
		If Not hasSelected() Then
			Call noSelectedError()
			Exit Function
		End If
		
		
		If ws.Prompt( PROMPT_YESNO, getLanTxt( "DELETEDOCUMENTS" ), Replace( getLanTxt("DELETEDOCUMENTS_PROMPT"), "%1", Cstr( selected.Count )) ) = 1 Then
			Call selected.RemoveAll( True )
			Call view.DeselectAll()
			Call ws.ViewRefresh
		End If
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
End Class
%REM
	Class WordHandle
	Description: Comments for Class
%END REM
Class WordHandle As OtherHandle 'AbstractHandle
	Private w As Variant 'the active word document
	Private mergefile As String 'the margefile filename
	Private profile As NotesDocument 'database setup profile
	
%REM
		Sub New
		Description: Comments for Sub
%END REM
	Sub New(attachmate As Attachmate)
		
	End Sub
	
%REM
		Returns true of word should be invisible while merging 
		(gives a performance boots if there are many bookmarks - but can give stability problems when using mergefiles(
%END REM
	Function doHide() As Boolean
		doHide = False
		If profile Is Nothing Then
			If hasProfile( session.Currentdatabase, "Setup" ) Then Set profile = session.currentDatabase.getProfileDocument( "Setup" )
		End If
		
		If Not profile Is Nothing Then
			If profile.Hasitem("attachmateHideWord") Then
				doHide = ( profile.getItemValue( "attachmateHideWord" )( 0 ) = "1" )
			Else
				doHide = True	'the old default setting before the field was introduced on the profile
			End If
		End If
	End Function
	
	Function getType() As String
		getType = "Word"
	End Function
	
	Function hasObject() As Boolean
		hasObject = False
		If Isempty( obj ) Then Exit Function
		If obj Is Nothing Then Exit Function
		If w Is Nothing Then Exit Function
		
		On Error Goto ERRORHANDLER
		Dim s As String
		s = w.name 'check if object is valid / works
		'If obj.activeWindow Is Nothing Then Exit Function
		'If obj.activeDocument Is Nothing Then Exit Function
		
		hasObject = True
		
DONE:
		Exit Function
		
ERRORHANDLER:
		hasObject = False
		Resume DONE
	End Function
	
	
	Function isOpen() As Boolean
		On Error Goto eh
		If Dir( filename ) = "" Then isOpen = False : Exit Function 'no file
		
		If hasObject() Then isOpen = obj.Visible
		
done:
		Exit Function
eh:
		isOpen = False	
		Resume done
	End Function
	
	Function createFromFile( filename As String ) As Boolean
		If Not debug Then On Error Goto eh
		Call AbstractHandle..createFromFile( filename ) 'set the filename
		
		Dim d As String
		d = Dir( filename, 0 ) 'ATTR_NORMAL
		If d = "" Then Error 9000, "File not found: " & filename
		
		Dim s As String
		
		'create new word object
		Dim retry As Boolean
		retry = True 'retry on object initalization failure
		
retry:
		On Error Resume Next
		If obj Is Nothing Then 
			Set obj = GetObject("","Word.Application")
		End If
		
		If obj Is Nothing Then
			Set obj = CreateObject("Word.Application")
		End If
		
		Err = 0 '11.02.2011 majkilde: object might fail - please check and recreate if needed
		If doHide() Then obj.Visible = False 'added 5.03.2010 majkilde (needed) 
		If Err > 0 Then
			'something went wrong
			If retry Then
				If doHide() Then obj.Visible = True 'added 20.01.2012, majkilde
				Call obj.Quit
				Set obj = Nothing
				retry = False 'dont start an indefinte loop
				Goto retry
			End If
		End If	
		On Error Goto eh
		
		'load the document
		If doHide() Then obj.Visible = False 'added 5.03.2010 majkilde (needed)
		
		'check if the document is allready open
		On Error 207 Goto reopen
		If Not obj.documents Is Nothing Then
			Forall wordDoc In obj.documents
				If wordDoc.fullname = filename Then
					'check is doc is still open (workaround - this shouldn't be nessesary)
					On Error Resume Next
					s = worddoc.fullname
					On Error Goto eh
					
					If s <> "" Then 
						Set w = wordDoc
						Goto found
					Else
						'word is closed - please reopen
						If doHide() Then obj.Visible = True 'added 20.01.2012, majkilde
						Set obj = CreateObject("Word.Application")
						Exit Forall
					End If
				End If
			End Forall
		End If
		
		'open file
		Print "Åbner word: " & filename
		Call beforeLaunch()
		
		obj.DisplayAlerts = 0 'wdAlertsNone
		Call obj.documents.open( filename ) 'open as readonly: open( filename, False, true )
		obj.DisplayAlerts = -1 'wdAlertsAll
		
		Set w = obj.ActiveDocument
		Print ""
		
found:
		createFromFile = True
		Exit Function
		
reopen:
		On Error Resume Next
		Err = 0 		
		Call closeFile
		Set obj = CreateObject("Word.Application")
		
		If retry Then
			retry = False
			Resume retry
		Else
			Resume eh
		End If
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	Function save() As Boolean
		If Not debug Then On Error Goto eh
		If obj Is Nothing Then save = False : Exit Function
		
		Call AbstractHandle..save()
		Call w.save()
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function saveAs( filename As String ) As Boolean
		If Not debug Then On Error Goto eh
		Call AbstractHandle..saveAs( filename )
		If obj Is Nothing Then saveAs = False : Exit Function
		Call w.saveAs( filename )
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function writeBookmark
		Description: Comments for Function
%END REM
	Private Function writeBookmark( bookmarkName As String, value As Variant, options As String ) As Boolean
		On Error Goto eh
		If obj Is Nothing Then Exit Function 'word not initialized
		
		
		Dim Selection As Variant
		Set Selection = w.ActiveWindow.Selection
		If w.Bookmarks.Exists(bookmarkName) = True Then
			w.Bookmarks(bookmarkName).Select
			Dim i As Integer
			Dim currentRow As Long
			Dim currentColumn As Long
			
			If options="H" Then 'data used to create sections in the table (table headers)
				
				currentRow = Selection.Rows(1).Index
				currentColumn = Selection.Cells(1).ColumnIndex
				
				Dim lastValue As String
				Dim sectionCount As Integer
				sectionCount = 0
				
				For i = 0 To Ubound( value )
					
					Selection.Tables(1).Cell(currentRow + i + sectionCount, currentColumn).Select 'set the cursor
					
					If lastValue = value( i ) Then 'same section as last row - just clear the cell
						Call Selection.TypeText( " " )
					Else 'new section
						Call Selection.TypeText( " " ) 'clear the current cell
						Call Selection.InsertRowsAbove( 1 ) 'insert new row
						Call Selection.Cells.Merge 'merge the cell
						Call Selection.TypeText( value( i )) 'insert the header text
						
						Call Selection.HomeKey( 5,1 ) ' Unit:=wdLine, Extend:=wdExtend
						Selection.Font.Bold = &H8967E ' wdToggle
						
						'Selection.Style = w.ActiveDocument.Styles("TableSection") 'format the header						
						
						'save the value
						lastValue = value( i ) 
						sectionCount = sectionCount + 1
					End If
				Next
				
			Elseif options="@" And Ubound( value )>0 And Selection.Information(12) = True Then 'create rows for multivalue field within a table
				
				currentRow = Selection.Rows(1).Index
				currentColumn = Selection.Cells(1).ColumnIndex
				
				For i = 0 To Ubound( value )
					If Selection.Tables(1).Rows.Count < currentRow + i Then
						'out of rows -> please create
						Selection.Tables(1).Rows.Add
					End If
					
					Selection.Tables(1).Cell(currentRow + i, currentColumn).Select
					If value( i ) = "" Then
						Call Selection.TypeText( " " )
					Else
						Call Selection.TypeText( value( i ))
					End If
				Next
			Else
				value = Join( value, ", " )
				If value = "" Then value = " "
				Selection.TypeText value
				
			End If
		End If
		
done: 
		Exit Function
eh:
		Print Err, getErrorInfo( Me )
		Resume done		
	End Function
	
	
	
	
	Private Function WriteProp(sPropName As String, sValue As String ) As Boolean
		WriteProp = False
		If obj Is Nothing Then Exit Function 'word not initialized
		
		'found at http://word.mvps.org/FAQs/MacrosVBA/MixedDocProps.htm
		'In the above declaration, "Optional lType As Long = msoPropertyTypeString" means
		'that if the Document Property's Type is Text, we don't need to include the lType argument
		'when we call the procedure; but if it's any other Prpperty Type (e.g. date) then we do
		
		Dim bCustom As Boolean
		
		On Error Goto ErrHandlerWriteProp
		
		'Try to write the value sValue to the custom documentproperties
		'If the customdocumentproperty does not exists, an error will occur
		'and the code in the errorhandler will run
		w.BuiltInDocumentProperties(sPropName).Value = sValue
		'Quit this routine
		Exit Function
		
Proceed:
		'We know now that the property is not a builtin documentproperty,
		'but a custom documentproperty, so bCustom = True
		bCustom = True
		
Custom:
		'Try to set the value for the customproperty sPropName to sValue
		'An error will occur if the documentproperty doesn't exist yet
		'and the code in the errorhandler will take over
		obj.activeDocument.CustomDocumentProperties(sPropName).Value = sValue
		WriteProp = True
		Exit Function
		
AddProp:
		'We came here from the errorhandler, so know we know that
		'property sPropName is not a built-in property and that there's
		'no custom property with this name
		'Add it 
		On Error Resume Next
		obj.activeDocument.CustomDocumentProperties.Add sPropName, False, 4, sValue
		
		If Err Then
			'If we still get an error, the value isn't valid for the Property Type
			'e,g an invalid date was used
			Print "Error writing property: " & sPropName & "=" & sValue & " (" & getErrorInfo( Me ) & ")"
		Else
			WriteProp = True
		End If
		
		Exit Function
		
ErrHandlerWriteProp:
		'bCustom is a boolean variable, if the code jumps to this
		'errorhandler for the first time, the value for bCustom is False
		If Not bCustom Then
			'Continue with the code after the label Proceed
			Resume Proceed
		Else
			'The errorhandler was executed before because the value for
			'the variable bCustom is True, therefor we know that the
			'customdocumentproperty did not exist yet, jump to AddProp,
			'where the property will be made
			Resume AddProp
		End If
		
	End Function
	
	
%REM
		Function updateProperties
		Description: Comments for Function
%END REM
	Private Function updateProperties( sourceDoc As NotesDocument, template As AttachmateTemplate )
		On Error Goto eh
		Dim Field As String
		Dim formula As String
		Dim values As Variant
		Dim value As String
		Dim options As String
		
		'debug stuff
		If debug Then
			Execute(|
use "cls.utils"
set timerObject = new Stopwatch()
|)
			Call timerObject.start( "properties" )
		End If
		
		'do bookmarks
		If Not attachmate.document.isTemplate Then
			Forall entry In template.getField( "wordBookmarks" )
				If entry = "" Then Goto nextBookmark
				
				Field = Fulltrim( Strleft( entry, ":=" ))
				If Instr( Field, ";" ) > 0 Then
					options = Fulltrim( Strright( Field, ";" ))
					Field = Fulltrim( Strleft( Field, ";" ))
				Else
					options = ""
				End If
				
				formula = Fulltrim( Strright( entry, ":=" ))
				
				If Field = "" Then Goto nextBookmark
				If formula = "" Then Goto nextBookmark
				
				values = Evaluate( formula, sourceDoc )	
				
				'update word bookmark
				
				'sometimes we get a Type Mismatch with the values param in the Writebookmark call - this is a workaround:
				'<workaround> 
				Dim idx As Integer
				If Isarray( values ) Then
					Dim v As Variant
					Redim v(Ubound( values ))
					For idx = 0 To Ubound( values )
						v( idx ) = Cstr( values( idx ))
					Next
					values = v
				Else
					values = Split( Cstr( values ), "#¤%" )
				End If
				'</workaround>
				
				Call writeBookmark( Field, values, options )
				
nextBookmark:
			End Forall
		End If
		
		'do properties
		Forall entry In template.getField( "wordProperties" )
			If entry = "" Then Goto nextentry
			
			field = Fulltrim( Strleft( entry, ":=" ))
			If Instr( Field, ";" ) > 0 Then
				options = Fulltrim( Strright( Field, ";" ))
				Field = Fulltrim( Strleft( Field, ";" ))
			Else
				options = ""
			End If
			
			formula = Fulltrim( Strright( entry, ":=" ))
			
			If Field = "" Then Goto nextentry
			If formula = "" Then Goto nextentry
			
			values = Evaluate( formula, sourceDoc )	
			If Isarray( values ) Then	
				value = Join( values, ", " )
			Else
				value = values
				Redim values( 0 )
				values( 0 ) = value
			End If
			
			If value="" Then
				If attachmate.document.isTemplate Then
					value = "<<" & Field & ">>"
				End If
			End If
			
			'update word property
			Call WriteProp( Field, Cstr( value ))
			
			
		'<Handle the @ option>
			If options = "@" And Not obj Is Nothing And Ubound( values ) > 0 Then
				Dim wordDoc As Variant
				Set wordDoc = obj
				Dim i As Long
				
				'find and select the DocProperty Field
				Dim wordField As Variant
				For i = 1 To wordDoc.activeDocument.fields.count
					
					Set wordField = wordDoc.activeDocument.fields( i )
					If wordField.type = 85 Then 'wdFieldDocProperty=85
						If Instr( 1, Cstr( wordField.code.text ), " " & Field & " ", 5 ) > 0 Then
							'field found
							wordField.Select
							Goto updateTable
						End If
						On Error Goto eh
					End If
				Next
				
				'field not found
				Print "Didn't find the DocProperty field: " & field
				Goto nextentry
				
				
				'Multivalues spans multiple rows
updateTable:
				If wordDoc.Selection.Information(12) = True Then 'wdWithInTable=12
					
					Dim currentRow As Long
					Dim currentColumn As Long
					
					currentRow = wordDoc.Selection.Rows(1).Index
					currentColumn = wordDoc.Selection.Cells(1).ColumnIndex
					
					For i = 0 To Ubound( values )
						If wordDoc.Selection.Tables(1).Rows.Count < currentRow + i Then
							'out of rows -> please create
							wordDoc.Selection.Tables(1).Rows.Add
						End If
						
						wordDoc.Selection.Tables(1).Cell(currentRow + i, currentColumn).Select
						Call wordDoc.Selection.TypeText( values( i ))
						
					Next
				Else
					'MsgBox ("You are not in a table")
				End If
			End If
			'</Handle the @ option>		
			
nextentry:	
		End Forall
		
		
		obj.activeDocument.Fields.Update 'KLINT 16.11.2008 (31.01.2011 moved out of the loop for better performance)
		
		If debug Then 
			Print "Data merged in " & timerObject.readms( "properties" )
		End If
		
		
		'update headers
		w.PrintPreview
		w.ClosePrintPreview
		
		Exit Function	
eh:
		Print "Error: " & getErrorInfo( Me )
		Resume Next 'don't fail on this...
	End Function
	
%REM
		Function activateWordFilemerge
		Description: Comments for Function
%END REM
	Private Function activateWordFilemerge( mergeFilename As String )
		
		If Not debug Then On Error Goto eh
		
		If mergeFilename = "" Then Exit Function
		
		'activate mail merge and set the filename to the mergefile
		Call w.MailMerge.OpenDataSource( mergeFilename, 5, False, True, False ) '4=wdOpenFormatText, wdOpenFormatUnicodeText=5
		'w.MailMerge.ViewMailMergeFieldCodes = 0 'enable //moved to the show method
		
		'save word and mark as 'unchanged'
		'removed 5.11.2010 by majkilde
		'Call save()
		'Me.filedate = FileDateTime( filename )
		
		
		Exit Function
eh:
		Print Err, Error
		Resume Next
	End Function
	
	
%REM
		Function createMergeFile
%END REM
	Private Function createMergeFile( ) As String
		Dim mergeFilename As String
		Dim f As Integer
		If Not debug Then On Error Goto eh
		
		If attachmate.document.isTemplate() And Not attachmate.template.hasTemplate() Then 
			Call attachmate.template.setTemplate( attachmate.document.getDocument()) 'we need a template
		End If
		mergeFilename = attachmate.getMergeFilename()
		
		'handle existing files
		On Error Resume Next
		If Dir( mergeFilename ) <> "" Then Kill mergeFilename 'delete old files
		If Dir( mergeFilename ) <> "" Then createMergeFile = mergeFilename : Exit Function 'reuse existing open file
		If Not debug Then On Error Goto eh
		
		'<include properties>
		Dim propertyHeader As String
		Dim propertyData As String
		If attachmate.template.getFieldString( "wordMergeIncludeProperties" ) = "1" Then ' And Not attachmate.mergeData.getDocument() Is Nothing Then
			Dim propertyField As String
			Dim propertyFormula As String
			Dim propertyValue As Variant
			
			Forall entry In attachmate.template.getField( "wordProperties" )
				If entry = "" Then Goto nextentry
				
				propertyField = Fulltrim( Strleft( entry, ":=" ))
				propertyFormula = Fulltrim( Strright( entry, ":=" ))
				
				If propertyField = "" Then Goto nextentry
				If propertyFormula = "" Then Goto nextentry
				
				propertyValue = Evaluate( propertyFormula, attachmate.mergeData.getDocument())	
				propertyValue = attachmate.cMergeText( Join( propertyValue, ", " ))
				
				If propertyValue="" Then
					If attachmate.document.isTemplate Then
						propertyValue = "<" & propertyField & ">"
					End If
				End If
				
				propertyHeader = propertyHeader & ";" & propertyField
				propertyData = propertyData & ";" & propertyValue
				
nextentry:
			End Forall
			If propertyHEader = ";" Then propertyHeader = ""
			If propertyData = ";" Then propertyData = ""  
		End If
		'</include properties>
		
		Dim Field As String
		
		'calc the header
		Dim data As String
		Dim formulas List As String
		Dim header As String
		Forall entry In attachmate.template.getField("wordCollection")
			Field = attachmate.cMergeText( Strleft( entry, ":=" ))
			If Field <> "" Then
				If header = "" Then
					header = Field
					data = "<" & Field & ">"
				Else
					header = header & ";" & Field
					data = data & ";<" & Field & ">"
				End If
				formulas( Field ) = Strright( entry, ":=" )
			End If
		End Forall
		
		'create the file
		f = Freefile
		Open mergeFilename For Output As f
		Print #f, header & propertyHeader
		
		
		'loop on collection (if any)
		If Not attachmate.mergeData.hasCollection() Then
			Print #f, data & propertyData
		Else
			Dim v As Variant
			Dim tmpDoc As NotesDocument
			Dim tmpColl As Variant
			Set tmpColl = attachmate.mergedata.getCollection()
			Set tmpDoc = tmpColl.GetFirstDocument()
			Do Until tmpDoc Is Nothing
				data = ""
				Forall formula In formulas
					If formula <> "" Then
						v = Evaluate( formula, tmpDoc )
						v = Join( v, ", ")
						v = attachmate.cMergeText( Cstr( v ))
					Else
						v = ""
					End If
					data = data & v & ";"
				End Forall
				Print #f, Left( data, Len( data )-1 ) & propertyData
				
				Set tmpDoc = tmpColl.getNextDocument( tmpDoc )
			Loop 
		End If
		
		Close #f
		
		If header <> "" Then
			createMergeFile = mergeFilename
			If debug Then Print "Mergefile created: " & mergefilename 		
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function merge
		Description: Comments for Function
%END REM
	Function merge() As Boolean
		
		If Not hasObject() Then
			Call createFromFile( filename )
		End If
		
		If editmode Or isNew Then 'don't update a document in read mode
			If Not attachmate.template.hasTemplate Then Exit Function 'need a template 
			
			If attachmate.mergedata.hasDocument() Then
				'update document properties 
				Call updateProperties( attachmate.mergedata.getDocument(), attachmate.template )
			End If
		End If
		
		merge = True
	End Function
	
%REM
		Function beforeLaunch
		Used to prepare a merge file
%END REM
	Function beforeLaunch()
		On Error Goto eh
		
		'<mergefile>
		If attachmate.document.isTemplate() Then
			If attachmate.document.getDocument().wordUseMergeFile( 0 ) = "1" Then
				'launching a template that needs a merge file -> create sample file
				mergefile = createMergeFile()
			End If
		Elseif attachmate.template.hasTemplate() Then
			If attachmate.template.getFieldString( "wordUseMergeFile" ) = "1" Then 'check template flag
				'use a merge file -> create or detach
				'when should we recreate? this must be controlled by the user
				
				'always load the collection, thus enabling the user to edit the unid list 
				Call attachmate.mergedata.loadMergeCollection(attachmate.document.getDocument.attachmateMergeUnids)
				
				If attachmate.mergedata.hasCollection() Then
					'If editmode Or noMergeFile then
					mergefile = createMergeFile()
					'End if
				Else
					mergefile = attachmate.getMergefilename()
				End If
			End If
		Else
			mergefile = attachmate.getMergefilename()
			If Dir(mergefile, 0 ) = "" Then
				mergefile = "" 'there is no mergefile
			End If  
		End If
		'</mergefile>
		
done:
		Exit Function
eh: 
		Error Err, getErrorInfo( Me )
	End Function
	
	Function launch( ) As Boolean
		If Not debug Then On Error Goto eh
		Call AbstractHandle..launch() 
		
		'launch the letter
		If Not hasObject() Then
			Call createFromFile( filename )
		End If
		
		If hasObject() Then
			'execute the merge
			If mergefile <> "" Then
				Call activateWordFilemerge( mergefile )
			End If
			If editmode Or isNew Then Call merge()
			
			Call executeScript( "queryopen" )
			Call executeMacro( "queryopen" )
			
			launch = show()
			
			If isNew Then
				Call executeScript( "oncreate" )
				Call executeMacro( "oncreate" )
				'isNew = False 'removed 3.01.2011 by majkilde
			End If
			
			Call executeScript( "postopen" )
			Call executeMacro( "postopen" )
			
		Else
			launch = False
		End If
		
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function setFocus
		Description: Comments for Function
%END REM
	Function setFocus()
		On Error Goto eh
		
		obj.Visible = True
		Activateapp Strleftback( w.Name, "." )
		Activateapp w.name
		
done:
		Exit Function
eh:
		Print Err, geterrorInfo( Me )
		Resume Next
	End Function
	
%REM
		Makes word visble and focused
%END REM
	Function show() As Boolean
		If Not debug Then On Error Goto eh
		If hasObject() Then
			If doHide() Then obj.Visible = True
			
			'View the mergefield values (and not the fields) - but only if word MailMerge is enabled
			If Not w.MailMerge.DataSource Is Nothing Then
				If w.MailMerge.DataSource.name <> "" Then
					w.MailMerge.ViewMailMergeFieldCodes = 0 'enable
					Call save()
					If Not isnew Then 'this line added 5.11.2010 by majkilde
						Me.filedate = Filedatetime( filename )
					End If
				End If
			End If
			
			Call setFocus() 'give focus to word
			
			show = True
		Else
			show = False
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function runMacro( macro As String )
		If Not debug Then On Error Goto eh
		If macro <> "" Then
			Call obj.run( macro )
		End If
		
		Exit Function
eh:
		Print Err, getErrorInfo( Me )
		Resume Next
	End Function
	
	Function Print() As Boolean
		If Not debug Then On Error Goto eh
		Dim PrintBackground As Variant
		
		If Not hasObject Then Me.Print = False : Exit Function
		' Turn off background printing to avoid error message cf. Microsoft Technote #Q170393
		PrintBackground = obj.Options.PrintBackground()
		If PrintBackground = True Then obj.Options.PrintBackground = False 
		If attachmate.hasMergefile Then
			Call activateWordFilemerge( attachmate.getMergefilename )
			With w.mailmerge
				.Destination = 1 'wdSendToPrinter
				.SuppressBlankLines = True
				.DataSOurce.FirstRecord = 1 'wdDefaultFirstRecord
				.DataSource.LastRecord = -16 'wdDefaultLastRecord
				Call w.mailMerge.Execute( False )
			End With
		Else
			Call w.PrintOut()
		End If
		obj.Options.PrintBackground = PrintBackground 'Restore PrintBackground option
		Me.print = True
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function closefile()
		On Error Resume Next
		'close the open document
		If Not w Is Nothing Then
			If mergefile <> "" Then 
				Call w.Close( -1 ) 'wdSaveChnages=-1 // need this sometimes, until we have a 'forceSave as boolean' param
			Else
				Call w.close() 'prompt for save if file is changes
			End If
		End If
		
		Set w = Nothing
		
		'don't close word  - we want to reuse later
		'just minimize
		If doHide() Then obj.visible = True
		obj.WindowState = 2 'wdWindowStateMinimize
		
		
		'If Not obj Is Nothing Then obj.Quit
		'Set obj = Nothing
		
		Call AbstractHandle..closefile() 'delete the files
	End Function
	
%REM
		Function ExecuteFeature
		Description: Comments for Function
%END REM
	Function ExecuteFeature( id As String, params As Variant ) As Variant
		Select Case Lcase( id )
		Case "mailmerge"
			Call mailmergePDFFiles( params )
		End Select
		
	End Function
	
%REM
		Function mailmergePDFFiles
		special feature. 
		Requirements
		- Template must be using a word mergefile
		- The word custom property 'Email' must be set
		- The AttachmateMemoTemplates field must have a reference to a valid Memo Template document
		Result
		- Function will generate a pdf file for each record in the mergefile
		- The pdf will be mailed to the 'email' property
		- After mailing, a report will be sent to the current user
		
		Params( 0 ): report template. optional. String:memo template id, unid, notesdocument or MemoTemplateObject
		params( 1 ): mail template. optional. Default is defined in AttachmateMemoTemplates field. String:memo template id, unid, notesdocument or MemoTemplateObject
%END REM
	Private Function mailmergePDFFiles( params As Variant )
		On Error Goto eh
		
		Call beforeLaunch()
		
		Dim worddoc As Variant
		
		'init
		If Not hasObject() Then
			Call createFromFile( filename )
		End If
		
		'Do we have a mergefile?
		If Not attachmate.hasMergefile() Then
			Msgbox "Word template must be using a merge file", 64, "Error"
			Exit Function
		End If
		
		'create the report mail
		Dim report As AbstractMemo
		If Isarray( params ) Then
			Set report = getMemo( "*", params( 0 ))
			If Not report Is Nothing Then
				Call report.create( attachmate.document.getDocument, Nothing )
			End If
%REM
		ElseIf TypeName( params ) = "STRING" And params<>"" Then
			Set report = getMemo( "*", params( 0 ))
			Call report.create( attachmate.document.getDocument, Nothing )
		else
			Dim mt As New MemoTemplate()
			Call mt.create( "", "" )
			Call mt.setRecipients(session.username, null, null)
			Call mt.setSender( session.currentDatabase.title, null )
			
			Set report = getMemo( "*", mt )
			Call report.create( attachmate.document.getDocument(), nothing)
			call report.setSubject(parseParam( "PDF mail report from '%1'", session.currentDatabase.title ))
			Call report.insert( "Source document: " )
			Call report.insert( attachmate.document.getDocument() )
			Call report.insert( "\n\n" )
%ENDREM
		End If
		
		'Get the memo template
		Dim m As AbstractMemo
		If Isarray( params ) Then
			If Ubound( params ) >=1   Then
				Set m = getMemo( "*", params( 1 ))
			End If
		End If
		If m Is Nothing Then 'use default
			Set m = getMemo( "*", attachmate.document.getDocument().AttachmateMemoTemplates( 0 ))
		End If
		
%REM
			Dim mt As New MemoTemplate()
			Dim templates As Variant
			templates = attachmate.document.getDocument().AttachmateMemoTemplates
			Dim template As NotesDocument
			Set template = mt.getTemplate( session.Currentdatabase, templates )
			If template Is Nothing Then
				MsgBox parseParam("Can't find a valid memo template to merge with (%1)", templates), 64, "Error"
				exit function	
			End If
%ENDREM
		
		'loop on all records in the mergefile
		Call activateWordFilemerge( attachmate.getMergeFilename())
		If doHide() Then obj.Visible = False
		
		Const wdFirstRecord= -4
		Const wdNextRecord= -2
		Dim email As String
		Dim record As Long
		
		Dim tmpDoc As NotesDocument
		Set tmpDoc = session.currentDatabase.createDocument()
		
		Dim pdfFile As String
		
		Dim i As Integer
		With w.MailMerge
			.DataSource.ActiveRecord = wdFirstRecord
			
			Do
				record = .DataSource.ActiveRecord	
				
				'read the data
				For i = 1 To .DataSource.DataFields.Count
					Call tmpDoc.replaceItemValue( .DataSource.DataFields(i).Name, .DataSource.DataFields(i).Value )
				Next
				
				'create a mail
				Call m.create( tmpDoc, Nothing )
				
				'merge the current record 
				.Destination = 0 'wdSendToNewDocument
				.SuppressBlankLines = True
				.DataSource.FirstRecord = record
				.DataSource.LastRecord = record
				Call w.mailMerge.Execute( False )
				Set worddoc = obj.ActiveDocument
				
				'save as pdf
				Const wdExportFormatPDF = 17
				Const wdExportOptimizeForPrint = 0
				Const wdExportAllDocument = 0
				Const wdExportDocumentContent = 0
				pdfFile = Strleftback( filename, "." ) & ".pdf"
				Call worddoc.ExportAsFixedFormat( pdfFile, wdExportFormatPDF, False, wdExportOptimizeForPrint, wdExportAllDocument )
				Call worddoc.close(0) 'wdDoNoSaveChanges=0
				
				'attach a the file
				Call m.attach( pdfFile )
				
				'send the mail and update the report mail
				If m.send() Then
					If Not report Is Nothing Then
						Call report.insert( parseParams( "Send to: %1 (%2) \n", m.getDocument().sendto, m.getDocument.subject, "", "" ))
					End If
				Else
					If Not report Is Nothing Then
						Call report.insert( parseParams( "Error - no recipient: '%2'","", m.getDocument.subject, "", "" ))
						Call report.attach( pdfFile )
						Call report.insert( "\n" )
					End If
				End If
				
				.DataSource.ActiveRecord = wdNextRecord
				
			Loop Until .DataSource.ActiveRecord = record
			
		End With
		
		If Not report Is Nothing Then
			Call report.send()
		End If
		
done:
		If Not w Is Nothing Then w.Close( 0 ) 'close, but dont save (wdDoNoSaveChanges=0)
		Call closefile()
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function convertFile
		Description: Comments for Function
%END REM
	Function convertFile( conversion As Integer ) As String
		On Error Goto eh
		Dim worddoc As Variant
		Dim newFile As Boolean
		Dim newFilename As String
		
		If Not hasObject() Then
			Call createFromFile( filename )
		End If
		
		If attachmate.hasMergefile() Then
			Call activateWordFilemerge( attachmate.getMergeFilename())
			With w.mailmerge
				.Destination = 0 'wdSendToNewDocument
				.SuppressBlankLines = True
				.DataSource.FirstRecord = 1 'wdDefaultFirstRecord
				.DataSource.LastRecord = -16 'wdDefaultLastRecord
				Call w.mailMerge.Execute( False )
			End With
			Set worddoc = obj.ActiveDocument
			newFile = True
		Else
			Set wordDoc = w
			newFile = False
		End If
		
		Select Case conversion
		Case ATTACHMATE_CONVERT_MERGE:
			If Not newFile Then
				convertFile = filename 'nothing happend
			Else
				newFilename = Strleftback( filename, "." ) & " merged." & Strrightback( filename, "." ) 
				Call wordDoc.saveAs( newFilename )
				convertFile = newFilename
			End If
		Case ATTACHMATE_CONVERT_PDF:
			Const wdExportFormatPDF = 17
			Const wdExportOptimizeForPrint = 0
			Const wdExportAllDocument = 0
			Const wdExportDocumentContent = 0
			newFilename = Strleftback( filename, "." ) & ".pdf"
			Call worddoc.ExportAsFixedFormat( newFilename, wdExportFormatPDF, False, wdExportOptimizeForPrint, wdExportAllDocument )
			
			convertFile = newFilename
			
		End Select
		
		If newFile Then
			Call worddoc.close(0)
			Set worddoc = Nothing
		End If
done:
		Exit Function
eh:
		Print Err, getErrorInfo( Me )
		convertFile = ""
		Resume done
	End Function
	
	
	
End Class

%REM
	Class AttachmateSource
	Data to merge with. 
	Optional: create a merge file
	
	The attachmate object
	Required: AttachmateTemplate (a valid template document with merge info, field mappings etc.)
	Optional: AttachmateDocument (containing the last used merge file)
%END REM
Public Class AttachmateMergedata As AbstractObject
	Private attachmate As Attachmate
	Private db As NotesDatabase
	'Private sourceDb As NotesDatabase 'for the sourceColl
	'Private sourceColl As Variant 'NotesView or NotesDocumentCollection
	
	Private sourceCollections As SourceCollections
	
	Private sourceDoc As NotesDocument 'source db is always current db for this
	
	Private docCache List As notesDocument
	
	
	Sub New(attachmate As Attachmate)
		Set Me.attachmate = attachmate
		Set db = session.Currentdatabase
		'Set sourceDb = session.Currentdatabase
		Set sourceCollections = New SourceCollections( attachmate )
	End Sub
	
%REM
		Function clear
		Description: Comments for Function
%END REM
	Function clear()
		On Error Goto eh
		Call sourceCollections.clear()
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function getFirst
		Description: Comments for Function
%END REM
	Function getFirst() As NotesDocument
		On Error Goto eh
		Set getFirst = sourceCollections.getFirst()
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function getNext
		Description: Comments for Function
%END REM
	Function getNext() As NotesDocument
		On Error Goto eh
		Set getNext = sourceCollections.getNext()
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
%REM
%END REM
	Public Function loadMergeDocument( source As NotesDocument )
		On Error Goto eh
		If source.AttachmateMergeUnid( 0 ) <> "" Then
			Dim sourceDb As NotesDatabase
			Dim s As String
			s = source.AttachmateMergeUnid( 0 )
			If Left( s, 1 ) = "<" Then s = Mid( s, 2, Len( s )-2 )
			If Instr( s, "=" ) = 0 Then s = "unid=" & s 
			Call attachmate.resolve( s, sourceDb, sourceDoc )
		End If
		
		If sourceDoc Is Nothing Then 
			Set sourceDoc = source
		End If
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function addMergeQuery
		Description: Comments for Function
%END REM
	Function addMergeQuery( database As Variant, query As String )
		On Error Resume Next
		Call sourceCollections.addQuery(Database, Query)
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function getDocument
		Description: Comments for Function
%END REM
	Function getDocument() As NotesDocument
		Set getDocument = sourceDoc
	End Function
	
%REM
		Function hasDocument
		Description: Comments for Function
%END REM
	Function hasDocument() As Boolean
		hasDocument = Not (sourceDoc Is Nothing)
	End Function
	
%REM
		Function hasCollection
		Description: Comments for Function
%END REM
	Function hasCollection() As Boolean
		On Error Goto eh
		hasCollection = sourceCollections.hasData()
		
'		Select Case TypeName( sourcecoll )
'			Case "NOTESVIEW"
'				hasCollection = True
'			case "NOTESDOCUMENTCOLLECTION"
'				hasCollection = (sourceColl.count > 0)
'			Case Else
'				hasCollection = false
'		End Select
'		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
%REM
		Function getCollection
		Description: Comments for Function
%END REM
	Function getCollection() As Variant
		Set getCollection = sourceCollections.getCollection( 0 )
'		Set getCollection = sourceColl
	End Function
	
%REM
		Function setSourceDb
		Description: Comments for Function
%END REM
	Function setSourceDb( sourceDb As NotesDatabase )
		'Set me.sourceDb = sourceDb
		Print "setSourceDb: Why this ?"
		Error 9000, "This method is obsolete"
	End Function
	
%REM
		Function loadMergeCollection
		Description: NotesDocumentCollection, NotesView or NotesDocument
%END REM
	Function loadMergeCollection( source As Variant )
		On Error Goto eh
		Call sourceCollections.clear()
		
		If Isarray( source ) Then
			Call sourceCollections.addUnids( source )
%REM
			'list of document unids
			If source( 0 ) = "" Then Exit Function 'no data
			Dim tmpDoc As NotesDocument
			
			Dim columns As Variant
			Dim unidColumn As Integer 'default = 0 (only one column with the unid)
			columns = Split( "unid", "#" )
			
			If Left(source( 0 ),1)="<" Or InStr( source( 0 ), "=" ) > 0 Then
				If attachmate.resolve(source(0), sourceDb, Nothing ) Then
					'everything is fine
					'<extra columns> (E&P)
					Dim i As Integer
					If IsElement( attachmate.params( "columns" )) Then
						columns = Split( attachmate.params( "columns" ), "#")
						For i = 0 To UBound( columns )
							If LCase( columns( i )) = "unid" Then unidColumn = i : Exit for
						Next			
					End If
					'</extra columns>
				Else
					Error Err, "Can't find the source database: " & source( 0 )
				End If
			End If
			
			Set sourceColl = sourceDb.Getprofiledoccollection("Give me an empty collection")
			On Error Resume Next 'don't fail on invalid unids
			Dim data As Variant
			Dim unid As String
			ForAll entry In source
				data = Split( entry, "#" )
				unid = data( unidColumn )				
				If unid = "" Then GoTo nextunid
				If Left( unid, 1 ) = "<" Then GoTo nextunid
				If Len( unid ) <> 32 Then GoTo nextunid
				
				On Error Resume Next
				If attachmate.document.getDocument().Universalid = unid Then
					Set tmpDoc = attachmate.document.getDocument() 'this is the current document (can't be found by the .getDocumentByUnid if it is a new note)
					If tmpDoc.Isnewnote Then 
						If tmpDoc.Isuidocopen Then
							Dim ws As New NotesUIWorkspace
							Call ws.currentDocument.save()
						Else
							Call tmpDoc.save( True, False ) 'must be saved in order to merge data
						End If
						
						Print "Saving the document (can't merge with unsaved documents)"
						Print ""
					End if
				else
					Set tmpDoc = sourceDb.Getdocumentbyunid(unid)
				End if
				On Error GoTo eh
				If tmpDoc Is nothing Then
					Print "Error: Source document unid not found: " & unid
				Else
					'<add extra columns>
					If UBound( columns ) > 0 Then 'there is extra columns
						For i = 0 To UBound( columns )
							If i <> unidColumn then
								Call tmpDoc.Replaceitemvalue( columns( i ), data( i ))
							End If
						Next
						
						Set docCache( tmpDoc.noteid ) = tmpDoc 'store the document - otherwise the extra columns is lost 
					End if
					'</add extra columns>
					If Not sourceColl.contains( tmpDoc ) then
						Call sourceColl.addDocument( tmpDoc )
					End if
				End If
nextunid:
			End ForAll
%ENDREM
		Else 'view or collection
			Select Case Typename( source )
			Case "NOTESDOCUMENT"
				Call sourceCollections.addDocument(source)
				
'				Set sourceDb = source.parentDatabase
'				Set sourceColl = sourceDb.Getprofiledoccollection("Give me an empty collection")
'				Call sourceColl.addDocument( source )
				
			Case "NOTESVIEW"
				Call sourceCollections.addView(source)
				
			Case "NOTESDOCUMENTCOLLECTION"
				Call sourceCollections.addCollection(source)
				
			Case "NOTESDOCUMENTCOLLECTION"
				Call sourceCollections.addView(source)
				
'				Set sourceDb = source.parent
'				Set sourceColl = source
			End Select
			
		End If
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
End Class
'++LotusScript Development Environment:2:2:Initialize:1:10
Sub Initialize
	Call loadLanguagePack()
End Sub






'++LotusScript Development Environment:2:1:getAttachmate:1:8
Static Function getAttachmate As Attachmate
	If globalAttachmate Is Nothing Then
		Set globalAttachmate = New Attachmate()
		Call globalAttachmate.init()
	End If
	
	Set getAttachmate = globalAttachmate
End Function



'++LotusScript Development Environment:2:1:attachmate_doAttach:5:8




Function attachmate_doAttach( attachmate As Attachmate )
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	
	Set doc = ws.currentDocument.Document
	
	
	Dim disabledFeatures As Variant
	disabledFeatures = doc.AttachmateDisabledFeatures
	
	If Not Isnull( Arraygetindex( disabledFeatures, "CREATEFROMFILE", 5 )) Then
		Exit Function 'create is disabled
	End If
	
	Dim filename As String
	filename = attachmate.selectOSFile( True, "save" )
	
	If filename <> "" Then
		Call attachmate.attachFile( doc, filename )
		
		Call ws.CurrentDocument.Close()
		Call ws.ViewRefresh()
	End If
End Function

'++LotusScript Development Environment:2:1:attachmate_doCheckOut:2:8

Function attachmate_doCheckOut( attachmate As Attachmate )
	Dim ws As New NotesUIWorkspace
	Dim session As New NotesSession
	Dim filename As String
	If attachmate.document.hasHandle() Then
		
		Msgbox getLanTxt( "ERRCHECKOUT" ), 64, getLanTxt( "ERROR" )
		Exit Function
	End If
	
	Dim path As New Path( "MY" )
	Call path.add( "Attachmate" )
	Call path.create()
	
	attachmate.document.logDisabled = True
	
	Dim doc As NotesDocument
	Set doc = ws.CurrentDocument.Document
	
	filename = attachmate.document.storage.detachto( path.getPath(), "#" )
	
	attachmate.document.logDisabled = False	
	Call attachmate.document.logAttachmateAction( "Check-out" )
	
	ws.CurrentDocument.Document.attachmate_1_checkinout = "date=" & Now & ";username=" & session.username & ";filename=" & filename & ";"
	
	Call ws.CurrentDocument.Refresh()	
	Call ws.CurrentDocument.Save()
	
	Print parseParams( getLanTxt( "CHECKOUTMSG" ), filename, getLanTxt( "OPENCHECKOUT" ), "", "" )
End Function

'++LotusScript Development Environment:2:1:attachmate_doRemoveCheckOut:3:8


Function attachmate_doRemoveCheckOut( attachmate As Attachmate )
	Dim ws As New NotesUIWorkspace
	
	If ws.Prompt( PROMPT_YESNO,  getLanTxt( "REMOVECHECKOUT" ), getLanTxt( "REMOVECHECKOUT_PROMPT" ) ) Then
		ws.CurrentDocument.Document.attachmate_1_checkinout = ""
		Call attachmate.document.logAttachmateAction( "Check-out removed" )
		
		Call ws.CurrentDocument.Refresh
	End If
End Function


'++LotusScript Development Environment:2:1:attachmate_doEdit:3:8


Function attachmate_doEdit( attachmate As Attachmate )
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Set doc = ws.CurrentDocument.Document
	
	Dim templateid As String
	templateid = doc.GetItemValue( ATTACHMATE_TEMPLATE_ITEM )( 0 )
	If Lcase( Strright( templateid, "." )) = "<new>" Then
		Call attachmate.document.createFromTemplate( Strleft( doc.GetItemValue( ATTACHMATE_TEMPLATE_ITEM )( 0 ), "." )) 
	Else	
		Call attachmate.document.edit()
	End If
End Function

'++LotusScript Development Environment:2:1:attachmate_doCheckIn:3:8


Function attachmate_doCheckIn( attachmate As Attachmate )
	
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Set doc = ws.currentDocument.document
	
	Dim filename As String
	filename = Strleft( Strright( doc.attachmate_1_checkinout( 0 ), "filename=" ), ";" )
	
	Dim s As String
	s = Dir( filename )
	If s = "" Then 
		Print "Error: File not found (" & filename & ")"
	Else
		If attachmate.isFileOpen( filename ) Then 
			s = Strrightback( Replace( filename, "/", "\" ), "\" )
			Msgbox parseParam( getLanTxt( "CHECKIN_OPENERR" ), s ), 64, getLanTxt( "OPENDOCS_TITLE" )
			Goto done
		End If
		
		attachmate.document.logdisabled = True
		
		Call attachmate.document.createFromFile( filename, False )
		Call doc.ReplaceItemValue( "attachmate_1_checkinout", "" )		
		
		attachmate.document.logDisabled = False
		Call attachmate.document.logAttachmateAction( "Check-in" )
		
		If ws.currentDocument.EditMode Then
			Call ws.CurrentDocument.save() 
		Else
			Call doc.save( True, False )
		End If
		
		Call ws.CurrentDocument.Close()
	End If
	
done:
	
End Function

'++LotusScript Development Environment:2:1:getLanTxt:1:8
Public Function getLanTxt( id As String ) As String
	getLanTxt = language.getText( "ATTACHMATE", id )
End Function

























'++LotusScript Development Environment:2:1:isFileOpen:1:8
Function isFileOpen( filename ) As Boolean
	isFileOpen = False 
	If Dir( filename ) = "" Then Goto DONE 'no file
	
	On Error Goto ERRORHANDLER
	On Error 101 Goto ERROR_OPEN
	
	'check if file is open
	Dim f As Integer
	f = Freefile
	Open filename For Input Access Read Lock Read Write As f
	Close f
DONE:
	Exit Function
	
ERROR_OPEN:
	isFileOpen = True
	Resume DONE
	
ERRORHANDLER:
	Print Err & " - " & Error & " from isFileOpen() line " & Erl
	isFileOpen = True
	Resume DONE
End Function


'++LotusScript Development Environment:2:1:attachmate_doOpenCheckout:3:8


Function attachmate_doOpenCheckout( attachmate As Attachmate )
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Set doc = ws.currentDocument.document
	
	Dim filename As String
	filename = Strleft( Strright( doc.attachmate_1_checkinout( 0 ), "filename=" ), ";" )
	
	Dim s As String
	s = Dir( filename )
	If s = "" Then 
		Print parseParam( getLanTxt( "ERRCHECKOUTFILE" ), filename )
	Else
		Dim wf As New WinFiles()
		Call wf.shellExecute( filename, "open", SW_SHOWNORMAL )
	End If
End Function

'++LotusScript Development Environment:2:1:debug:5:8
%REM
	Function debug
	Description: Comments for Function
%END REM
Function debug() As Boolean
	Dim session As New NotesSession
	debug = (session.Commonusername = "Jakob Majkilde" )
End Function

'++LotusScript Development Environment:2:1:attachmate_doConvert:1:8
Function attachmate_doConvert( attachmate As Attachmate )
	'convert the file
	attachmate.silentmode = True
	
	Dim convertedFilename As String
	convertedFilename = attachmate.document.convert( ATTACHMATE_CONVERT_MERGE ) 
	
	If convertedFilename <> "" Then
		'delete the old file
		Call attachmate.document.remove()
		
		'attach the new file
		Call attachmate.document.createFromFile( convertedFilename, True )
	End If
	
	attachmate.silentmode = False
	
End Function

'++LotusScript Development Environment:2:1:attachmate_doRead:2:8

Function attachmate_doRead( attachmate As Attachmate )
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Set doc = ws.CurrentDocument.Document
	
	Dim templateid As String
	templateid = doc.GetItemValue( ATTACHMATE_TEMPLATE_ITEM )( 0 )
	If Lcase( Strright( templateid, "." )) = "<new>" Then
		Call attachmate.document.createFromTemplate( Strleft( doc.GetItemValue( ATTACHMATE_TEMPLATE_ITEM )( 0 ), "." )) 
	Else	
		Call attachmate.document.read()
	End If
End Function

'++LotusScript Development Environment:2:1:loadLanguagePack:5:8
%REM
	Function loadLanguagePack
	Description: Comments for Function
%END REM
Function loadLanguagePack()
	Const VERSION = "01-02-2013"
	On Error Goto eh 'don't fail here
	
	Dim update As Boolean
	update = False
	
	Dim d As LanguageDocument
	Set d = language.getLanguageDoc( "ATTACHMATE", language.getLanguage())
	
	If Not d Is Nothing Then
		If d.isValid() Then
			If d.document().Getitemvalue("version")( 0 ) <> VERSION Then
				update = True
			End If
		Else
			update = True
		End If
	Else
		update = True
	End If
	
	If update Then
		Dim da List As String
		Dim en List As String
		
		da( "PRODUCTNAME" ) = "Attachmate"
		en( "PRODUCTNAME" ) = "Attachmate"
		
		da( "SELECTPRINTFILES" ) = "Vælg filer der skal udskrives"
		en( "SELECTPRINTFILES" ) = "Select files for printing"
		
		da( "SELECTDETACHFILES" ) = "Vælg filer der skal gemmes på disk"
		en( "SELECTDETACHFILES" ) = "Select files to detach"
		
		da( "DELETEOPENFILES" ) = "Klik Ja for at slette filen. Bemærk at filen er åben"
		en( "DELETEOPENFILES" ) = "You are about to delete the file. Note: the file is currently open. Click Yes to confirm"
		
		da( "DELETECHANGEDFILES" ) = "Klik Ja for at slette filen. Dine ændringer wil gå tabt."
		en( "DELETECHANGEDFILES" ) = "You are about to delete the file. Note: You will loose your changes. Click Yes to confirm"
		
		da( "DELETEFILES" ) = "Klik Ja for at slette filen"
		en( "DELETEFILES" ) = "You are about to delete the file. Click Yes to confirm"
		
		da( "DELETEFILES_TITLE" ) = "Bekræft sletning"	
		en( "DELETEFILES_TITLE" ) = "Confirm file deletion"	
		
		da( "DELETELOG" ) = "Dokument slettet af %1 den %2" 
		en( "DELETELOG" ) = "Document deleted %2 by %1" 
		
		da( "OTHER" ) = "Andre..."
		en( "OTHER" ) = "Other..."
		
		
		'%1: filename, %2 application name
		da( "OPENDOCS" ) = "Du kan ikke forlade dokumentet i Notes, før du har lukket filen '%1' i programmet '%2'"
		en( "OPENDOCS" ) = "'%1' is still open in '%2' - please close this first"
		
		da( "ALLREADYOPEN" ) = "Dokumentet er allerede åbnet."
		en( "ALLREADYOPEN" ) = "Document is allready open. Please close first"
		
		da( "OPENDOCS_TITLE" ) = "Åbent dokument"
		en( "OPENDOCS_TITLE" ) = "Document open"
		
		'%1=filename, %2=application, %3=database title
		da( "SAVEDOC" ) = "Skal de ændringer, du har foretaget i filen '%1', gemmes i '%3'?"
		en( "SAVEDOC" ) = "Do you want to save changes to the file '%1' in '%3'"
		
		da( "SAVEDOC_TITLE" ) = "Gem ændringer?"
		en( "SAVEDOC_TITLE" ) = "Save changes?"
		
		'%1=filename
		da( "CHANGEDFILE" ) = "Der er ændret i filen '%1' mens den var åbnet i læsetilstand. Du kan nu vælge en af følgende:"
		en( "CHANGEDFILE" ) = "The file '%1' is modified in readmode - please select an action:"
		
		da( "CHANGEDFILE_TITLE" ) = "Fil er ændret"
		en( "CHANGEDFILE_TITLE" ) = "File is modified"
		
		'Required: option 1=Save, option 2=Mail, option 3=Ignore
		da( "CHANGEDFILE_OPTIONS" ) = "Gem ændringer i filen,Send filen til mig selv i en mail,Forlad uden at gemme ændringen i filen"
		en( "CHANGEDFILE_OPTIONS" ) = "Save the file,Mail the file to myself,Ignore the changes"
		
		da( "SELECTTEMPLATE" ) = "Vælg en skabelon"
		en( "SELECTTEMPLATE" ) = "Please select a template"
		
		da( "SELECTTEMPLATE_TITLE" ) = "Skabelon?"
		en( "SELECTTEMPLATE_TITLE" ) = "Template?"
		
		da( "SELECTFILE" ) = "Vælg fil"
		en( "SELECTFILE" ) = "Please select a file"
		
		da( "SELECTFILE_TITLE" ) = "Fil?"
		en( "SELECTFILE_TITLE" ) = "File?"
		
		da( "READ" ) = "Læs"
		en( "READ" ) = "Read"
		
		da( "EDIT" ) = "Rediger"
		en( "EDIT" ) = "Edit"
		
		da( "DELETE" ) = "Slet dokument"
		en( "DELETE" ) = "Delete"
		
		da( "PRINT" ) = "Udskriv"
		en( "PRINT" ) = "Print"
		
		da( "DETACH" ) = "Gem på disk"
		en( "DETACH" ) = "Detach file"
		
		da( "CREATEPDF" ) = "Opret PDF mail"
		en( "CREATEPDF" ) = "Create PDF mail"
		
		da( "CREATEMAIL" ) = "Opret mail"
		en( "CREATEMAIL" ) = "Create mail"
		
		da( "CREATEMAILMERGED" ) = "Opret mail, flettet"
		en( "CREATEMAILMERGED" ) = "Create mail, merged"
		
		da( "CREATETEMPLATE" ) = "Opret fra skabelon"
		en( "CREATETEMPLATE" ) = "Create from template"
		
		da( "CREATEFILE" ) = "Opret fra fil"
		en( "CREATEFILE" ) = "Create from file"		
		
		da( "OPENFOLDER" ) = "Åben folder"
		en( "OPENFOLDER" ) = "Open folder"		
		
		da( "RESTORE" ) = "Gendan fil"
		en( "RESTORE" ) = "Restore file"		
		
		da( "CONVERT.FLAT" ) = "Konverter til flad/flettet fil"
		en( "CONVERT.FLAT" ) = "Convert to merged file"
		
		da( "OPENTEMPLATE" ) = "Åben skabelon"
		en( "OPENTEMPLATE" ) = "Open template"		
		
		da( "REPLACEFILE" ) = "Der findes allerede en fil. Ønsker du at overskrive denne?"
		en( "REPLACEFILE" ) = "File exist! - Click Yes to replace."	
		
		da( "REPLACEFILE_TITLE" ) = "Slet eksisterende fil?"
		en( "REPLACEFILE_TITLE" ) = "Delete file?"	
		
		da( "NOTRESPONDING_EXCEL" ) = "Kan ikke kommunikere med Excel? Har du en dialogboks åben eller er du igang med at redigere i en celle?"
		en( "NOTRESPONDING_EXCEL" ) = "Please close any dialogboxes and check that you are not currently editing a cell"
		
		da( "NOTRESPONDING_EXCEL_TITLE" ) = "Excel er låst"
		en( "NOTRESPONDING_EXCEL_TITLE" ) = "Excel is locked"
		
		
		da( "NOTRESPONDING" ) = "Kan ikke kommunikere med %2? Har du en dialogboks åben? Prøv evt. at lukke programmet og prøv så igen"
		en( "NOTRESPONDING" ) = "%2 is not responding. Do you have any open dialogboxes? Please close the program and try again."
		
		da( "NOTRESPONDING_TITLE" ) = "Programmet svarer ikke"
		en( "NOTRESPONDING_TITLE" ) = "Application is not responding"
		
		
		'<new multipurpose buttons>
		da( "CREATE" ) = "Opret"
		en( "CREATE" ) = "Create"	
		da( "CREATE_PROMPT" ) = "Hvordan vil du oprette?"
		en( "CREATE_PROMPT" ) = "Select how to create:"	
		da( "OPTIONS" ) = "Filhåndtering"
		en( "OPTIONS" ) = "File options"	
		da( "OPTIONS_PROMPT" ) = "vælg en aktion fra listen"
		en( "OPTIONS_PROMPT" ) = "What do you want to do"	
		'</new multipurpose buttons>
		
		'<common stuff>
		da( "ERROR" ) = "Fejl"
		en( "ERROR" ) = "Error"
		'</common stuff>
		
		'<checkin/checkout>
		da( "CHECKIN" ) = "Tjek ind"
		en( "CHECKIN" ) = "Check in"
		
		da( "CHECKIN_OPENERR" ) = "Filen er åben (%1) og kan ikke tjekkes ind. Venligst gem & luk og prøv så igen."
		en( "CHECKIN_OPENERR" ) = "The file (%1) is open and can't be checked ind. Please save & close and try again"
		
		da( "CHECKOUT" ) = "Tjek ud"
		en( "CHECKOUT" ) = "Check out"
		
		da( "CHECKEDOUT" ) = "%1 Dokument udtjekket af %2"
		en( "CHECKEDOUT" ) = "%1 Document checked-out by %2"
		
		da( "OPENCHECKOUT" ) = "Åben dokument"
		en( "OPENCHECKOUT" ) = "Open document"
		
		da( "ERRCHECKOUT" ) = "Filen er åben og kan ikke checkes ud. Prøv evt. et genåbne Notes dokumentet"
		en( "ERRCHECKOUT" ) = "You can't check an open file out . Please reopen the Notes document"
		
		'%1: filename
		da( "ERRCHECKOUTFILE" ) = "Fejl - fil ikke fundet (%1)"
		en( "ERRCHECKOUTFILE" ) = "Error: File Not found (%1)"
		
		'%1: the filename, %2: the OPENCHECKOUT message
		da( "CHECKOUTMSG" ) = "Dokument gemt som '%1' - Klik '%2' for at redigere dokumentet"
		en( "CHECKOUTMSG" ) = "Document saved as '%1' - click the '%2' button to edit"
		
		
		da( "REMOVECHECKOUT" ) = "Fjern udtjek"
		en( "REMOVECHECKOUT" ) = "Remove checkout"
		
		da( "REMOVECHECKOUT_PROMPT" ) = "Er du sikker på at du vil fjerne referencen til den udtjekkede fil?" 
		en( "REMOVECHECKOUT_PROMPT" ) = "Are you sure that you will remove the reference to the checkout file?" 
		
		'</checkin/checkout>
		
		'<view controls>
		da( "NOSELECTION_PROMPT" ) = "Du skal markere et dokument i listen"
		en( "NOSELECTION_PROMPT" ) = "Please select a document"
		
		da( "NOSELECTION" ) = "Ingen dokumenter valgt"
		en( "NOSELECTION" ) = "No selection"
		
		da( "DELETEDOCUMENTS" ) = "Slet dokumenter?"
		en( "DELETEDOCUMENTS" ) = "Delete documents?"
		
		'%1: document count
		da( "DELETEDOCUMENTS_PROMPT" ) = "Er du sikker på at du vil slette %1 dokument(er)?"
		en( "DELETEDOCUMENTS_PROMPT" ) = "This will delete %1 document(s)"
		
		da( "DOCUMENTSPRINTED" ) = "%1 dokument(er) sendt til printer"
		en( "DOCUMENTSPRINTED" ) = "%1 document(s) printed"
		
		da( "DOCUMENTSSAVED" ) = "%1 dokumenter(er) gemt på disk"
		en( "DOCUMENTSSAVED" ) = "%1 document(s) saved"
		
		da( "SUCCESS" ) = "Succes"
		en( "SUCCESS" ) = "Success"
		
		da( "FILEEXIST" ) = "Fil findes"
		en( "FILEEXIST" ) = "File exist"
		
		'%1 Filename
		da( "FILEEXIST_PROMPT" ) = "Filen '%1' findes allerede. Vælg aktion:"
		en( "FILEEXIST_PROMPT" ) = "The file '%1' is allready on the disk. Please select an action:"
		
		da( "FILEEXIST_OVERWRITE" ) = "Erstat eksisterende fil"
		en( "FILEEXIST_OVERWRITE" ) = "Replace existing file"
		
		'%1 New filename
		da( "FILEEXIST_RENAME" ) = "Skift navn til '%1'"
		en( "FILEEXIST_RENAME" ) = "Rename to '%1'"
		
		da( "FILEEXIST_SKIP" ) = "Spring denne fil over"
		en( "FILEEXIST_SKIP" ) = "Skip this file"
		
		da( "FILEEXIST_CANCEL" ) = "Stop alle"
		en( "FILEEXIST_CANCEL" ) = "Stop all"
		
		
		'</view controls>
		Call language.createLanguageDoc( "ATTACHMATE", "EN", en )
		Call language.createLanguageDoc( "ATTACHMATE", "DA", da )
		
		Set d = language.getLanguageDoc( "ATTACHMATE", language.getLanguage())
		If d.isValid() Then
			d.document().version = VERSION
			Call d.document().save( True, False )
		End If
	End If
	
done:
	Exit Function
eh:
	Print Err, Error, Erl, Getthreadinfo( 1 )
	Resume done
End Function

'++LotusScript Development Environment:2:1:X_PrintDebugInfo:5:8
%REM
	Function getDebugInfo
	Description: Comments for Function
%END REM
Function X_PrintDebugInfo(msg As string) As String
	print Now, LSI_Info( 12 ), msg
End Function

'++LotusScript Development Environment:2:1:attachmate_doCreate:3:8


Function attachmate_doCreate( attachmate As Attachmate )
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Set doc = ws.CurrentDocument.Document
	
	Dim options(1 ) As String
	options( 0 ) = getLanTxt( "CREATETEMPLATE" )
	options( 1 ) = getLanTxt( "CREATEFILE" )
	
	Dim selectlist() As String
	Redim selectlist( 0 )
	Dim cnt As Integer
	Dim disabledFeatures As Variant
	disabledFeatures = doc.AttachmateDisabledFeatures
	
	If Isnull( Arraygetindex( disabledFeatures, "CREATEFROMTEMPLATE", 5 )) Then
		Redim Preserve selectlist( cnt )
		selectlist( cnt ) = options( 0 )
		cnt = cnt+1
	End If
	
	If Isnull( Arraygetindex( disabledFeatures, "CREATEFROMFILE", 5 )) Then
		Redim Preserve selectlist( cnt )
		selectlist( cnt ) = options( 1 )
		cnt = cnt+1
	End If
	
	If cnt = 0 Then Print "All features are disabled" : Exit Function
	
	Dim s As String
	If cnt = 1 Then
		'only one choice - don't prompt
		s = selectlist( 0 )
	Else
		'prompt
		s = ws.Prompt( PROMPT_OKCANCELLIST, getLanTxt( "CREATE" ), getLanTxt( "CREATE_PROMPT" ), selectlist( 0 ), selectlist )
		If s = "" Then Exit Function
	End If
	
	Select Case s
	Case options( 0 ): Call attachmate.document.createFromTemplate( doc.GetItemValue( ATTACHMATE_TEMPLATE_ITEM )( 0 )) 
	Case options( 1 ): Call attachmate.document.createFromFile("", True )
	End Select
	
End Function

'++LotusScript Development Environment:2:1:attachmate_doOptions:2:8

Function attachmate_doOptions( attachmate As Attachmate )
	Dim session As New NotesSession
	Dim db As NotesDatabase
	Set db = session.CurrentDatabase
	
	Dim ws As New NotesUIWorkspace
	Dim doc As NotesDocument
	Set doc = ws.CurrentDocument.Document
	
	Dim options( 8 ) As String
	options( 1 ) = getLanTxt( "DETACH" )
	options( 0 ) = getLanTxt( "PRINT" )
	options( 2 ) = getLanTxt( "CREATEMAIL" )
	options( 3 ) = getLanTxt( "CREATEMAILMERGED" )
	options( 4 ) = getLanTxt( "CREATEPDF" )
	options( 5 ) = getLanTxt( "DELETE" )
	options( 6 ) = getLanTxt( "CONVERT.FLAT" )
	options( 7 ) = getLanTxt( "CHECKIN" )
	options( 8 ) = getLanTxt( "CHECKOUT" )
	
	Dim selectlist() As String
	Redim selectlist( 0 )
	Dim cnt As Integer
	Dim disabledFeatures As Variant
	disabledFeatures = doc.AttachmateDisabledFeatures
	
	If Isnull( Arraygetindex( disabledFeatures, "DETACH", 5 )) Then
		Redim Preserve selectlist( cnt )
		selectlist( cnt ) = options( 1 )
		cnt = cnt+1
	End If
	
	If Isnull( Arraygetindex( disabledFeatures, "PRINT", 5 )) Then
		Redim Preserve selectlist( cnt )
		selectlist( cnt ) = options( 0 )
		cnt = cnt+1
	End If
	
	If Isnull( Arraygetindex( disabledFeatures, "MAIL", 5 )) Then
		Redim Preserve selectlist( cnt )
		selectlist( cnt ) = options( 2 )
		cnt = cnt+1
	End If
	
	If Isnull( Arraygetindex( disabledFeatures, "MAILMERGED", 5 )) Then
		Redim Preserve selectlist( cnt )
		selectlist( cnt ) = options( 3 )
		cnt = cnt+1
	End If
	
	
	If Isnull( Arraygetindex( disabledFeatures, "MAILPDF", 5 )) Then
		Redim Preserve selectlist( cnt )
		selectlist( cnt ) = options( 4 )
		cnt = cnt+1
	End If
	
	If Isnull( Arraygetindex( disabledFeatures, "DELETE", 5 ))  And ws.CurrentDocument.EditMode Then
		Redim Preserve selectlist( cnt )
		selectlist( cnt ) = options( 5 )
		cnt = cnt+1
	End If
	
	'check-in/check-out feature
	Dim profile As NotesDocument
	Set profile = db.getProfileDocument( "Setup" )
	If profile.getItemValue( "attachmateEnableCheckInOut" )( 0 ) = "1" Then
		If ws.CurrentDocument.EditMode Then
			If doc.GetItemValue( "attachmate_1_checkinout" )( 0 ) = "" Then
			'check-out
				If Isnull( Arraygetindex( disabledFeatures, "CHECKOUT", 5 )) Then
					Redim Preserve selectlist( cnt )
					selectlist( cnt ) = options( 8 )
					cnt = cnt+1
				End If
			Else
			'check-.in
'this is done from the document
'			Redim Preserve selectlist( cnt )
'			selectlist( cnt ) = options( 7 )
'			cnt = cnt+1
			End If
		End If
	End If
	
	'speciel word feature when using an additional merge file: convert to flat merge file
	If doc.Getitemvalue(ATTACHMATE_TEMPLATE_ITEM)( 0 ) <> "" Then
		If Not attachmate.template.hasTemplate() Then
			Call attachmate.template.setTemplate( doc.Getitemvalue(ATTACHMATE_TEMPLATE_ITEM)( 0 ))
		End If
	End If
	
	If attachmate.template.hasTemplate() Then
		If attachmate.template.getFieldString( "wordUseMergeFile" ) = "1" Then 
			If Isnull( Arraygetindex( disabledFeatures, "CONVERT", 5 ))  And ws.CurrentDocument.EditMode  Then
				
				Redim Preserve selectlist( cnt )
				selectlist( cnt ) = options( 6 )
				cnt = cnt+1
			End If
		End If
	End If
	
	If cnt = 0 Then Print "All features are disabled" : Exit Function
	
	Dim s As String
	s = ws.Prompt( PROMPT_OKCANCELLIST, getLanTxt( "OPTIONS" ), getLanTxt( "OPTIONS_PROMPT" ), selectlist( 0 ), selectlist )
	If s = "" Then Exit Function
	
	Select Case s
	Case options( 1 ): Call attachmate.document.saveAs( ATTACHMATE_CONVERT_NO )
	Case options( 0 ): Call attachmate.document.print()
	Case options( 2 ): Call attachmate.document.mailAs( ATTACHMATE_CONVERT_NO )
	Case options( 3 ): Call attachmate.document.mailAs( ATTACHMATE_CONVERT_MERGE )
	Case options( 4 ): Call attachmate.document.mailAs( ATTACHMATE_CONVERT_PDF )
	Case options( 5 ): Call attachmate.document.remove()
	Case options( 6 ): Call attachmate_doConvert( attachmate ) 'attachmate.document.convert( ATTACHMATE_CONVERT_MERGE )
	Case options( 7 ): Call attachmate_doCheckIn( attachmate )
	Case options( 8 ): Call attachmate_doCheckOut( attachmate )
	End Select
End Function









