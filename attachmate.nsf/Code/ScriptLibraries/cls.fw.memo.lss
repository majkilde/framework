'++LotusScript Development Environment:2:5:(Options):0:74
Option Declare
Option Public
Use "cls.system"
Use "cls.utils"

'++LotusScript Development Environment:2:5:(Forward):0:1
Declare Public Class ParseFormula As AbstractObject
Declare Public Class Mailer As AbstractObject 
Declare Class NewsletterView As AbstractObject
Declare Public Class AbstractRichTextWrapper As AbstractObject
Declare Class MemoTemplate As AbstractRichTextWrapper
Declare Public Class AbstractMemo As AbstractRichTextWrapper
Declare Public Class HTMLMemo As AbstractMemo
Declare Public Class RTFMemo As AbstractMemo
Declare Public Class TextMemo As AbstractMemo
Declare Public Function getMemo( db As Variant, template As Variant ) As AbstractMemo
Declare Function createMemo( db As Variant, template As Variant ) As AbstractMemo
Declare Function disableOOO( memo As NotesDocument )

'++LotusScript Development Environment:2:5:(Declarations):0:10


%REM
**************************************************************************************************************************'
COPYRIGHT 2003-2012 by MAJKILDE Aps
**************************************************************************************************************************'
This library is programmed and owned by MAJKILDE Aps
Under the copyright laws, neither the documentation nor the software may be copied, photocopied, 
reproduced, translated, resold, or reduced to any electronic medium or machine-readable form, 
in whole or in part, without the prior written consent of MAJKILDE Aps, except in the manner described 
in the documentation or the applicable licensing agreement governing the use of the software.
**************************************************************************************************************************'
%ENDREM


%REM
Rev 6.9.5 majkilde 5.07.2012
- disableOOO function added
Rev 6.9.1 majkilde 19.03.2012
- Fixed some initial values in the AbstractMemo
Rev 6.9 majkilde 12.02.2012
- All richtext handling are now using the AbstractRichText class (thrugh the AbstractRichTextWrapper class)
Rev 6.8.1 majkilde 8.02.2012
- Methods in NewletterView class made public ;-)
Rev 6.8 majkilde 15.01.2012
- New NewsletterView class
Rev 6.7.4 majkilde 22.12.2011
- Fix a small bug in the memoTemplate.creame method
- New method: AbstractMemo.getMySignatureAsString
Rev 6.6.12 majkilde 24.10.2011
- Fixed a problem med evaluationg multivalue fields
Rev 6.6.11 majkilde 12.08.2011
- MemoTemplate.getTemplate now supports multivalue input	
Rev 6.6.10 majkilde 10.08.2011
- AbstractMemo.disableOOO write only property added
Rev 6.6.2 majkilde 30.4.2011
- Now supports multiple #DOCLINK# tags
- and multivalues/newlines
- Link gets a nice comment text	
Rev 6.6.1 majkilde 8.04.2011
- Mailer class updated with styles etc. 
Rev 6.6 majkilde 6.04.2011
- Added: Class MemoTemplate
- Deleted: Class MemoTemplateManager
- Class Memo made private: You don't need this - create and send a new memo with:
	 dim m as new AbstractMemo( "*", "<template name>" )
	 call m.create( sourceDocuument, nothing )
	 if not m.send() then
	 	print "No mail sent"
	 end if 
Rev 6.5.2 majkilde 26.01.2011
- GetBody added
- Insert method updated
Rev 6.5.1 majkilde 13.11.2011
- $AutoForward added to mailer
Rev 6.4 majkilde 1-12-2010
- Mailer fixes	
Rev 6.3.2 majkilde 22-11-2010
- Mailer.doResolve added (default=false)
Rev 6.3.1 majkilde 17.11.2010
- Errorhandlers added	
Rev 6.3 majkilde 20.09.2010
- New class: Mailer
Rev 6.2 majkilde 2.09.2010
- Update to use new version af cls.system
- Class MemoTemplateManager added
Rev 6.0.8 majkilde 20.8.2010
- Bug fixes
Rev 6.0.7 majkilde 31.05.2010
- Performance optimation in Memo.setTemplate
Rev 6.0.4 majkilde 23-4-2010
- Fixed a problem when sending an individual mail to multiple recipents
Rev 6.0 majkilde 12-02-2010
- Insert Signature updated to support 8.5 mail
Rev 5.7.4 majkilde 29-11-09
- AS400 bug fix. Links in mails failes due to a bug. Workaround found for text mails 
Rev 5.7.3 majkilde 1.07.09
- The signature (bodySuffix) is now appended when memo is posted (and not when created)
Rev 5.6.3
- SourceDoc not required
Rev 5.6.2
- fixed problem with the body field parse (content was duplicated)
- added a 'inheritedFields' option on the template doc
- fixed problem with the insert method
Rev 5.6
- #DBLINK# and #COLLECTION# added
Rev 5.5.1
- Some obsolete code removed (use of ''cls.document")
Rev 5.5
- getDocument method added to the Memo class
Rev 5.1.1
- New method: setParams
Rev 5.0.1
- Handle multivalue formulas (nice to have in a sendto field)
Rev 5.0
- Merge richtext items is now possible
Rev 4.1.1
- Small fix to the getMailDb method
Rev 4.1
- Finding the mail.box on servers with multiple mailboxes.
- Correct linebreaks with text mails
Rev 4.0 014
- Fixed problem: error when tryin to create memo as response in mail.box...
%END REM
Private Const START_FORMULA_TAG = "{"
Private Const END_FORMULA_TAG = "}"
Private Const DOCLINK_TAG = "#DOCLINK#"
Private Const DBLINK_TAG = "#DBLINK#"
Private Const URLLINK_TAG = "#URLLINK#"
Private Const URLREF_TAG = "#URLREF#"
Private Const HOSTNAME_TAG = "#HOSTNAME#"
'Private Const DOCLINK_TEXT = "Click to open"'ParseFormula

Public Const MAILER_NORECIPIENTS = 9010

Public Class ParseFormula As AbstractObject
	'##################################################################################################	
	Private sourceDoc As NotesDocument
	Private util As Utils
	
	Sub New( sourceDoc As NotesDocument )
		Set Me.sourceDoc = sourceDoc
		Set Me.util = New Utils()
	End Sub 'new
	
	Public Function evalTag( tag As String ) As String 
		On Error GoTo eh
		Select Case tag
			Case URLLINK_TAG: evalTag =  "http://" & util.getHTTPHostname() & util.getUrlTo( sourceDoc )
			Case URLREF_TAG: evalTag = util.getUrlTo( sourceDoc )
			Case HOSTNAME_TAG: evalTag = util.getHTTPHostname()
				
		End Select
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Public Function evaluateFormula( formula As String ) As Variant
		On Error GoTo FORMULA_ERROR
		evaluateFormula = Evaluate( formula, sourceDoc )
		On Error GoTo 0
		
DONE:
		Exit Function
		
FORMULA_ERROR:
		evaluateFormula = |<error in '| & formula & |' - | & Err & " " & Error & | >|
		Resume DONE
	End Function
	
	Private params As Variant
	
	Public Function setParams( params As Variant )
		Me.params = params 
	End Function
	
	Public Function parseRTF( sourceBody As NotesRichTextItem, body As NotesRichTextItem )
		On Error GoTo eh
		Call body.AppendRTItem( sourceBody )
		
		'set html links
		Dim rtf As New AbstractRichText( body.Parent, body )
		Call rtf.searchAndReplace(URLLINK_TAG, evalTag( URLLINK_TAG ), True )
		Call rtf.searchAndReplace(URLREF_TAG, evalTag( URLREF_TAG ), True )
		Call rtf.searchAndReplace(HOSTNAME_TAG, evalTag( HOSTNAME_TAG ), True )

		'set notes links
		If Not sourceDoc Is Nothing Then
			Call rtf.searchAndReplace(DOCLINK_TAG, sourceDoc, True )
			Call rtf.searchAndReplace(DBLINK_TAG, sourceDoc.Parentdatabase, True )
		End If

		'set params
		Dim i As Integer
		If IsArray( params ) Then
			For i = 0 To UBound( params )
				Call rtf.searchAndReplace("%" & ( i+1 ), params( i ), True )
			Next
		End If
		
		'extract formulas from richtext - evaluate and replace
		Dim s As String
		s = body.GetUnformattedText()
		
		Dim formulaStart As Integer
		Dim formulaEnd As Integer
		Dim formula As String
		Dim rc As Variant
		
		formulaStart = InStr( s, START_FORMULA_TAG )
		Do While formulaStart > 0 
			
			formulaEnd = InStr( formulastart, s, END_FORMULA_TAG )
			
			formula = Mid$( s, formulaStart+1, formulaEnd - formulaStart-1 )
			
			'is the formula just an RichTextItem? Then just insert the content of the item (and dont evaluate)
			Dim item As Variant
			If Not sourceDoc Is Nothing Then
				If sourceDoc.HasItem( formula ) Then
					Set item = sourcedoc.GetFirstItem( formula )
					If item.type = RICHTEXT Then
						Call rtf.searchAndReplace( START_FORMULA_TAG & formula & END_FORMULA_TAG, item, False )
						GoTo nextformula
					End If
				End If
			End If
			
			'evaluate formula
			rc = evaluateFormula( formula )
			Call rtf.searchAndReplace( START_FORMULA_TAG & formula & END_FORMULA_TAG, rc, False )

nextformula:
			formulaStart = InStr( formulaend, s, START_FORMULA_TAG )
		Loop
		
		%REM	
		Dim range As NotesRichTextRange

		Set range = body.CreateRange
		Call range.FindandReplace( URLLINK_TAG, evalTag( URLLINK_TAG ))
		Set range = body.CreateRange
		Call range.FindandReplace( URLREF_TAG, evalTag( URLREF_TAG ))
		Set range = body.CreateRange
		Call range.FindandReplace( HOSTNAME_TAG, evalTag( HOSTNAME_TAG ))
		
		Dim i As Integer
		If Isarray( params ) Then
			For i = 0 To Ubound( params )
				Set range = body.CreateRange
				Call range.FindandReplace( "%" & ( i+1 ), params( i ))
			Next
		End If
		
		'extract formulas from richtext - evaluate and replace
		Dim s As String
		s = body.GetUnformattedText()
		
		Dim formulaStart As Integer
		Dim formulaEnd As Integer
		Dim formula As String
		Dim rc As String
		
		formulaStart = Instr( s, START_FORMULA_TAG )
		Do While formulaStart > 0 
			
			formulaEnd = Instr( formulastart, s, END_FORMULA_TAG )
			
			formula = Mid$( s, formulaStart+1, formulaEnd - formulaStart-1 )
			
			Dim item As Variant
			If sourceDoc.HasItem( formula ) Then
				Set item = sourcedoc.GetFirstItem( formula )
				If item.type = RICHTEXT Then
					Call body.AddNewline( 1 )
					Call body.AppendText( "------------------------------------------------------------------------------------------------------------" )
					Call body.AddNewline( 1 )
					Call body.AppendRTItem( item )
					rc = " "
					Goto RESUME_FORMULA_ERROR
				End If
			End If
			
			'evaluate formula
			rc = evalFormula( formula )
			
RESUME_FORMULA_ERROR:		
			Set range = body.CreateRange
			If rc = "" Then rc = " " 'BUG Workaround - Notes doesn't replace with an emptry string
			Call range.FindandReplace( START_FORMULA_TAG & formula & END_FORMULA_TAG, rc )
			
			formulaStart = Instr( formulaend, s, START_FORMULA_TAG )
		Loop
		
		Call insertLinks( body )
		%ENDREM
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function insertLinks( body As NotesRichTextItem )
		On Error GoTo eh
		Dim range As NotesRichTextRange
more:
		'find a doclink?
		Dim pointer As NotesRichTextNavigator
		Set pointer = body.CreateNavigator
		If pointer.FindFirstString( DOCLINK_TAG ) Then
			
			Call body.BeginInsert( pointer, False )
			Call body.AppendDocLink( sourceDoc, getLinkComment( sourceDoc ))
			Call body.EndInsert()
			
			'clear fieldcode
			Set range = body.CreateRange
			Call range.FindandReplace( DOCLINK_TAG, " " )
			
			'search for more tags
			GoTo more
		End If 
		
		'find a dblink?
		Set pointer = body.CreateNavigator
		If pointer.FindFirstString( DBLINK_TAG ) Then
			
			Call body.BeginInsert( pointer, False )
			Call body.AppendDocLink( sourceDoc.ParentDatabase, getLinkComment( sourceDoc.ParentDatabase ))
			Call body.EndInsert()
			
			'clear fieldcode
			Set range = body.CreateRange
			Call range.FindandReplace( DBLINK_TAG, " " )
			
			'search for more tags
			GoTo more
		End If
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Public Function parseToRichText( formulaText As Variant, rtItem As NotesRichTextItem )
		On Error GoTo eh
		Dim v As Variant
		Dim i As Integer
		Dim s As String 
		Dim util As New Utils()
		
		v = parse( formulaText ) 'text parser
		
		'Append result to richtext field and insert links
		ForAll entry In v
			s = CStr( entry )
			
			'insert urls
			s = Replace( s, URLLINK_TAG, "http://" & util.getHTTPHostname() & util.getUrlTo( sourceDoc ))
			s = Replace( s, URLREF_TAG, util.getUrlTo( sourceDoc ))
			s = Replace( s, HOSTNAME_TAG, util.getHTTPHostname())
			
			'insert doc links
			%REM 'AS400 bug: AppendDoclink doesn't work after BeginInsert
			Call rtItem.AppendText( s ) 
			Call insertLinks( rtItem )
		%ENDREM
				
				'<multiple links hack>
				Dim a As Variant
				a = Split( s, DOCLINK_TAG )
				If UBound( a ) > 0 Then
					For i = 0 To UBound( a )
						Call rtItem.AppendText( a( i ))
						If i <> UBound( a ) Then
							Call rtItem.Appenddoclink(sourceDoc, getLinkComment( sourceDoc ))
						End If
					Next
				Else
					'no doclinks
					Call rtItem.AppendText( s )
				End If
				'<hack>
				
		%REM
				i = Instr( s, DOCLINK_TAG )
				If i = 0 Then 'no link in this line
					Call rtItem.AppendText( s )
				Else
					Call rtItem.AppendText( Left( s, i-1 ))
					
					Call rtItem.AppendDoclink( sourceDoc, DOCLINK_TEXT )
					
					Call rtItem.AppendText( Mid( s, i+Len( DOCLINK_TAG )))					
				End If
		%ENDREM
				
				'insert db links
				'	i = Instr( s, DBLINK_TAG )
				'	If i = 0 Then 'no link in this line
				'		Call rtItem.AppendText( s )
				'	Else
				'		Call rtItem.AppendText( Left( s, i-1 ))
				'		
				'		Call rtItem.AppendDoclink( sourceDoc.ParentDatabase, DOCLINK_TEXT )
				'		
				'		Call rtItem.AppendText( Mid( s, i+Len( DOCLINK_TAG )))					
				'	End If
			End ForAll
			
			
			Exit Function
eh:
			Error Err, getErrorInfo( Me )
	End Function 'parseToRichText
	
	Public Function parse( formulaText As Variant ) As Variant
		On Error GoTo eh
		Dim result As New AbstractArray ( Null )
		Dim v As String
		
		If IsArray( formulaText ) Then
			ForAll f In formulaText
				Call result.add( parseToVariant( CStr( f )))
			End ForAll
		Else
			Call result.add( parseToVariant( CStr( formulaText )))
		End If
		
		parse = result.elements
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function 'parse
	
	Function parseToVariant( s As String ) As Variant
		On Error GoTo eh
		'Formula brackets = {}
		Dim result As Variant
		ReDim result( 0 )
		result( 0 ) = Null
		Dim idx As Long
		Dim v As Variant 'temporary var
		
		Dim formulaStart As Integer
		Dim formulaEnd As Integer
		Dim formula As String
		
		
		formulaStart = InStr( s, START_FORMULA_TAG )
		
		If formulaStart = 0 Then
			result = cList( s )
		End If
		
		Do While formulaStart > 0 
			formulaEnd = InStr( s, END_FORMULA_TAG )
			'Call result.setElementAt( result.elementAt( idx ) & Left( s, formulaStart-1 ), idx )
			formula = Mid$( s, formulaStart+1, formulaEnd - formulaStart-1 )
			
			Dim item As Variant
			If Not sourceDoc Is Nothing Then				
				If sourceDoc.HasItem( formula ) Then
					Set item = sourcedoc.GetFirstItem( formula )
					If item.type = RICHTEXT Then
						v = item.getUnformattedtext
						GoTo RESUME_FORMULA_ERROR
					End If
				End If
			End If
			
			'			On Error Goto FORMULA_ERROR
			v = EvaluateFormula( formula )
			'			On Error Goto 0

RESUME_FORMULA_ERROR:
			If IsArray( v ) Then 'seperate multivalues with newlines
			'	v = Join( v, Chr( 10 ))
			End If

			If Not IsArray( v ) Then
				v = cList( v )	
			End If
			
			If UBound( v ) > 0 Then
				If IsNull( result( 0 )) Then 'new, just replace
					If Trim( Left( s, formulaStart -1 )) <> "" Then
						result( 0 ) = Left( s, formulaStart -1 ) 
						ForAll entry In v 'append
							ReDim Preserve result( UBound( result )+1 )
							result( UBound( result )) = entry
						End ForAll
					Else
						result = v
					End If
				Else
					ForAll entry In v 'append
						ReDim Preserve result( UBound( result )+1 )
						result( UBound( result )) = entry
					End ForAll
				End If
				
			Else 'single value
				If IsNull( result( 0 )) Then
					result( 0 ) = Left( s, formulaStart -1 ) & v( 0 )
				Else
					result( 0 ) = result( 0 ) & Left( s, formulaStart -1 ) & v( 0 )
				End If
			End If
			'			result = result & Left( s, formulaStart -1 ) & cString( v )
			
			s = Mid$( s, formulaEnd+1 )
			formulaStart = InStr( s, START_FORMULA_TAG )
			If formulaStart = 0 Then
				result( UBound( result )) = result( UBound( result )) & s 
			End If
		Loop
		
DONE:		
		parseToVariant = result
		Exit Function
		
		'FORMULA_ERROR:
		'		Call Me.logAction( LOG_WARNING_LOW, parseParams( "Error in formula: %1", formula, "", "", "" ), Nothing )
		'		v = formula & "(" & Error &  ")"
		
		'		Resume RESUME_FORMULA_ERROR
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Private Function parseString( s As String ) As String
		On Error GoTo eh
		Dim result As String
		Dim idx As Long
		Dim v As Variant 'temporary var
		
		Dim formulaStart As Integer
		Dim formulaEnd As Integer
		Dim formula As String
		
		
		formulaStart = InStr( s, START_FORMULA_TAG )
		Do While formulaStart > 0 
			formulaEnd = InStr( s, END_FORMULA_TAG )
			'Call result.setElementAt( result.elementAt( idx ) & Left( s, formulaStart-1 ), idx )
			formula = Mid$( s, formulaStart+1, formulaEnd - formulaStart-1 )
			
			
			Dim item As Variant
			If sourceDoc.HasItem( formula ) Then
				Set item = sourcedoc.GetFirstItem( formula )
				If item.type = RICHTEXT Then
					v = item.getUnformattedtext
					GoTo RESUME_FORMULA_ERROR
				End If
			End If
			
			
			On Error GoTo FORMULA_ERROR
			v = Evaluate( formula, sourceDoc )
			On Error GoTo eh
RESUME_FORMULA_ERROR:		
			result = result & Left( s, formulaStart -1 ) & cString( v )
			
			s = Mid$( s, formulaEnd+1 )
			formulaStart = InStr( s, START_FORMULA_TAG )
		Loop
		
		result = result & s
		
		
DONE:		
		parseString = result
		Exit Function
		
FORMULA_ERROR:
		Call Me.logAction( LOG_WARNING_LOW, parseParams( "Error in formula: %1", formula, "", "", "" ), Nothing )
		v = formula & "(" & Error &  ")"
		
		Resume RESUME_FORMULA_ERROR

		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function 'parseString
	
End Class 
Public Class Mailer As AbstractObject 
	Private mails List As AbstractMemo 
	Private count As Integer 
	
	Private db As NotesDatabase 
	Private template As Variant 
	
	Private redirectto As String 
	
	Public doResolve As Boolean 'true: resolve the recipients (groups etc) 
	
	Public normalStyle As NotesRichTextStyle 'title lines uses this
	Public resumeStyle As NotesRichTextStyle  'sub title lines uses this
	Public tabs As NotesRichTextParagraphStyle 'set the tabs
	
	
	%REM 
                Sub New 
                Description: Comments for Sub 
	%END REM 
	Sub New( templateid As Variant )
		On Error GoTo eh
		Set db = session.Currentdatabase 
		
		If TypeName( templateid ) = "STRING" Then
			Dim mt As New MemoTemplate()
			Set me.template = mt.getTemplate( "*", templateid )
		Else
			Set me.template = template 
		End if
		
		
		me.doResolve = False 
		
		Set normalStyle = session.createRichTextStyle
		normalStyle.Notescolor = COLOR_BLACK
		Set resumeStyle = session.createRichTextStyle
		resumeStyle.Notescolor = COLOR_GRAY
		
		Set tabs = session.Createrichtextparagraphstyle()
		Call tabs.Settab(3.2*RULER_ONE_CENTIMETER, TAB_LEFT)
		
done:
		Exit Sub
eh:
		Error Err, getErrorInfo( Me )
	End Sub 
	
	
	
	%REM 
                Function redirectAll 
                ENable debug mode 
	%END REM 
	Function redirect( address As String ) As Boolean 
		On Error GoTo eh
		me.redirectto = address
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me ) 
	End Function 
	
	%REM 
                Function getRecipients 
                Checks all the recipients 
                - Explode groups 
                - remove invalid entries (servers, anonymous, -default- etc ) 
	%END REM 
	Private Function getRecipients( sendto As Variant ) As Variant 
		On Error GoTo eh 
		Dim recipients As New Array( Null ) 
		
		'convert to array 
		If Not IsArray( sendto ) Then 
			sendto = Split( sendto, "#¤%&" ) 
		End If 
		
		'explode all groups 
		ForAll entry In sendto 'check all 
			Call recipients.add( getMembers( entry )) 
		End ForAll 
		
		
		'check all entries 
		Dim i As Long 
		Dim s As String 
		Dim tmpDoc As NotesDocument 
		
		For i = 0 To recipients.count 
			s = CStr( recipients.getElementAt(i)) 
			
			Select Case LCase( s ) 
			Case "-default-", "anonymous" 
				Call recipients.setElementAt( i, "" ) 
			Case Else 
				Set tmpDoc = CacheManager.getDocument("*!!names.nsf", "($Servers)", s) 
				If Not tmpDoc Is Nothing Then 
					'found a server 
					Call recipients.setElementAt( i, "" ) 
				End If 
		End Select 
			
		Next 
		
		'done 
		Call recipients.unique() 
		Call recipients.Trim() 
		getRecipients = recipients.elements() 
		
		
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me ) 
	End Function 
	
	%REM 
                Find all members in a group or list of groups and persons 
                Will also work when running on a local replica (but requires server access) 
	%ENDREM 
	Private Function getMembers( GroupOrNameList As Variant ) As Variant 
		On Error GoTo eh 
		Dim members As Variant 
		
		'find a server (use the homeserver if script is running on a local database) 
		Dim server As Variant 
		server = Evaluate(|@if( @subset( @dbname;1 ) = ""; @LocationGetInfo([HomeServer]); @subset( @dbname;1 ))|) 
		
		If IsArray( GroupOrNameList ) Then 
			ForAll member In GroupOrNameList 
				If IsEmpty( members ) Then 
					members = getMembers( member ) 
				Else 
					members = ArrayAppend( members, getMembers( member )) 
				End If 
			End ForAll 
		Else 
			members = Evaluate(|@ExpandNameList( "| & server( 0 ) & |":"names.nsf"; "| & GroupOrNameList & |" )|) 
		End If 
		
		'fix problem with persons with an forward address on the person document 
		Dim i As Integer 
		Dim v As Variant 
		For i=0 To UBound(members) 
			If Left(members(i), 3)<>"cn=" Then 
				v = Evaluate(|@NameLookup( [NoUpdate] ; "|+members(i)+|"; "fullname")|) 
				
				If Not IsEmpty(v) Then 
					members(i)=v(0)         
				End If                 
			End If 
		Next 
		
		'remove duplets 
		members = ArrayUnique( members,5 ) 
		
		'return 
		getMembers = members 
		
		
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me ) 
	End Function 
	
	%REM 
          Function add 
          Sendto: recpients. For each recipient find an existing email (or create a new) and append a link/text
          titleFormula: @formula defining the text to append in the mail
          subTitleFormula: Optional @formula with a subtitle/resume text (will be written in gray)
          source: Will be inserted as an link (and formulas evaluates on this)
         
         note: \n and \t will be replaces with newlines and tabs. Uses \\ to insert a \
	%END REM 
	Public Function add( sendto As Variant, titleformula As String, subTitleformula As String, source As NotesDocument ) 
		On Error GoTo eh 
		Dim recipients As Variant 

		If doResolve Then 
			recipients = getRecipients( sendto ) 
		Else 
			If IsArray( sendto ) Then 
				recipients = sendto 
			Else 
				recipients = Split( sendto, "#¤%" ) 
			End If 
		End If 
		If recipients( 0 ) = "" Then 
			Error MAILER_NORECIPIENTS, "No valid recipients"
		End If 
		
		Dim n As NotesName 
		Dim memo As AbstractMemo 
		
		ForAll recipient In recipients 
			'get the mail 
			Set n = New NotesName( recipient ) 
			If IsElement( mails( LCase( n.abbreviated ))) Then 
				Set memo = mails( LCase( n.Abbreviated )) 
				memo.getDocument().count = memo.getDocument().count( 0 ) + 1 
			Else 
				Set memo = GetMemo( db, template ) 
				Call memo.create( source, Nothing ) 
				
				memo.getDocument().sendto = recipient
				memo.disableOOO = True 
				
				
				Call memo.insert( tabs )
				
				memo.getDocument().count = 1 
				Set mails( LCase( n.Abbreviated )) = memo 
				count = count+1 
			End If 
			
			'append the line
			Dim v As Variant 
			
			Dim p As New ParseFormula( source )
			
			If source Is Nothing Then
				If titleformula <> "" Then
					v = p.evaluateFormula( titleformula )
					Call memo.insert( normalStyle )
					Call memo.insert( source ) 
					Call memo.insert( v )
					Call memo.insert( "\n" )
				End If 
				If subTitleformula <> "" Then 
					v = p.evaluateFormula( subTitleformula )
					Call memo.insert( resumeStyle ) 
					Call memo.insert( v ) 
					Call memo.insert( "\n" )
				End If
			Else
				If titleformula <> "" Then
					v = p.evaluateFormula( titleformula )
					Call memo.insert( normalStyle )
					Call memo.insert( source ) 
					Call memo.insert( "\t" )
					Call memo.insert( v )
					Call memo.insert( "\n" )
				End If 
				If subTitleformula <> "" Then 
					v = p.evaluateFormula( subTitleformula )
					Call memo.insert( resumeStyle ) 
					Call memo.insert( "\t" )
					Call memo.insert( v )
					Call memo.insert( "\n" )
				End If
			End If 
		End ForAll 
		
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me ) 
	End Function 


	%REM 
        Function getCount 
        Description: Comments for Function 
	%END REM 
	Public Function getCount() As Integer 
		On Error GoTo eh
		getCount = count
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me ) 
	End Function 

	%REM 
                Function send 
                Description: Comments for Function 
	%END REM 
	Public Function send() As Boolean 
		On Error GoTo eh 
		send = True 
		Dim m As AbstractMemo
		ForAll memo In mails 
			If redirectto<>"" Then 
				With memo.getDocument() 
					.subject = session.createName( .sendto( 0 )).abbreviated & ": " &  .subject( 0 ) & " - " & memo.getDocument().count( 0 ) & " incidents" 
					.sendto = redirectto 
				End With 
			End If 
			
			If Not memo.send Then 
				send = False 
				Call me.logAction(LOG_WARNING_HIGH, m.getMessage(), Nothing ) 
			Else 
				With memo.getDocument() 
					Call me.LogAction( LOG_VERBOSE, parseParams( "Memo '%2' sent to: %1", .sendto, .subject, "", "" ), Nothing ) 
				End With 
			End If 
		End ForAll 
		
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me ) 
	End Function 
End Class
%REM
	Class NewsletterView
	Description: Comments for Class
%END REM
Class NewsletterView As AbstractObject
	Private redirectto As String 

	Sub New(  )
		
	End Sub
	
	
	%REM 
                Function redirectAll 
                ENable debug mode 
	%END REM 
	Public Function redirect( address As String ) As Boolean 
		On Error GoTo eh
		me.redirectto = address
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me ) 
	End Function 
	
	%REM
		ViewName: The source view. 
			Required, First column: Categorized. Recipients (sendto names)
			Required, Second column: Categorized. Sections (headers) (can be an empty string)
			Remaining columns will be formated as a table, where first column will contain a doclink
		template: the memo template to use (string, MemoTemplate or NotesDocument)
		options: not implemented (use nothing)
		Returns the number of mails sent
	%END REM
	Public Function sendMails( viewname As String, template As Variant, options As AbstractParams ) As Integer
		On Error GoTo eh
		Dim recipients As Variant
		Dim formula As String
		formula = parseParam( |@dbcolumn("";@dbname;"%1"; 1 )|, viewname )
		recipients = Evaluate( formula )
		
		Dim db As NotesDatabase
		Set db = session.Currentdatabase
		
		Dim tmpDoc As NotesDocument
		Set tmpDoc = db.Createdocument()
		
		Dim view As NotesView
		Set view = CacheManager.getView(db, viewname)
		Dim nav As NotesViewNavigator
		Dim entry As NotesViewEntry
		
		Dim cnt As Integer
		Dim rtf As New AbstractRichText( Nothing, "" )
		
		Dim columns As Variant
		columns = rtf.getViewColumns( view )
		'skip the first 2 categorized columns
		columns( 0 ) = Null
		columns( 1 ) = Null
		columns = FullTrim( columns )
		
		Dim coll As NotesDocumentCollection
		Dim linkCount As Integer
		Dim sectionCount As Integer
		
		'loop on all recipients
		ForAll recipient In recipients
			If recipient = "" Then GoTo nextRecipient
			
			'create the memo
			Dim m As AbstractMemo
			Set m = getMemo( db, template )
			tmpDoc.sendto = recipient
			Call m.create( tmpDoc, Nothing )
			Call m.setRecipients(recipient, "", "")
			
			Set rtf = New AbstractRichText( m.getDocument(), m.getBody())
			
			'loop on all entries and create the table(s)
			Set nav = view.Createviewnavfromcategory(recipient)
			Set entry = nav.Getfirst()
			Set coll = db.createDocumentCollection
			linkCount = 0
			sectionCount = 0
			
			Dim s As String
			Do Until entry Is Nothing
				If entry.Iscategory Then
					If coll.count > 0 Then
						'append the table
						Call rtf.appendTable( Coll, columns, Nothing)
						Call rtf.append("\n")
					End If
					
					'start on a new section
					s = entry.Columnvalues( 1 )
					Call rtf.append(s)
					sectionCount = sectionCount+1
					
					Set coll = db.createDocumentCollection
				ElseIf entry.Isdocument Then
					linkCount = linkCount+1
					Call coll.Adddocument(entry.Document)
				End If
				
				Set entry = nav.Getnext(entry)
			Loop
			
			'add the final section
			If coll.count > 0 Then
				Call rtf.appendTable( Coll, columns, Nothing)
			End If
			
			'send the mail
			If redirectto<>"" Then 
				With m.getDocument() 
					.subject = session.createName( .sendto( 0 )).abbreviated & ": " &  .subject( 0 ) & " - " & linkCount & " link(s) in " & sectionCount & " section(s)"
					.sendto = redirectto 
				End With 
			End If 
			
			If m.send() Then
				Call me.logAction(LOG_NORMAL, parseParam( "Message send to: %1",session.Createname( recipient ).Abbreviated ), Nothing)
				cnt = cnt+1
			End If
			
nextRecipient:
		End ForAll
		
done:
		Call me.logAction(LOG_NORMAL, parseParam( "%1 mails sent", cnt ), view)
		sendMails = cnt
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
		
	End Function
End Class
%REM
	Class RichTextHandler
	Wrapper class for AbstractRichText (needed a constructor with no params)
	@see class.AbstractRichText 
%END REM
Public Class AbstractRichTextWrapper As AbstractObject
	Private body As AbstractRichText
	
	%REM
		Sub New
		Description: Comments for Sub
	%END REM
	Sub New()
		
	End Sub
	
	%REM
		Initialize the object. 
		Finds or creates a richtext field with the name <itemname> on the <doc> document
	%END REM
	Public Function createItem( doc As NotesDocument, itemname As String ) As NotesRichTextItem
		Set body = New AbstractRichText( doc, itemname )
		Set createItem = body.getItem()
	End Function
	
	%REM
		Append data to the richtext field
		@see class.AbstractRichText 
	%END REM
	Public Function Append( source As Variant ) 
		Call body.append( source )
	End Function
	
	%REM
		Function appendFile
		@see class.AbstractRichText.appendFile
	%END REM
	Public Function appendFile( filename As String )
		Call body.appendFile(Filename)
	End Function
	
	%REM
		Function appendTable
		Description: Comments for Function
	%END REM
	Public Function appendTable(coll As NotesDocumentCollection, columns As Variant, options As AbstractParams )
		Call body.appendTable(Coll, Columns, Options)
	End Function
	
	%REM
		Function getItem
		Description: Comments for Function
	%END REM
	Public Function getItem As NotesRichTextItem
		Set getItem = body.getItem()
	End Function
	
	%REM
		Function getStyle
		Description: Comments for Function
	%END REM
	Public Function getStyle( params As String ) As NotesRichTextStyle
		Set getStyle = body.getStyle(Params)
	End Function
	
	%REM
		Function getViewColumns
		Description: Comments for Function
	%END REM
	Public Function getViewColumns( view As NotesView ) As Variant 
		getViewColumns = body.getViewColumns(View)
	End Function
	
	%REM
		Function update
		Description: Comments for Function
	%END REM
	Public Function update()
		Call body.update()
	End Function
	
	%REM
		Function searchAndReplace
		Description: Comments for Function
	%END REM
	Public Function searchAndReplace( searchFor As String, replaceWith As Variant, allOccurrences As Boolean ) As Boolean
		searchAndReplace = body.searchAndReplace(Searchfor, Replacewith, Alloccurrences)
	End Function
End Class
%REM
	Class MemoTemplate
	Description: Comments for Class
%END REM
Class MemoTemplate As AbstractRichTextWrapper
	Private doc As NotesDocument 'the template document
	
	%REM
		Sub New
		Description: Comments for Sub
	%END REM
	Sub New()
		
	End Sub
	
	%REM
		Function getDocument
		Description: Comments for Function
	%END REM
	Function getDocument() As NotesDocument
		On Error GoTo eh
		Set getDocument = doc
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function getBody
		Description: Comments for Function
	%END REM
	Function getBody() As NotesRichTextItem
		On Error GoTo eh
		Set getBody = body.getItem()
		
'		Dim body As NotesRichTextItem
'		
'		Set body = doc.Getfirstitem("body")
'		If body Is Nothing Then
'			Set body = doc.createRichTextItem( "body ")
'		End If
'		
'		Set getBody = body
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me )
		
	End Function
	
	%REM
	Append data to the body field. 
	Source: 
		String, include \n for newline, \t for tab or \\ for \
		otherwise the same options as for the AbstractRichText append method
		@see class.AbstractRichText
	%END REM
	Public Function insert( source As Variant ) 
		On Error GoTo eh
		If Not doc Is Nothing Then
			Call me.append( source )
		Else
			Call pushMessage( "There is no mail document - can't insert" )
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function		
	
	
	%REM
		Function create
		Creates as new Memo Template document
		dbid: DbConfig id or NotesDatabase
		if you don't intend to save the template, you can provide an empty id
	%END REM
	Function create( dbid As Variant, templateId As String ) As NotesDocument
		On Error GoTo eh
		
		'If dbid = "" Then Set dbid = session.Currentdatabase
		If templateId = "" Then 
			templateId = LCase(session.Createname(session.username).Common) & "-" & Format(Now, "yyyymmdd-hhmm")
		Else
			'does the template allready exist?
			Call getTemplate( dbid, templateId )
			If Not doc Is Nothing Then GoTo done
		End If

		'create a new document
		Dim db As NotesDatabase
		Set db = CacheManager.getDatabase(Dbid)
		Set doc = db.Createdocument()
		doc.form = "memo.template"
		doc.id = templateId
		doc.docid = Evaluate(|@unique|)
		
		Call setAccessibility( "system" )
		Call setUI( False )
		Call setSignature( False )
		Call setPostMethod( "normal" )
		Call setSave( "no" )
		Call setMailType( "standard" )
		Call setContentType( "text" )
		
		Call setItem( "createdBy", session.username )
		Call setItem( "createdOn", db.server )
		
		'Dim body As NotesRichTextItem
		'Set body = doc.Createrichtextitem("body")
		
done:
		Call createItem( doc, "body" )
		
		Call recalc
		Set create = doc
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	%REM
		Function setContentType
		contentType: text, RTF, HTML
	%END REM
	Function setContentType( contentType As String )
		On Error GoTo eh
		Select Case LCase( contentType )
			Case "html": Call setItem( "contentType", "HTML" )
			Case "rtf": Call setItem( "contentType", "RTF" )
				
			Case Else
				Call setItem( "contentType", "text" )
		End Select
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me )
		
	End Function
	
	%REM
		Function setMailType
		mailtype: standard or merge
	%END REM
	Function setMailType( mailtype As String )
		On Error GoTo eh
		Select Case LCase( mailtype )
			Case "merge": Call setItem( "mailtype", "merge" )
				
			Case Else
				Call setItem( "mailtype", "standard" )
		End Select
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	%REM
		Function setColums
		@see class.AbstractRichText
	%END REM
	Function setColums( columns As Variant )
		Call setItem( "columns", columns )
	End Function
	
	%REM
		Function setSave
		save: source, mail or no
	%END REM
	Function setSave( save As String )
		On Error GoTo eh
		Select Case LCase( save )
			Case "source": Call setItem( "save", "source" )
			Case "mail": Call setItem( "save", "mail" )
				
			Case Else
				Call setItem( "save", "no" )
		End Select
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me )
		
	End Function
	
	%REM
	postmethod: normal or mailbox
	%END REM
	Function setPostMethod( postmethod As String )
		Select Case LCase( postmethod )
			Case "mailbox": 
			Call setItem( "postmethod", "mailbox" )
			Call setSave( "no" )
			
			Case Else
				Call setItem( "postmethod", "normal" )
		End Select
	End Function
	
	%REM
		Function setSignature
		Description: Comments for Function
	%END REM
	Function setSignature( signature As Boolean )
		On Error GoTo eh
		If signature Then
			Call setItem( "signature", "1" )
		Else
			Call setItem( "signature", "" )
		End If
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me )
		
	End Function
	
	
	%REM
		Function setUI
		Description: Comments for Function
	%END REM
	Function setUI( ui As Boolean )
		On Error GoTo eh
		If ui Then
			Call setItem( "ui", "1" )
		Else
			Call setItem( "ui", "" )
		End If
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me )
		
	End Function
	
	%REM
		Function setAccessibility
		accessibility: system or user
	%END REM
	Function setAccessibility( accessibility As String )
		On Error GoTo eh
		Select Case LCase( accessibility )
			Case "system": Call setItem( "accessibility", "system" )
			Case Else
				Call setItem( "accessibility", "user" )
		End Select
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me )
		
	End Function
	
	%REM
		Function setItem
		Description: Comments for Function
	%END REM
	Function setItem( itemname As String, value As Variant ) As Boolean
		On Error GoTo eh
		
		Call doc.Replaceitemvalue(Itemname, value)
		setItem = True
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	%REM
		Function setSubject
		Description: Comments for Function
	%END REM
	Function setSubject( subject As String )
		On Error GoTo eh
		Call doc.replaceItemValue( "subject", subject )
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function setRecipients
		Params: a value will overwrite any existing values. Use null to keep old values
			All values can contain Notes @formula, enclosed in {}
	%END REM
	Function setRecipients( sendto As Variant, copyto As Variant, blindcopyto As Variant )
		On Error GoTo eh
		If Not IsNull( sendto ) Then
			Call doc.Replaceitemvalue("sendto", sendto)
		End If
		
		If Not IsNull( copyto ) Then
			Call doc.Replaceitemvalue("copyto", copyto)
		End If
		
		If Not IsNull( blindcopyto ) Then
			Call doc.Replaceitemvalue("blindcopyto", blindcopyto)
		End If
		
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me )
		
	End Function
	
	%REM
		Function setSender
		Params: a value will overwrite any existing values. Use null to keep old values
			All values can contain Notes @formula, enclosed in {}
	%END REM
	Function setSender( principal As Variant, replyto As Variant )
		On Error GoTo eh
		If Not IsNull( principal ) Then
			Call doc.Replaceitemvalue("principal", principal)
		End If
		
		If Not IsNull( replyto ) Then
			Call doc.Replaceitemvalue("replyto", replyto)
		End If
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me )
		
	End Function
	
	
	%REM
		Function recalc
		Description: Comments for Function
	%END REM
	Function recalc() As Boolean
		On Error GoTo eh
		
		Call setItem( "lookupKey", "MEMO.TEMPLATE." & doc.id( 0 ))
		Call setItem( "lookupResult", doc.description( 0 ) & "|" & doc.id( 0 ))
		Call setItem( "systemDocument", 1 )
		Call setItem( "viewIcon", 133 )
		Call setItem( "viewCategory", doc.category( 0 ))
		Call setItem( "viewDescription", doc.description( 0 ) & "|" & doc.id( 0 ))
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function getTemplate
		Returns: a Memo Template document
		dbid: DbConfig id or NotesDatabase
		template: template id (string) or notesDocument
	%END REM
	Function getTemplate( dbid As Variant, template As Variant ) As NotesDocument
		On Error GoTo eh
		Dim id As String
		Set doc = Nothing
		
		Select Case TypeName( template )
			Case "NOTESDOCUMENT":
				Set doc = template
			Case "STRING":
				Id = Trim( LCase( template ))
				If id = "" Then Exit Function
				
				If Len( id ) = 32 Then 'doc unid?
					Set doc = CacheManager.getDocumentById( dbid, id ) 
				End If
				
				'find in the admin.lookup view
				If doc Is Nothing Then
					Set doc = CacheManager.getDocument(Dbid, "admin.lookup", "MEMO.TEMPLATE." & template)
				End If
				
				If doc Is Nothing Then 'find in then sys.lookupMemoId view 
					Set doc = CacheManager.getDocument(Dbid, "sys.LookupMemoId", CStr( template))
				End If
				
				If doc Is Nothing Then 'do a db.search
					Call me.logAction(LOG_VERBOSE, parseParam( "Memo: template (%1) not found in view (admin.lookup) - using a slower db.search instead", template ), Nothing)
					Dim coll As NotesDocumentCollection
					Dim qry As String
					qry = |memoTemplate="1" & id="| & CStr( template ) & |" & deleted!="1"|
					
					Set coll = CacheManager.searchDatabase(Dbid, qry, 1)	
					If Not coll Is Nothing Then 
						Select Case coll.Count
						Case 0: 	
							Set doc = Nothing
						Case 1: 
							Set doc = coll.GetFirstDocument()
						Case Else:
							Set doc = coll.getFirstDocument()
							Call SystemLog.logAction( LOG_WARNING_LOW, parseParams( "Multiple memo templates with ID='%1' found", template, "", "", "" ), Nothing )
					End Select	
					End If
				End If
				
			Case "MEMOTEMPLATE":
				Set doc = template.getDocument()
				
			Case "EMPTY", "NULL":
				Exit Function
			Case Else:
				If IsArray( template ) Then
					'let the user select one of the templates
					Dim tmpDoc As NotesDocument
					Dim tDocs( ) As NotesDocument
					Dim tNames() As String
					ReDim tDocs( 0 )
					ReDim tNames( 0 )
					
					'collect the data
					Dim i As Integer
					For i = 0 To UBound( template )
						Set tmpDoc = getTemplate( dbId, template( i ))
						If Not tmpDoc Is Nothing Then
							'a template is found
							ReDim Preserve tNames( i )
							ReDim Preserve tDocs( i )
							
							Set tDocs( i ) = tmpDoc
							tNames( i ) = tmpDoc.description( 0 )
						End If
					Next
					
					'let the user choose
					Dim s As String
					Dim ws As New NotesUIWorkspace
					s = ws.Prompt(PROMPT_OKCANCELLIST, "Select a template", "Please select a mail", tnames( 0 ), tnames)
					If s = "" Then Exit Function	
					i = ArrayGetIndex( tnames, s )
					Set doc = tDocs( i )		
				Else
					Error 9000, "Illegal parameter"
				End If
		End Select
		
		
		Set getTemplate = doc
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	
	%REM
		Function save
		Description: Comments for Function
	%END REM
	Function save( )
		On Error GoTo eh
		
		If Not doc.Isnewnote Then
			Call setItem( "lastModifiedDate", Now )
			Call setItem( "lastModifiedBy", session.username )
		End If
		
		Call doc.save( True, False )
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
End Class
Public Class AbstractMemo As AbstractRichTextWrapper
	Private db As NotesDatabase 'current database (this)
	Private template As NotesDocument 'the memo template document
	Private doc As NotesDocument 'the mail document
	Private mailbox As NotesDatabase 'the mail.box
	Private mailDb As NotesDatabase 'the users mail database
	Private p As parseFormula 'formula parser. 
	Private parent As NotesDocument 'the parent document (the main source document)
	Private recipients As Array 'all the recipients of the memo 
	
	Sub New( template As NotesDocument )
		Set Me.template = template
		Set db = session.CurrentDatabase
		
		Call init()
		
		Dim server As String
		
		If Not template Is Nothing Then
			
			If LCase( template.postMethod( 0 )) = "mailbox" Then
				'use the mail.box directly
				If session.isOnServer Then
					server = ""
				Else
					Call getMailDb()
					If mailDb.IsOpen Then
						server = mailDb.Server
					Else
						server = db.Server
					End If
				End If
				
				Set mailbox = session.getDatabase( server, "mail.box" )
			End If
		End If
	End Sub
	
	
	%REM
		Function init
		Description: Comments for Function
	%END REM
	Function init()
		On Error GoTo eh
		Set recipients = New Array( Null )
		Set body = Nothing
		Set parent = nothing
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Public Function getMailDb() As NotesDatabase 
		
		On Error GoTo ERRORHANDLER 
		
		If mailDb Is Nothing Then 
			If session.isOnServer Then 
				Call Me.logAction( LOG_DEBUG, "Server based agent - using current db as mail db" , Nothing ) 
				Set mailDb = session.currentDatabase 
			Else 
				Call Me.logAction( LOG_DEBUG, "Find the users mails db" , Nothing ) 
				
				Set mailDb = New NotesDatabase( "", "" ) 
				Call mailDb.OpenMail 
			End If 
		End If 
		
		Call Me.logAction( LOG_DEBUG, "Found Mail db on " & maildb.Server & " // " & maildb.FilePath , Nothing ) 
		Set getMailDb = mailDb 
		
DONE: 
		Exit Function 
		
ERRORHANDLER: 
		Error Err, getErrorInfo( Me ) 
	End Function 
	
	%REM
		Function attach
		Description: Comments for Function
	%END REM
	Public Function attach( filename As String )
		On Error GoTo eh
		Dim content As NotesRichTextItem
		Set content = getBody()
		
		Call content.Embedobject(EMBED_ATTACHMENT, "", filename )
		
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	%REM
		Function getBody
		Description: Comments for Function
	%END REM
	Public Function getBody() As NotesRichTextItem
		On Error GoTo eh
		If body Is Nothing Then
			Set body = New AbstractRichText( doc, "body" )
		End If
		
		Set getBody = body.getItem
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function

	
	%REM
source - data to be inserted in the mail content
source can be: String, NotesRichtextItem, NotesRichTextParagraphStyle, NotesRichTextStyle, NotesDocument, NotesDatabase or NotesView
	%END REM
	Public Function insert( source As Variant ) 
		On Error GoTo eh
		If Not doc Is Nothing Then
			Call body.append( source )
'			Dim content As NotesRichTextItem
'			Set content = getBody()
'			
'			Dim rtf As New AbstractRichText( doc, getBody())
'			Call rtf.append( source )
		Else
			Call pushMessage( "There is no mail document - can't insert" )
		End If
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	%REM
		Function appendFile
		Description: Comments for Function
	%END REM
	Public Function appendFile( filename As String )
		On Error GoTo eh
		If Not doc Is Nothing Then
			Call body.appendFile( filename )
		Else
			Call pushMessage( "There is no mail document - can't insert" )
		End If
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Write only
		Enable/disable the Out Out Office reply
		When enabled the $AutoForward field is set to 1
		and the MIME flag Auto-Response-Suppress is set to 'All'. This field is used by Outlook
		Note: You must add the 'Auto-Response-Suppress' field to the 'Always send the following Notes items in headers' field
		on the 'Advanced outbound MIME options' tab on the configuration document in the Domino Directory

	%END REM
	Public Property Set disableOOO As Boolean
		If disableOOO Then
			Call doc.replaceItemValue( "$AutoForward", "1" ) 'notes
			Call doc.replaceItemValue( "Auto-Response-Suppress", "All" ) 'outlook
		Else
			Call doc.removeItem( "$AutoForward" )
			Call doc.removeItem( "Auto-Response-Suppress" )
		End If
	End Property
	
	
	Public Function getDocument() As NotesDocument
		Set getDocument = doc
	End Function 'document	
	
	Public Function setDocument( doc As NotesDocument ) 
		Set Me.doc = doc
	End Function 'document	
	
	Function getSave() As String
		On Error GoTo  eh
		If Not template Is Nothing Then
			getSave = LCase( template.GetItemValue( "save" )( 0 ))
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function getMailType() As String
		If Not template Is Nothing Then
			getMailType = LCase( template.GetItemValue( "mailType" )( 0 ))
		End If
	End Function
	
	Function getContentType() As String
		If Not template Is Nothing Then
			getContentType = LCase( template.GetItemValue( "contentType" )( 0 ))
		End If
	End Function
	
	Function getPostMethod() As String
		If Not template Is Nothing Then
			getPostMethod = LCase( template.GetItemValue( "postMethod" )( 0 ))
		End If
	End Function
	
	
	Function getSignature() As Boolean
		If Not template Is Nothing Then
			getSignature = ( LCase( template.GetItemValue( "signature" )( 0 )) = "1" )
		End If
	End Function
	
	Function getUI() As Boolean
		If Not template Is Nothing Then
			getUI = ( LCase( template.GetItemValue( "ui" )( 0 )) = "1" )
		End If
	End Function
	
	Function getAccessibility() As String
		If Not template Is Nothing Then
			getAccessibility = LCase( template.GetItemValue( "accessibility" )( 0 ))
		End If
	End Function
	
	%REM
Returns the number of recipients
	%END REM
	Function getRecipientsCount() As Integer
		getRecipientsCount = recipients.count
	End Function
	
	%REM
Creates a new memo document, based on a template

Parameters;
database - the memo document is created in this database
template - the mail template document (notesDocument) or the mail template document id (string)
sourceDoc - retrieve source data from this document and/or insert a docLink in the mail to this document
sourceColl - merge data collection (optional). Will be inserted in a tabel where the columns is defined in the template document (setColumns method)

Example
dim memo as  AbstractMemo
set memo = getMemo( db, "STANDARD" )
call memo.create( doc, nothing )
call memo.send()
	%END REM
	Public Function create( sourceDoc As NotesDocument, sourceColl As NotesDocumentCollection ) As Boolean
		On Error GoTo eh
		Dim v As Variant		
		If sourceDoc Is Nothing Then If Not sourceColl Is Nothing Then Set sourceDoc = sourceColl.GetFirstDocument 'default to first collection entry is empty
		
		Call init()
		
		Set p = New ParseFormula( sourceDoc )
		Set parent = sourceDoc
		
		'create the document
		If getSave() = "no" And getpostMethod() = "mailbox" Then
			Set doc = mailbox.CreateDocument()
		Else
			Select Case getSave()
			Case "mail": 
				Call getMailDb()
				Set doc = mailDb.CreateDocument()
			Case Else
				Set doc = db.CreateDocument()
		End Select
		End If
		
		With doc
			.form = "Memo"
			If Not sourceDoc Is Nothing Then
				If doc.ParentDatabase.ReplicaID = sourceDoc.ParentDatabase.ReplicaID Then 'only create as response if created in the source database
					Call .makeResponse( sourceDoc )
				End If
			End If
			.sendTo = p.parse( template.SendTo )
			.copyTo = p.parse( template.CopyTo )
			.blindCopyTo = p.parse( template.BlindCopyTo )
			.subject = p.parse( template.Subject )
			
			.templateUnid = template.UniversalID
			.templateId = template.id
			
			v = p.parse( template.replyTo )
			If Not v( 0 ) = "" Then .replyTo = v
			
			v = p.parse( template.principal )
			If Not v( 0 ) = "" Then 
				.principal = v
				.from = v
			End If
			
			v = p.parse( template.inetFrom )
			If Not v( 0 ) = "" Then .inetFrom = v
			
			'inherited fields
			Dim item As NotesItem
			ForAll Field In template.inheritedFields
				If Field <> "" Then
					Set item = sourceDoc.GetFirstItem( Field )
					If Not item Is Nothing Then Call doc.CopyItem( item, "" )
				End If
			End ForAll
			
			'Automatically Disable OOO for mails sent by a scheduled agent on the server 
			If session.Isonserver Then
				disableOOO = True
			End If
		End With
		
		Dim content As NotesRichTextItem
		Set content = template.GetFirstItem( "body" )
		
		

		'append the collection (if any)
		If Not sourceColl Is Nothing Then
			Call body.appendTable( sourceColl, template.columns, Nothing )
'			
'			Dim collDoc As NotesDocument
'			Set collDoc = sourceColl.GetFirstDocument
'			Do Until collDoc Is Nothing
'				If collDoc.IsDeleted Then GoTo NEXTDOC
'				If Not collDoc.IsValid Then GoTo NEXTDOC
'				
'				Call content.AppendDocLink( collDoc, "Click me" )
'				Call content.AddNewline( 1 )
'				
'NEXTDOC:
'				Set collDoc = sourceColl.GetNextDocument( collDoc )
'			Loop
		End If
		
		
		create = True
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	%REM
		Function getMySignatureAsString
		Description: Comments for Function
	%END REM
	Public Function getMySignatureAsString() As String
		On Error GoTo eh
		Dim profile As NotesDocument 
		Call getMailDb()
		If Not mailDb Is Nothing Then
			Set profile = mailDb.GetProfileDocument("CalendarProfile")
			If profile.EnableSignature( 0 ) = "1" Then  
				If profile.HasItem("Signature_Rich") Then 'new 8.5 signature
					Dim tmpRtf As NotesRichTextItem
					Set tmpRtf = profile.Getfirstitem("Signature_Rich")
					getMySignatureAsString = tmpRtf.GetUnformattedText()
				Else
					If profile.SignatureOption( 0 ) = "1" Then
						getMySignatureAsString = profile.signature( 0 )
					End If
				End If
			End If
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function appendSignature
		Get the signature from the users mail file, and append it to the body field
	%END REM
	Public Function appendSignature( body As NotesRichTextItem )
		On Error GoTo eh
		Dim profile As NotesDocument 
		If getSignature Then
			Call getMailDb()
			If Not mailDb Is Nothing Then
				Set profile = mailDb.GetProfileDocument("CalendarProfile")
				If profile.EnableSignature( 0 ) = "1" Then  
					If profile.HasItem("Signature_Rich") Then 'new 8.5 signature
						Dim tmpRtf As NotesRichTextItem
						Set tmpRtf = profile.Getfirstitem("Signature_Rich")
						Call body.Appendrtitem(tmpRtf)
					Else
						If profile.SignatureOption( 0 ) = "1" Then
							Call body.AppendText( profile.signature( 0 ))
						End If
					End If
				End If
			End If
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	

	%REM
Calculates hidden fields on the memo document
	%END REM
	Public Function recalc()
		On Error GoTo eh
		If Not doc Is Nothing And Not template Is Nothing Then
			With doc
				.viewCategory = "MEMO\" & template.ID( 0 )
				.viewDescription = .Subject( 0 ) & " {" & .from( 0 ) & "}"
				.viewIcon = 121
			End With
		End If
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function setSubject
		Description: Comments for Function
	%END REM
	Function setSubject( subject As String )
		Call doc.replaceItemValue( "subject", subject )
	End Function
	
	%REM
		Function setSender
		Params: a value will overwrite any existing values. Use null to keep old values
			All values can contain Notes @formula, enclosed in {}
	%END REM
	Function setSender( principal As Variant, replyto As Variant )
		On Error GoTo eh
		If Not IsNull( principal ) Then
			Call doc.Replaceitemvalue("principal", principal)
		End If
		
		If Not IsNull( replyto ) Then
			Call doc.Replaceitemvalue("replyto", replyto)
		End If
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me )
		
	End Function
	
	%REM
		Function setRecipients
		Params: a value will overwrite any existing values. Use null to keep old values
	%END REM
	Function setRecipients( sendto As Variant, copyto As Variant, blindcopyto As Variant )
		On Error GoTo eh
		If Not IsNull( sendto ) Then
			Call doc.Replaceitemvalue("sendto", sendto)
		End If
		
		If Not IsNull( copyto ) Then
			Call doc.Replaceitemvalue("copyto", copyto)
		End If
		
		If Not IsNull( blindcopyto ) Then
			Call doc.Replaceitemvalue("blindcopyto", blindcopyto)
		End If
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
Sends the memo document

Returns
True if the document is successfully send, otherwise returns false.
	%END REM	
	Public Function send( ) As Boolean
		On Error GoTo eh
		Call recalc()
		
		Err = 0 
		On Error Resume Next
		
		With doc
			Call recipients.add( .sendTo )
			Call recipients.add( .copyTo )
			Call recipients.add( .blindCopyTo )
			Call recipients.trim()
			.recipients = recipients.elements()
			.postedDate = Now()
			.postedBy = session.username
		End With
		
		'append the signature		
		Dim content As NotesRichTextItem
		Set content = getBody()
		
		Dim signature As NotesRichTextItem
		Set signature = template.GetFirstItem( "bodySuffix" )
		If Not signature Is Nothing Then Call content.AppendRTItem( signature )
		
		If getSave() = "no" And getPostMethod() <> "mailbox" Then
			'dont save - just send
			Call doc.Send( False )
		Else
			If getSave() = "source" Then
				Call doc.MakeResponse( parent )
			End If
			Call doc.Save( True, False )
			
			If getPostMethod() = "mailbox" Then
				If getSave() <> "no" Then
					Call doc.CopyToDatabase( mailbox )
				End If
			Else
				Call doc.Send( False )
			End If
		End If
		
		
		If Err <> 0 Then
			send = False
			Call Me.logAction( LOG_WARNING_HIGH, parseParams( "Memo NOT send to %3: %1 - %2", Err, Error, doc.sendto, "" ), template )
			Call pushMessage( Error )
		Else
			send = True
		End If
		
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
End Class
Public Class HTMLMemo As AbstractMemo
	'####################################################################################################	
	Private htmlbody As NotesMIMEEntity
	Private header As NotesMIMEHeader
	Private child As NotesMIMEEntity
	Private stream As NotesStream
	
	Private cnt As Integer
	
	Sub New( template As NotesDocument )
		Set stream = session.CreateStream
	End Sub 'new
	
	
	Public Function create( sourceDoc As NotesDocument, sourceColl As NotesDocumentCollection ) As Boolean
		
		create = AbstractMemo..create( sourceDoc, sourceColl )
		
		On Error GoTo eh
		'content
		session.ConvertMime = True
		Set htmlbody = doc.CreateMIMEEntity
		Set header = htmlbody.CreateHeader("Content-Type")
		Call header.SetHeaderVal("multipart/relative")
		Set child = htmlbody.CreateChildEntity
		
		
		'fill the body
		Dim templateBody As NotesRichTextItem
		Set templateBody = template.GetFirstItem( "body" )			
		Dim tempDoc As NotesDocument
		Set tempDoc = db.createDocument
		
		Dim tempBody As NotesRichTextItem
		Set tempBody = tempDoc.CreateRichTextItem( "Body" )
		
		Call p.parseToRichText( templateBody.text, tempBody )
		Call appendSignature( tempBody )
		
		Call stream.WriteText( tempBody.text )		
		
		create = True
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function 'create
	
	
	Public Function send( ) As Boolean
		On Error GoTo eh
		Call recalc()		
		Call child.SetContentFromText(stream, "text/html", ENC_NONE)
		Call stream.Truncate
		
		send = AbstractMemo..send()
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function 'send
	
	%REM
Destructor - does all the cleanup.
	%END REM
	Public Sub Delete()
		session.ConvertMime = False
	End Sub
End Class 



Public Class RTFMemo As AbstractMemo
	'####################################################################################################	
	
	
	Sub New( template As NotesDocument )
		
	End Sub 'new
	
	
	Public Function create( sourceDoc As NotesDocument, sourceColl As NotesDocumentCollection ) As Boolean
		
		create = AbstractMemo..create( sourceDoc, sourceColl )
		
		On Error GoTo eh
		'Content 
		Dim templateBody As NotesRichTextItem
		Dim body As NotesRichTextItem
		
		Set templateBody = template.GetFirstItem( "body" )			
		
		Set body = doc.CreateRichTextItem( "Body" )
		
		Call p.parseRTF( templateBody, body )
		Call appendSignature( body )
		
		create = True
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function 'create
	
	
	
End Class 

Public Class TextMemo As AbstractMemo
	'####################################################################################################	
	
	'Private body As NotesRichTextItem
	
	Sub New( template As NotesDocument )
		
	End Sub 'new
	
	
	Public Function create( sourceDoc As NotesDocument, sourceColl As NotesDocumentCollection ) As Boolean
		On Error GoTo eh
		
		create = AbstractMemo..create( sourceDoc, sourceColl )

		'Content 
		Dim templateBody As NotesRichTextItem
		Set templateBody = template.GetFirstItem( "body" )			
		
		Call getBody()
		
		Call p.parseToRichText( templateBody.GetUnformattedText, body.getItem() )
		
		Call appendSignature( body.getItem() )
		
		'append attachments
		Dim attachments As NotesRichTextItem
		Set attachments = template.GetFirstItem( "attachments" )
		If Not attachments Is Nothing Then
			If IsArray( attachments.EmbeddedObjects ) Then
				Call body.append( "\n\n" )
				Call body.append( attachments )
			End If
		End If
		
		create = True
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function 'create
	
	
End Class 
'++LotusScript Development Environment:2:1:getMemo:10:8




%REM
	Returns as new Memo
	db: source database, use "*" or "" for current
	template: source template document to use. String (id), notesdocument or MemoTemplate
%END REM
Public Function getMemo( db As Variant, template As Variant ) As AbstractMemo
	On Error GoTo eh
	Dim qry As String
	Dim coll As NotesDocumentCollection
	Dim templateDoc As NotesDocument
	
	Dim mt As New MemoTemplate
	Set templateDoc = mt.getTemplate(db, Template)
	
	
	'create and return the memo object
	If Not templateDoc Is Nothing Then
		Select Case LCase( templateDoc.contentType( 0 ))
		Case "text": Set getMemo = New TextMemo( templateDoc )
		Case "rtf": Set getMemo = New RTFMemo( templateDoc )
		Case "html": Set getMemo = New HTMLMemo( templateDoc )
		Case Else:
			Set getMemo = New TextMemo( templateDoc ) 'default
	End Select
		'		call getMemo.setParentObject( me )
	End If
done:
	Exit Function
eh:
	Error Err, getErrorInfo( "" )
End Function 'getMemo

'++LotusScript Development Environment:2:1:createMemo:5:8

%REM
	Same as getMemo
%END REM
Function createMemo( db As Variant, template As Variant ) As AbstractMemo
	On Error GoTo eh
	Set createMemo = getMemo( db, template )
done:
	Exit Function
eh:
	Error Err, getErrorInfo( "" )
End Function
	



































































'++LotusScript Development Environment:2:1:disableOOO:5:8
%REM
	Function disableOOO
	Description: Comments for Function
%END REM
Function disableOOO( memo As NotesDocument )
	Call memo.replaceItemValue( "$AutoForward", "1" ) 'notes
	
	'<X-Auto-Response-Suppress>
	'Note: The X-Auto-Response-Suppress flag must be set in the mime header
	'but, we can't create a new mimeitem if a Notes RichText body item exits on the document
	'solution: copy the body field to another field, create the mime flags and then restore the body field

	'rename the body field
	Dim body As NotesRichTextItem
	Dim copybody As NotesRichTextItem
	Set body = memo.Getfirstitem("body")
	Set copybody = memo.Createrichtextitem("copybody")
	Call copybody.Appendrtitem(body)
	Call body.Remove()

	'mime - set the X-Auto-Response-Suppress flag
	Dim session As New NotesSession
	session.Convertmime = False
	Dim header As NotesMIMEHeader
	Dim mimebody As NotesMIMEEntity
	
	Set mimebody = memo.CreateMIMEEntity
	Set header = mimebody.CreateHeader({MIME-Version})
	Call header.SetHeaderVal("1.0")
	Set header = mimebody.CreateHeader("X-Auto-Response-Suppress")
	Call header.SetHeaderVal("All")
	session.Convertmime = True
	
	'restore the body field
	Set copybody = memo.Getfirstitem("copybody")
	Set body = memo.Createrichtextitem("body")
	Call body.Appendrtitem(copybody)
	Call copybody.Remove()

	'</X-Auto-Response-Suppress>
End Function

