'++LotusScript Development Environment:2:5:(Options):0:74
Option Declare
%REM @!
This work by MAJKILDE is licensed under a Creative Commons Attribution 3.0 Unported License.
 -> http://creativecommons.org/licenses/by/3.0/
	%END REM
%REM @disclaimer
<a rel="license" href="http://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/88x31.png" /></a>&nbsp;This work by <a xmlns:cc="http://creativecommons.org/ns#" href="majkilde.dk" property="cc:attributionName" rel="cc:attributionURL">MAJKILDE</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a>.
	%ENDREM



%REM
This library contains all the basics - classes that are fundamental to the design.
All classes inherits from one super class: AbstractObject
This class gives basic error handling and logging based on AbstractLog

@see class.AbstractObject
@ee class.AbstractLog
%END REM

%REM @revisions
	Rev 6.7.3 majkilde 15.12.2001
	- some minor fixes (cString)
	Rev 6.7.2 majkilde 07.10.2011
	- AbstractRichText.appendFile added
	Rev 6.7.1 majkilde 31.08.2011
	- AbstractRichText.update added
	Rev 6.7 majkilde 24.08.2011
	- New class: AbstractParams
	- AbstractRichText.appendTable
	- AbstractRichTExt.getStyle
	- AbstractRichTExt.getViewColumns
	Rev 6.6.9 majkilde 13-07-2011
	- Array.toString() added
	- CacheManager, getDocument: add an replicaid to the internal id (to secure uniqueness across replicas)
	Rev 6.6.8 majkilde 30.06.2011
	- CacheManager.getCurrentLocation added
	Rev 6.6.2 majkilde 03.05.2011
	- AbstractRichText class added
	Rev 6.4.1 majkilde 07.12.2010
	- Small fix in the cString function
	Rev 6.4 majkilde 01.12.2010
	- Timer functions added to AbstractLog
	Rev 6.2.3 majkilde 16.11.2010
	- CacheManager: Number of documents in cache limited to 100 (notes doesn't have memory enough to cache everything) 
	Rev 6.2.2 majkilde 21.09.2010
	- Fixed a small problem in the CacheManager.getDatabase
Rev 6.2.1 majkilde 15.09.2010
- Added error handlers to the CacheManager
Rev 6.2 majkilde 02.09.2010
- CacheManager added	
- Array, Utils, Strings moved to cls.utils 
Rev 5.7.5 majkilde 9.02.2010
- getLinkComment function added	
Rev 5.7.4 
- ParseParam function cleanup
Rev 5.5
- Better errorhandling (with an error stack). Use the getErrorInfo function
rev 5.4.2
- RemoveElementAt fixed (problem when removing elements form an empty array)
rev 5.4.1
- fixed resize problem in Array.RemoveElementAt
rev 5.4
- Added a quicksort routine the the Array class (copied from the the domino directory)
- Old sort copied bubbleSort() (sort now calls the new QuickSort method)
- Remove can now remove a lsit (and not just a string )
rev 5.2.2.
- Log will now write to the NotesLog (agent) if available
rev 5.2.1
- added a getNotesUrl to Utils
rev 5.2 / 270508
- improved errorhandling
rev 5.0.2 / 110308
- array.remove small error fix
rev 5.0.1 / 280208
- array.join, ignore null values
rev 4.05 / 080208
- isRTFEmpty method in Utils class: can now handle NotesItem and NotesRichTextItem as well
- fixed a problem in the isEqual function (utils class)
rev 4.04 / 100807
- Fixed problem in array.setValue()
rev 4.03 / 260607
- parseParam now support \n and \t for newlines and tabulators
rev 4.02
- Improved array.unique function
- added utils.isEmpty function
- added parseParam function (for better backward compatiblity)
rev 4.01
- added trimCollection
rev 4.0 0029
 - added cVariant function
 - added replace function in Array
 - hasMember function added to Array
rev 4.0 0028 - integers changed to long
%ENDREM




'++LotusScript Development Environment:2:5:(Forward):0:1
Declare Public Class SystemLogObject
Declare Public Class AbstractObject
Declare Public Class AbstractLog As AbstractObject
Declare Public Class CacheManagerObject As AbstractObject
Declare Public Class AbstractArray As AbstractObject
Declare Public Class AbstractCollection As AbstractObject
Declare Public Class Array As AbstractArray
Declare Public Class AbstractRichText As AbstractObject
Declare Public Class AbstractParams As AbstractObject
Declare Public Function trimCollection( coll As NotesDocumentCollection, options As Integer ) As NotesDocumentCollection
Declare Public Function getErrorInfo( obj As Variant )
Declare Public Function cList( source As Variant ) As Variant
Declare Static Public Function CacheManager() As CacheManagerObject
Declare Public Function hasProfile( db As NotesDatabase, profilename As String ) As Boolean
Declare Public Function getLinkComment( link As Variant ) As String
Declare Public Function cString( source As Variant ) As String
Declare Static Public Function SystemLog() As SystemLogObject
Declare Public Function parseParams( s As String, p1 As Variant, p2 As Variant, p3 As Variant, p4 As Variant ) As String
Declare Public Function parseParam( s As String, params As Variant ) As String

'++LotusScript Development Environment:2:5:(Declarations):0:10
%REM
Set the version number in every script library
%END REM
Private Const VERSION = "6.4.1"

Public Const LOG_FATAL = 1
Public Const LOG_FAILURE = 2
Public Const LOG_WARNING_HIGH = 3
Public Const LOG_WARNING_LOW = 4
Public Const LOG_NORMAL = 5
Public Const LOG_VERBOSE = 6
Public Const LOG_DEBUG = 7'AbstractObject


 








'# SYSTEMLOG ###################################################################################
Public Class SystemLogObject
'####################################################################################	
	Private l As AbstractLog
	Private lastSeverity As Integer 'the last report
	Private lastMsg As String
	Private highSeverity As Integer 'the report with the highest severity
	Private highMsg As String
	
	Private timers List As Long
	
	
	Sub new( )
	'---------------------------------------------------------------------------------------------------------------------------------------------------
	End Sub
	
	Public Function set( l As AbstractLog )
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		Set Me.l = l
	End Function
	
	Public Function logAction( severity As Integer, msg As String, link As Variant  )
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		Call l.logAction( severity, msg, link )	
		lastSeverity = severity
		lastMsg = msg
		If highSeverity = 0 Then
			highSeverity = severity
			highMsg = msg
		Elseif highSeverity >= severity Then
			highSeverity = severity
			highMsg = msg
		End If
	End Function
	
	
	Function getSeverity() As Integer
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		getSeverity = highSeverity
	End Function
	
	%REM
		Function startTimer
		Starts a named timer
	%END REM
	Function startTimer( timername As String )
		' Const LSI_THREAD_TICKS=6
		' Const LSI_THREAD_TICKS_PER_SEC=7
		Dim s As String
		s = LCase( timername )
		timers( s ) = GetThreadInfo( 6 )
	End Function
	
	%REM
		Function getTimer
		Returns the elapsed time in ms
	%END REM
	Function getTimer( timername As String ) As Long
		Dim s As String
		s = LCase( timername )
		If IsElement( timers( s )) Then
			getTimer = (GetThreadInfo( 6 ) - timers( s ))*1000 / GetThreadInfo( 7 )
		End If
	End Function
	
	%REM
		Function getTimers
		Description: Returns a list of all the active timer names
	%END REM
	Function getTimers() As Variant
		Dim a As Array
		ForAll entry In timers
			Call a.add( ListTag( entry ))
		End ForAll
		getTimers = a.elements
	End Function
	
	Function getMsg() As String
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		getMsg = highMsg
	End Function
	
	Public Function isError() As Boolean
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		If highSeverity >= LOG_FATAL And highSeverity < LOG_NORMAL Then 
			isError = True
		Else
			isError = False
		End If
	End Function
	
	Public Function close()
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		If Isobject( l ) Then Call l.close()
	End Function
End Class


%REM
AbstractObject is the root of the class hierarchy. Every class has AbstractObject as a superclass. All objects, implement the methods of this class. 
Include basic functionality as error reporting as logging
%END REM

'# ABSTRACT OBJECT ###################################################################################
Public Class AbstractObject
'####################################################################################	
	Private messageStack As variant 'stacked messages
	Private session As NotesSession
	
	Sub new( )
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		Set session = New NotesSession
	End Sub 'new
	
	
'********** MESSAGES
'Used internally by methods to report events to the caller

	
%REM
Returns the latest message string
%END REM
	Public Function getMessage() As String
		If IsArray( messageStack ) Then
			getMessage = messageStack( UBound( messageStack ))
		End If
	End Function
	
	%REM
		Function getMessages
		Returns all messages
	%END REM
	Public Function getMessages() As Variant
		If IsArray( messageStack ) Then
			getMessages = messageStack
		Else
			messageStack = Split( "", "#" ) 'return an array with one empty element
		End If
	End Function
	
	%REM
		Function pushMessage
		Append a message to the messageStack 
	%END REM
	Private Function pushMessage( message As String )
		If IsArray( messageStack ) Then
			ReDim Preserve messageStack( UBound( messageStack )+1 )
			messageStack( UBound( messageStack )) = message
		Else
			ReDim messageStack( 0 )
			messageStack( 0 ) = message
		End If
	End Function
	
	%REM
	Clear the stack and set one message
	%END REM
	Private Function setMessage( message As String )
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		Call Me.logAction( LOG_DEBUG, message, Nothing )
		messageStack = ""
		pushMessage( message )
	End Function
	
'********** LOG / ERROR REPORTING
	Public Function logAction( severity As Integer, msg As String, link As Variant )
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		Call SystemLog.logAction( severity, msg, link )
	End Function
	
	%REM
	Public Function getInfo() As String
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		getInfo = Typename( Me ) & " version: " &  getVersion()
	End Function
	
	Public Function getVersion() As String
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		getVersion = VERSION
	End Function
	

	Public Function throw( errNumber As Long, errorMsg As String )
	'---------------------------------------------------------------------------------------------------------------------------------------------------
		Call Me.logAction( LOG_FATAL, errorMsg & "[" & Typename( Me ) & "/" & Getthreadinfo( 10 ) & "/" & Getthreadinfo( 11 ) & "]", Nothing )
		'Error errNumber, errorMsg
	End Function
	%ENDREM
	
End Class 


'# ABSTRACT LOG ###################################################################################
Public Class AbstractLog As AbstractObject
'####################################################################################	
	Private isOpen As Boolean
	
	Private severity As Integer '1 Fatal, ..., 5 Normal, ... , 7 Debug
	Private mode As String 'ON, OFF, OPTIONAL
	Private console As Boolean 'true - print logs to console
	Private ui As Boolean 'true - print logs to status bar
	
	Sub new()
		isOpen = True
		
		Dim db As NotesDatabase
		Dim profile As NotesDocument
		
		Set db = session.currentDatabase
		Set profile = db.GetProfileDocument( "Setup" )
		
		If profile.logSeverity( 0 ) = "" Then
			Me.severity = LOG_NORMAL
		Else
			Me.severity = Cint( profile.logSeverity( 0 ))
		End If
		
		If profile.logMode( 0 ) = "" Then
			Me.mode = "ON"
		Else
			Me.mode = profile.logMode( 0 )
		End If
		
		console = (profile.logConsole( 0 ) = "1")
		ui = (profile.logUI( 0 ) = "1")
	End Sub
	
	
	
%REM
Severity: the messages severity (eg. warning or fatal error)
Msg: the message to write in the log
link: inserts a notes document link if available
%END REM
	Public Function logAction( severity As Integer, msg As String, link As Variant )
		On Error GoTo eh
		If mode = "OFF" Then Exit Function
		
		If severity <= Me.severity Then
			If session.currentAgent Is Nothing Then
				If ui Then Print severity & " - " & msg				
			Else 'running from an agent
				If console Then Print  severity & " - " & msg				
				Dim l As New NotesLog( session.currentDatabase.title )
				Call l.OpenAgentLog()
				Call l.LogAction( msg )
				Call l.Close()
			End If
			
		End If
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	Public Function close()
		isOpen = False
	End Function
	
	Public Function setSeverity( severity As Integer )
		Me.severity = severity
	End Function
End Class
%REM
	Class CacheManagerObject
	Description: Comments for Class
%END REM
Public Class CacheManagerObject As AbstractObject
	private cache List As Variant
	%REM
		Sub New
		Description: Comments for Sub
	%END REM
	Sub New()
		
	End Sub
	
	%REM
		Function hasElement
		Description: Comments for Function
	%END REM
	Public Function hasElement( id As String ) As Boolean
		On Error GoTo eh
		hasElement = IsElement( cache( LCase( id )))
				
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function getObject
		Description: Comments for Function
	%END REM
	Public Function getObject( id As string ) As Variant
	On Error GoTo eh
		id = LCase( id )
		If IsElement( cache( id )) Then
			Set getObject = cache( id )
		Else
			Set getObject = nothing 
		End If
				
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function getValue
		Description: Comments for Function
	%END REM
	Public Function getValue( id As String ) As Variant
		On Error GoTo eh
		id = LCase( id )
		If IsElement( cache( id )) Then
			getValue = cache( id )
		Else
			getValue = null 
		End If
				
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	Function getCurrentLocation() As NotesDocument 
		On Error GoTo eh 
		Dim noteid As String 
		noteid = StrToken( session.Getenvironmentstring("location", True), ",", 2 ) 
		
		Set getCurrentLocation = getDocumentById( "!!names.nsf", noteid ) 
		
done: 
		Exit Function 
eh: 
		Error Err, getErrorInfo( Me ) 
	End Function

	
	
	Private NumberOfDocumentsInCache As long
	
	%REM
		Function push
		Description: push a object to the cache (and just return the object isself)
	%END REM
	Public Function pushObject( id As String, obj As Variant ) As Variant
		On Error GoTo eh
		If TypeName( obj ) = "NOTESDOCUMENT" Then
			If NumberOfDocumentsInCache < 100 then
				NumberOfDocumentsInCache = NumberOfDocumentsInCache+1
				Set cache( LCase( id )) = obj
			End if
		else
			Set cache( LCase( id )) = obj
		End if
		Set pushObject = obj
				
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function pushValue
		Description: Comments for Function
	%END REM
	Public Function pushValue( id As String, value As Variant ) As Variant
		On Error GoTo eh
		cache( LCase( id )) = value
		pushValue = value
				
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM 
		Function clear 
		Clears the cache 
	%END REM 
	Public Function clear() 
		Erase cache 
	End Function
	
	%REM
		convert the input to a servername:
		*: current server
		HOME: the home server (from the users location document)
		MAIL: the current mail server (or "" if using local mail or no mail) 
	%END REM
	Private Function getServer( server As String ) As String 
		Dim v As Variant
		Select Case LCase(Trim(server))
			Case "*":
				getServer = session.Currentdatabase.Server
			Case "home":
				v = Evaluate( |@LocationGetInfo( [Homeserver] )| )
				getServer = v( 0 )
			Case "mail":
				v = Evaluate( |@subset(@maildbname;1)| )
				getServer = v( 0 )
			Case Else:
				getServer = server
		End Select
	End Function
	
	
	%REM
	dbId is a text reference to a database. The getDatabase function returns a NotesDatabase object if the database is found and can be opened - otherwise returns nothing.
	dbId syntax: <ul>
	<li>server!!filepath (use a * for the current server, or home/mail for the home server or the mail server)
	<li>server::replicaid (server can be a server name or *, home, mail)
	<li>dbConfig alias - more info in the cls.fw documentation
	</li>
	@see cls.fw_dbConfig
	%END REM
	Public Function getDatabase( dbId As variant ) As NotesDatabase
		On Error GoTo eh
		Dim db As NotesDatabase
		Dim server As String
		
		Dim id As String
		Select case TypeName( dbId )
			Case "NOTESDATABASE"
				'We allready have a database object - just cache it
				id = LCase( dbId.Replicaid)
				If Not hasElement( id ) Then Call pushObject( id, db )
				Set getDatabase = dbId
				
			Case Else
				id = LCase( dbId )
				
				If hasElement( id ) Then 'use the cache
					Set getDatabase = getObject( id )
				Else
					If id = "*" Then
						Set getDatabase = pushObject( id, session.Currentdatabase )
						
					ElseIf InStr( id, "!!" ) > 0 Then
						'server+filepath
						server = StrLeft( id, "!!" )
						server = getServer( server )
						
						On Error Resume next
						Set db = session.Getdatabase(server, StrRight( id, "!!" ))
						On Error GoTo eh
						
						If Not db Is Nothing then
							If Not db.Isopen Then Set db = Nothing
						End if
						Set getDatabase = pushObject( id, db )
					ElseIf InStr( id, "::" ) > 0 Then
						'replicaid
						server = StrLeft( id, "::" )
						server = getServer( server )
						
						Set db = New NotesDatabase( "", "" )
						On Error Resume Next 'don't fail on invalid id's
						Call db.Openbyreplicaid(Server, Replace( StrRight( id, "::" ), ":", "" ))
						On Error GoTo eh
						
						If Not db Is Nothing then
							If Not db.Isopen Then Set db = Nothing
						End If
						
						Set getDatabase = pushObject( id, db )	
					Else
						Dim script As String
						script = |
use "cls.fw"
sub initialize()
	const id="%1"
	dim config as new DbConfig()
	dim db as notesDatabase
	set db = config.getDatabase( id )
	call CacheManager.pushObject( id, db )
end sub
|
					script = parseParam( script, id )
					Dim v As Variant
					v = Execute( script )
					Set getDatabase = getObject( id )
				End If
			End If 
		End Select
		
done:
		Exit function
eh:
		Error Err, getErrorInfo( Me )
	End Function

	%REM
	Function getView
	Description: Comments for Function
	%END REM
	Public Function getView( dbId As variant, viewId As variant ) As NotesView
		On Error GoTo eh
		Dim id As String
		Dim db As NotesDatabase
		Dim view As NotesView
		
		Set db = getDatabase( dbId )
		If db Is Nothing Then Exit Function
		
		Select Case TypeName( viewId )
			Case "NOTESVIEW"
				id = LCase( db.replicaId & "." & viewId.name )
				If Not hasElement( id ) Then Call pushObject( id, viewId )
				Set view = viewId
				
			Case Else
				'get the view
				id = LCase( db.Replicaid & "." & viewId )
				If hasElement( id ) Then
					Set view = getObject( id )
				Else
					Set view = db.getView( viewId )
					
					Call pushObject( id, view )
				End If
		End Select
		
		If Not view Is Nothing Then view.Autoupdate = False 'performance option
		Set getView = view
				
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function

	%REM
	Function getAllDocuments
	Description: Comments for Function
	options: 
		-1= Dont trim
		0 = trim collection (remove deleted and invalids)
		1 = trim colleciton - also remove conflicts
	
	%END REM
	Public Function getAllDocuments( dbId As Variant, viewId As Variant, key As String, options As integer ) As NotesDocumentCollection
		On Error GoTo eh
		Dim coll As NotesDocumentCollection
		Dim id As String
		
		Dim db As NotesDatabase
		Set db = getDatabase( dbId )
		If db Is Nothing Then Exit Function
		
		Dim view As NotesView
		Set view = getView( db, viewId )
		If view Is Nothing Then Exit Function
		
		id = LCase( view.Universalid & "." & key )
		
		If hasElement( id ) Then 
			Set getAllDocuments = getObject( id )
		Else
			
			Set coll = view.GetAlldocumentsbykey( key, True )
			
			If options >= 0 then
				Call trimCollection( coll, options )
			End if
			
			Set getAllDocuments = pushObject( id, coll )
		End If
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	
	
	%REM
		Function searchDatabase
		Description: Comments for Function
		options: 
		-1= Dont trim
		0 = trim collection (remove deleted and invalids)
		1 = trim colleciton - also remove conflicts
	%END REM

	Public Function searchDatabase( dbId As Variant, query As String, options As Integer ) As NotesDocumentCollection
		On Error GoTo eh
		Dim coll As NotesDocumentCollection
		Dim id As String
		
		id = LCase( query )
		If id = "" Then exit function
		
		If hasElement( id ) Then 
			Set searchDatabase = getObject( id )
		Else
			Dim db As NotesDatabase
			Set db = getDatabase( dbId )
			If db Is Nothing Then Exit Function
			
			Set coll = db.search( query, Nothing, 0 )
			
			If options >= 0 Then
				Call trimCollection( coll, options )
			End If
			
			Set searchDatabase = pushObject( id, coll )
		End If
				
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function getDocumentById
		Description: Comments for Function
	%END REM
	Public Function getDocumentById( dbId As Variant, docId As String ) As NotesDocument
		On Error GoTo eh
		Dim doc As NotesDocument
		Dim id As String
		
		id = LCase( docId )
		
		If hasElement( id ) Then 
			Set getDocumentById = getObject( id )
		Else
			Dim db As NotesDatabase
			Set db = getDatabase( dbId )
			If db Is Nothing Then Exit Function
			
			On Error Resume Next 'don't fail on invalid ids
			If Len( id ) < 32 Then
				'note id
				Set doc = db.getDocumentById( id )
			Else
				'universal id
				Set doc = db.Getdocumentbyunid( id )	
			End If
			
			Set getDocumentById = pushObject( id, doc )
		End If
				
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function

	%REM
	Function getDocument
	Description: Comments for Function
	%END REM
	Public Function getDocument( dbId As variant, viewId As variant, key As String ) As NotesDocument
		On Error GoTo eh
		Dim doc As NotesDocument
		Dim id As String
		
		Dim db As notesDatabase
		Set db = getDatabase( dbId )
		If db Is Nothing Then Exit Function
		
		Dim view As NotesView
		Set view = getView( db, viewId )
		If view Is Nothing Then Exit Function
		
		id = LCase( db.replicaid & "." & view.Universalid & "." & key )
		
		If hasElement( id ) Then 
			Set getDocument = getObject( id )
		Else
			Set doc = view.Getdocumentbykey( key, True )
			
			Set getDocument = pushObject( id, doc )
		End If
				
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function

End Class
%REM
	Class AbstractArray
	Description: Comments for Class
%END REM
Public Class AbstractArray As AbstractObject
	Private values As Variant
	Private cnt As Long 'number of entries

	Sub New( source As Variant )
		Call setValue( source )
	End Sub
	
	Public Property Get elements As Variant
		elements = values		
	End Property
	
	Public Property Get count As Long
		count = cnt
	End Property
	
	%REM
		Property Get toString
		Description: Comments for Property Get
	%END REM
	Public property Get toString As String
		If cnt > 0 Then
			Dim s As string
			Dim i As Integer
			For i = 0 To cnt-1
				s = s & values( i )
				If i <> cnt-1 Then s = s & ", "
			Next	
			toString = s
		Else
			toString = ""
		End If
	End Property
	
	Public Function setValue( source As Variant ) As Variant
		On Error GoTo eh
		If Not IsNull( source ) Then
			If IsArray( source ) Then
				values = source
				cnt = UBound( source )+1
			Else
				Call add( source )
			End If
		End If
		
		me.setValue = elements
			
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( me )
	End Function
	
	Public Function add( source As variant ) As Variant
		On Error GoTo eh
		If cnt = 0 Then
			If IsArray( source ) then
				me.values = source
			Else
				ReDim values( 0 ) 
				values( 0 ) = source
			End if
		Else
			values = ArrayAppend( values, source )
		End if
		
		
		cnt = UBound( values )+1
		me.add = elements()
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	Public Function Trim() As Variant
	On Error GoTo eh
		If cnt > 0 then
			values = FullTrim( values )
			me.trim = elements()
		Else
			me.trim = ""
		End If
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End function
	
	Public Function unique() As Variant
		On Error GoTo eh
		If cnt > 0 then
			values = arrayunique( values )
			me.unique = elements()
		Else
			me.unique = ""
		End If
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function

	
	
	
End Class



Public Class AbstractCollection As AbstractObject
	Private values As Variant
	Private cnt As Long 'number of entries

	Sub New
		ReDim values( 0 )
	End Sub
	
	Public Property Get elements As Variant
		elements = values		
	End Property
	
	Public Property Get count As Long
		count = cnt
	End Property


	Public Function add( source As Variant )
		ReDim Preserve values( cnt )
		Set values( cnt ) = source
		cnt = cnt+1
	End Function
End Class

Public Class Array As AbstractArray
	Private compMethod As Long
	
	Sub New( source As Variant )
		compMethod = 5	
	End Sub
	
	Public Function sort() As Variant
		On Error GoTo eh
		If cnt > 0 Then
			sort = QuickSort( elements())
		Else
			me.sort = ""
		End If
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	Public Function replace( compareArray As Variant, replaceArray As Variant) As Variant
	On Error GoTo eh
		values = ArrayReplace( values, compareArray, replaceArray )
		me.replace = elements()
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	Public Function word( seperator As String, index As Long ) As Variant
		On Error GoTo eh
		Dim result As New Array( Null )
		Dim s As String
		
		ForAll entry In values
			s = StrToken( entry, seperator, index, compMethod )
			Call result.add( s )
		End ForAll
		
		word = result.elements()
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	Public Function search( s As String ) As Long
		On Error GoTo eh
		Dim v As Variant
		v = ArrayGetIndex( values, s, compMethod )
		If IsNull( v ) Then
			search = -1
		Else
			search = v
		End If
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	Public Function getIndex( s As String ) As Long
		On Error GoTo eh		
		getIndex = search( s )
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	Public Function filter( filterStr As String ) As Variant
		On Error GoTo eh
		ForAll entry In values
			If Not entry Like filterStr Then
				Call Me.remove( CStr( entry ))
			End If
		End ForAll
		
		filter = elements
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function

	%REM
Used to change the compare method (used when comparing 2 strings)

Input - compMethod
0 	Case Sensitive, Pitch sensitive [Default]
1 	Case Insensitive, Pitch sensitive
4 	Case Sensitive, Pitch insensitive
5 	Case Insensitive, Pitch insensitive
Use 2 to specify string comparison in the platform's collation sequence. If 2 is specified, strings are compared bit-wise. If you omit compMethod, the default comparison mode is the mode set by the Option Compare statement for this module. If there is no statement for the module, the default is case-sensitive and pitch-sensitive.
	%END REM
	Public Function setCompMethod( compMethod As Long )
		'----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------			
		Me.compMethod = compMethod
	End Function 'setCompMethod
	
	Public Function Remove( l As Variant ) As Variant
	On Error GoTo eh
		If IsArray( l ) Then
			ForAll entry In l
				Call Me.remove( entry )
			End ForAll
		Else
			Dim a As New Array( Null ) 
			ForAll entry In values 
				If StrCompare( entry, l, compMethod ) <> 0 Then 
					Call a.add( CStr( entry )) 
				End If 
			End ForAll 
			values = a.elements 
			If IsArray( values ) Then
				Me.cnt = UBound( values )+1 
			Else
				me.cnt = 0 
			End If
		End If
		
		Me.remove = elements() 
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	Public Function hasElement( s As variant ) As Boolean
		On Error GoTo eh
		If count = 0 Then hasElement = False : Exit Function 
		
		If IsNull( ArrayGetIndex( values, s, compMethod )) Then
			hasElement = False
		Else 
			hasElement = True
		End If
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function getElementAt
		Description: Comments for Function
	%END REM
	Public Function getElementAt( idx As Long ) As String
		On Error GoTo eh
	
		If idx >= LBound( values ) And idx <= UBound( values ) Then
			getElementAt = values( idx )
		Else
			getElementAt = ""
		End If
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function'
	
	Public Function setElementAt( idx As Long, value As variant )
		On Error GoTo eh
		If idx >= LBound( values ) And idx <= UBound( values ) Then
			values( idx ) = value
		End If
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function

	
	Public Function Implode( seperator As String ) As String
	On Error GoTo eh
		Me.implode = Join( values, seperator )
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
	Private Sub DoQS( sA() As String, bottom As Long, top As Long )
		On Error GoTo eh
		' Called by QuickSort
		' Uses Public variable sA  (array of string)
		Dim length As Long
		Dim i As Long
		Dim j As Long
		Dim Pivot As Long
		Dim PivotValue As String
		Dim t As String
		Dim LastSmall As Long
		length = top - bottom + 1
		
		' Only do the QuickSort if the sublist is at least 10 items long
		If length > 10 Then
			' Pivot is chosen approx. halfway through sublist.
			' This gives us best speed if list is almost sorted already, and is no worse than any
			' other choice if the list is in random order.
			Pivot = bottom + (length \ 2)   
			
			' Move PivotValue out of the way
			PivotValue = sA( Pivot )
			sA ( Pivot ) = sA ( bottom )
			sA ( bottom ) = PivotValue
			
			' LastSmall is the location of the last value smaller than PivotValue
			LastSmall = bottom
			For i = bottom + 1 To top 
				If sA ( i ) < PivotValue Then 
					LastSmall = LastSmall + 1
					t = sA ( i )
					sA ( i ) = sA ( LastSmall )
					sA ( LastSmall ) = t
				End If
			Next
			
			' Move the PivotValue back
			t = sA ( LastSmall )
			sA ( LastSmall ) = sA ( bottom )
			sA ( bottom ) = t
			Pivot = LastSmall
			
			' Now sort each side
			Call DoQS ( sA, bottom, Pivot - 1 )
			Call DoQS ( sA, Pivot + 1, top )
		End If
					
done:
	Exit sub
eh: 
	Error Err, getErrorInfo( Me )
	End Sub
	
	Private Sub DoInsertSort ( sA() As String, ByVal bottom As Long, ByVal top As Long )
		On Error GoTo eh	
		Dim i As Long
		Dim x As Long
		Dim v As String
		Dim Found As Integer
		For i = bottom+1 To top
			x = i
			v = sA (i )
			Do While (sA(x-1) > v)
				sA ( x ) = sA ( x-1 )
				x = x - 1
				If x=0 Then
					Exit Do
				End If
			Loop
			sA (x) = v
		Next
					
done:
	Exit sub
eh: 
	Error Err, getErrorInfo( Me )
	End Sub
	
	Public Function QuickSort( sArray As Variant ) As Variant
		On Error GoTo eh
		Dim sA() As String    
		Dim j As Long
		Dim bottom As Long
		Dim top As Long
		Dim vA As Variant
		'Dim sArray As Variant
		
		'sArray = values 'use internal array
		
		bottom = LBound ( sArray )
		top = UBound ( sArray )
		ReDim sA( bottom To top ) As String     
		For j = bottom To top
			sA ( j ) = sArray ( j )
		Next
		' DoQS does a QuickSort if the Sublist is longer than 10 elements
		' Thus, when DoQS finishes, all elements are within 10 spots of their correct location.
		' For lists that are close to being in order, an Insertion Sort is much faster than a QuickSort, so we
		' run through the whole thing once doing an Insertion Sort to finish tidying up the order.
		Call DoQS( sA, bottom, top )
		Call DoInsertSort ( sA, bottom, top )
		ReDim vA(bottom To top) As Variant
		For j = bottom To top
			vA ( j ) = sA ( j )
		Next	
		
		'done
		values = vA
		QuickSort = vA
					
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( Me )
	End Function
	
End Class
%REM @DOC #RTFormatMail Sample: How to create a formatted mail

<lotusscript>
	'Create a new mail document
	Set mail = db.createDocument
	mail.form = "Memo"
	mail.subject = "Sample mail created with the AbstractRichText class"


	'Fill in some nicely formatted richtext in the body field
	Dim body As New AbstractRichText( mail, "body" ) 'create a new body field on the mail
	Call body.append( "Hi, \n\nDatabase link: " ) 'notice, you can use \n to insert newlines in the text - or \t to insert tabs
	Call body.append( db ) 'the append method supports a lot of datatypes
	Call body.append( body.getStyle( "bold=true;color=GRAY" )) 'with the getStyle you can easily create a NotesRichTextStyle
	Call body.append( "\n\n\nBest regards\n\n" )
	Call body.append( body.getStyle( "bold=false;" ))
	Call body.append( session.commonUsername )
	Call body.update() 'update before showing in UI


	'open the mail in UI
	Dim ws As New NotesUIWorkspace
	Call ws.Editdocument(True, mail )
</lotusscript>
%END REM

%REM @DOC #RTViewTable Sample: Copy View as table
With the AbstractRichText.appendTable you can mimic the @Command([CopySelectedAsTable]) function in Lotus Script - thus giving you the possibiblity to extend the function adding custom columns.
 

<lotusscript>
	'Create a new mail document
	Set mail = db.createDocument
	mail.form = "Memo"
	mail.subject = "Sample mail with the current view inserted as a table"
	Dim body As New AbstractRichText( mail, "body" ) 'create a new body field on the mail

	'get the collection (the table content)
	Dim coll As NotesDocumentCollection
	Set coll = db.Unprocesseddocuments 'use all the selected document

	'define the table colums
	Dim columns As Variant
	columns = body.getViewColumns(ws.currentView.View) 'get the columns from the current view	
	columns = ArrayAppend( columns, "header=Author;formula=@subset(@author<semi>1);width=10;" ) 'adding a custom column

	'Create the table
	Call body.appendTable(Coll, Columns, nothing) 'no options specified
	
	'open the mail in UI
	Call ws.Editdocument(True, mail )
</lotusscript>
Notice how the custom column is added. Each column is defined as a text string with 3 parameters:
<ul>
	<li>header=;
	<li>formula=;
	<li>width=;
</ul>
If your formula needs a semikolon, used the encoded format: <semi> instead as defined in the AbstractParams class

@see cls.system_AbstractParams
%END REM

%REM
The AbstractRichText class is use to manipulate the content of a rich text field

@See doc.RTFormatMail
@See doc.RTViewTable
%END REM
Public Class AbstractRichText As AbstractObject
	Private db As NotesDatabase
	Private doc As NotesDocument
	Private rtf As NotesRichTextItem
	
	%REM
	<u>Params</u>
	<ul>
	<li><b>doc</b> The NotesDocument that holds the richtext item (the source document)
	<li><b>item</b> Name of the richtext item (string). If the item doesn't exist it will be created. You can also provide NotesRichTextItem reference
	</ul>
	
	@See doc.RTFormatMail
	@See doc.RTViewTable
	%END REM
	Sub New( doc As NotesDocument, item As variant )
		Set me.doc = doc
		If doc Is Nothing Then Exit Sub
		
		Set me.db = doc.Parentdatabase
		
		Select Case TypeName( item )
			Case "NOTESRICHTEXTITEM":
				Set rtf = item
			Case "STRING":
				Set rtf = doc.Getfirstitem(item)
				If rtf Is Nothing Then
					Set rtf = doc.Createrichtextitem(item)
				End If
		End Select
		
	End Sub
	
	%REM
		Function update
		Call this before opening the document in UI (
		See the NotesRichTextItem.Update() method in the Notes Designer help for more information

		@See doc.RTFormatMail
		@See doc.RTViewTable
	%END REM
	Public Function update()
		Call rtf.Compact()
		Call rtf.Update()
	End Function
	
	%REM
		Returns the NotesRichtextItem object
		Usefull if you need to manipulate the RichText field further
	%END REM
	Public Function getItem As NotesRichTextItem
		Set getItem = rtf
	End Function
	
	%REM
		Make a search and replace operation in a RichText field
		
		<u>Parameters</u><ul>
		<li>searchFor: string to search for
		<li>replaceWith: data to replace with (String, NotesRichtextItem, NotesDocument, NotesDatabase or NotesView)
		<li>allOccurrences: true to replace all, false to replace first
		</ul>
		
		<u>Return value</u>
		returns true if the tag is found and a replace took place
		
		The sample script will replace the {date} tag in the Richtext field, with todays date
		<lotusscript>
		Dim body As New AbstractRichText( doc, "body" )
		call body.searchAndReplace( "{date}", Today, True )
		</lotusscript>
	%END REM
	Public Function searchAndReplace( searchFor As String, replaceWith As Variant, allOccurrences As Boolean ) As Boolean
		On Error GoTo eh
		searchAndReplace = false
		If doc Is Nothing Then Exit Function
		If rtf Is Nothing Then Exit Function
		
		'inspired by http://www.breakingpar.com/bkp/home.nsf/0/87256B280015193F87256FAC005B6DAE
		Dim range As NotesRichTextRange
		Dim nav As NotesRichTextNavigator
		
		Call rtf.Update
		
		Set range = rtf.CreateRange 
		Set nav = rtf.CreateNavigator 
		
		Do While nav.FindFirstString(searchFor) 'find the string
			searchAndReplace = True

			'set the range
			Call range.SetBegin(nav) 
			Call range.SetEnd(nav)
			
			'clear the area (remove the tag)
			Call range.Remove 
			
			
			If TypeName( replaceWith ) = "NOTESRICHTEXTITEM" Then
				'You need the C api to insert RichText, http://www.eknori.de/2006-10-14/insert-richtext-into-richtext-with-lotusscript-chapter-2/
				'Notes can't insert richtext into a NotesRichTextItem - so, we will just append
				Call me.append( "\n" )
				Call me.append( replaceWith )
			else
				Call rtf.BeginInsert(nav, false)

				'insert new data 
				If IsArray( replaceWith ) Then
					ForAll entry In replaceWith
						Call me.append( entry )

						If UBound( replaceWith ) - LBound( replaceWith ) > 0 Then
							'multiple lines - add new line
							Call me.append( "\n" )
						End If

					End ForAll
				else
					Call me.append( replaceWith )
				End If
				
				Call rtf.EndInsert 
			End If
			
			
			'update
			Call rtf.Compact 
			Call rtf.Update 
			
			'continue?
			If allOccurrences Then
				'Set range = rtf.CreateRange 
				'Set nav = rtf.CreateNavigator
				'for some reason the loop thing doesn't work - do insteand we jost the this method again
				Call searchAndReplace( searchFor, replaceWith, true )
				Exit Do 
			Else
				Exit do
			End if
		loop 
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	%REM
		Function appendCell
		Description: Comments for Function
	%END REM
	Private Function appendCell( rtnav As NotesRichTextNavigator, source As Variant )
		On Error GoTo eh
		
		Call rtf.BeginInsert(rtnav)
		Call me.append( source )
		Call rtf.EndInsert()
		Call rtnav.FindNextElement(RTELEM_TYPE_TABLECELL)
			
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	

	%REM 
        Used with the appendTable function to create a table that looks like the specified view 
        
        Returns a string array where each entry represents a column. See the appendTable method for more info.
        
		@See doc.RTViewTable
		@see cls.system_AbstractParams
		@see cls.system_AbstractRichText_AppendTable
	%END REM 
	Public Function getViewColumns( view As NotesView ) As Variant 
		On Error GoTo eh
		Dim result() As AbstractParams 
		Dim columnCount As Integer
		ReDim result( 0 )
		
		Dim p As AbstractParams 
		
		Const CATEGORIZED_COLUMN_WIDTH = "10"
		Const VIEW2TABLE_WIDTHFACTOR = 0.5 'view column width i s messured in chars -the table is mesured in centimeters
		Const TABLE_WIDTH = 30 'total width of the table

		Dim w As String
		Dim currentWidth As Integer
		
		'scan all the columns
		Dim formula As String
		Dim c As NotesViewColumn 
		ForAll column In view.Columns 
			Set c = column 
			
			If c.Isconstant Then GoTo nextcol 
			If c.Ishidden Then GoTo nextcol 
			If c.Isicon Then GoTo nextcol 
			If c.Isresponse Then GoTo nextcol
			
			If c.Isformula Then
				formula = c.Formula
			ElseIf c.isField Then
				formula = c.Itemname
			Else
				GoTo nextcol
			End If
			
			If c.Iscategory Then
				w = CATEGORIZED_COLUMN_WIDTH
			Else
				w = CStr( CInt( c.Width * VIEW2TABLE_WIDTHFACTOR ))
			End If
			
			'add the column
			Set p = New AbstractParams( "" )
			Call p.setParam( "header", c.title ) 
			Call p.setParam( "formula", formula ) 
			Call p.setParam( "width", w ) 
			currentWidth = currentWidth + CInt( w )
			
			ReDim Preserve result( columnCount )
			Set result( columnCount ) = p
			columnCount = columnCount + 1 
			
			
nextcol: 
		End ForAll 
		
		'resize to match the table width
		Dim resizeFactor As Double
		resizeFactor = TABLE_WIDTH / currentWidth
		Dim newWidth As String
		
		'return
		Dim a As New array( Null )
		ForAll param In result
			If resizeFactor < 1 Then 'don't expand - only downsize to fit window
				newWidth = CStr( CInt( CInt( param.getParam("width")) * resizeFactor ))
				Call param.setParam("width", newWidth)
			End If
			Call a.add( param.toString )
		End ForAll
		getViewColumns = a.elements 
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	

	
	%REM
		Returns a NotesRichTextStyle - can be used with the append methods
		Params string:
			bold=true/false
			italic=true/false
			underline=true/false
			size=1-250
			color=0-15 (or const name)
				0.00	BLACK
				1.00	WHITE
				2.00	RED
				3.00	GREEN
				4.00	BLUE
				5.00	MAGENTA
				6.00	YELLOW
				7.00	CYAN
				8.00	DARK_RED
				9.00	DARK_GREEN
				10.00	DARK_BLUE
				11.00	DARK_MAGENTA
				12.00	DARK_YELLOW
				13.00	DARK_CYAN
				14.00	GRAY
				15.00	LIGHT_GRAY
				
		<lotusscript>
		dim body as new AbstractRichText( doc, "body" )
		Dim style As NotesRichTextStyle
		set style = body.getStyle( "bold=true;color=gray;" ) 
		call body.append( style )
		</lotusscript>
	%END REM
	Public Function getStyle( params As String ) As NotesRichTextStyle
		On Error GoTo eh
		Dim style As NotesRichTextStyle
		Set style = session.Createrichtextstyle()
		
		Dim p As New AbstractParams( params )
		ForAll entry In p.getAll()
			Select Case entry
			Case "bold":
				style.Bold = ( LCase( p.getParam( CStr( entry ))) = "true" )
			Case "italic":
				style.Italic = ( LCase( p.getParam( CStr( entry ))) = "true" )
			Case "underline":
				style.Underline = ( LCase( p.getParam( CStr( entry ))) = "true" )
			Case "size":
				style.Fontsize = CInt( p.getParam( CStr( entry )))
			Case "color":
					Select Case UCase( p.getParam( CStr( entry )))
					Case "BLACK": style.Notescolor = COLOR_BLACK
					Case "WHITE": style.Notescolor = COLOR_WHITE
					Case "RED": style.Notescolor = COLOR_RED
					Case "GREEN": style.Notescolor = COLOR_GREEN
					Case "BLUE": style.Notescolor = COLOR_BLUE
					Case "MAGENTA": style.Notescolor = COLOR_MAGENTA
					Case "YELLOW": style.Notescolor = COLOR_YELLOW
					Case "CYAN": style.Notescolor = COLOR_CYAN
					Case "DARK_RED": style.Notescolor = COLOR_DARK_RED
					Case "DARK_GREEN": style.Notescolor = COLOR_DARK_GREEN
					Case "DARK_BLUE": style.Notescolor = COLOR_DARK_BLUE
					Case "DARK_MAGENTA": style.Notescolor = COLOR_DARK_MAGENTA
					Case "DARK_YELLOW": style.Notescolor = COLOR_DARK_YELLOW
					Case "DARK_CYAN": style.Notescolor = COLOR_DARK_CYAN
					Case "GRAY": style.Notescolor = COLOR_GRAY
					Case "LIGHT_GRAY": style.Notescolor = COLOR_LIGHT_GRAY
					Case Else
						style.Notescolor = CInt( p.getParam( CStr( entry )))
					End Select
			End Select
		End ForAll
		
		Set getStyle = style
		
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	
	%REM
		Function appendTable
		Creates a new table, based on the documents in the Coll
		Columns: Array of AbstractParams (or strings): header, formula, width
			header: column title
			formula: @formula - evaluates to the content
			width: column width in centimeters
		Options: optional, not implemented yet
		
		@See doc.RTViewTable
		@see cls.system_AbstractParams
	%END REM
	Public Function appendTable(coll As NotesDocumentCollection, columns As variant, options As AbstractParams )
		On Error GoTo eh
		Dim cols As Integer
		
		If coll Is Nothing Then Exit function
		If coll.count = 0 Then Exit Function
		
		If Not IsArray( columns ) Then Exit function
		cols = UBound( columns )+1 'number of columns in the table
		
		'create the table
		Dim styles() As NotesRichTextParagraphStyle
		ReDim styles( cols )
		'link column
		Set styles( 0 ) = session.Createrichtextparagraphstyle()
		styles( 0 ).Firstlineleftmargin = RULER_ONE_CENTIMETER*(0.1)
		styles( 0 ).Leftmargin = RULER_ONE_CENTIMETER*(0.1)
		styles( 0 ).Rightmargin = RULER_ONE_CENTIMETER*(1)
		Dim i As Integer
		Dim p As AbstractParams
		
		ForAll column In columns
			i = i+1
			If TypeName( column ) ="STRING" then 
				Set p = New AbstractParams( CStr( column ))
			Else
				Set p = column
			End if
			Set styles( i ) = session.Createrichtextparagraphstyle()
			styles( i ).Firstlineleftmargin = RULER_ONE_CENTIMETER*(0.1)
			styles( i ).Leftmargin = RULER_ONE_CENTIMETER*(0.1)
			styles( i ).Rightmargin = RULER_ONE_CENTIMETER*CInt((p.getParam( "width")))
		End ForAll
		Call rtf.Appendtable(coll.count+1, cols+1,,,styles ) 'one extra row=the header, one extra col=links goes here
		
		'header
		Dim c As Integer
		Dim rtnav As NotesRichTextNavigator
		Set rtnav = rtf.CreateNavigator

		Call rtnav.FindLastElement(RTELEM_TYPE_TABLE)
		Call rtnav.FindNextElement(RTELEM_TYPE_TABLECELL)
		
		'link column
		Call appendCell( rtnav, "#" )
		
		ForAll column In columns
			Set p = New AbstractParams( CStr( column ))
			Call appendCell( rtnav, p.getParam( "header" ))
		End ForAll
		'/header
			
		'content
		Dim v As Variant
		Dim formula As string
		Dim source As NotesDocument
		Set source = coll.Getfirstdocument()
		Do Until source Is Nothing 'loop on all documents/rows
			If source.Isdeleted Then GoTo nextdoc
			If Not source.Isvalid Then GoTo nextdoc
			
			'link column
			Call appendCell( rtnav, source )
			
			'loop on all columns
			ForAll column In columns
				Set p = New AbstractParams( CStr( column ))
				formula = p.getParam( "formula" )
				If formula="" Then
					v = ""
				Else
					v = Evaluate( formula, source )
				End If
				
				Call appendCell( rtnav, v )
					
			End ForAll
			'/content
		
nextdoc:
			Set source = coll.Getnextdocument(source)
		Loop
		
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
	
	%REM
		Function appendFile
		Description: Comments for Function
	%END REM
	Public Function appendFile( filename As String )
		On Error GoTo eh
		
		Call rtf.Embedobject(EMBED_ATTACHMENT, "", filename )
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function
			
	%REM
		Append data to the RichText field. You can append almost anything (e.g. a String, NotesDocument, NotesRichtextStyle)
	
		<u>Parameters</u><ul>
		<li>source - data to be appended to the rtf field
		source can be: String, NotesRichtextItem, NotesRichTextParagraphStyle, NotesRichTextStyle, NotesDocument, NotesDatabase or NotesView
		In strings you can include tabs: \t and newlines: \n
		Multivalues will be seperated with newlines
		</ul>
	%END REM
	Public Function append( source As Variant ) 
		On Error GoTo eh
		If doc Is Nothing Then Exit Function
		If rtf Is Nothing Then Exit Function
		
		If IsArray( source ) Then
			If UBound( source ) = 0 Then 'only one entry
				Call me.append( source( 0 ) )				
			else
				ForAll entry In source
					Call me.append( entry )
					Call rtf.Addnewline(1)
				End ForAll
			End if
		else
			Select Case TypeName( source )
				Case "STRING"
					source = Replace( source, "\\", |&slash;|)
					source = Replace( source, "\n", Chr( 10 ))
					source = Replace( source, "\t", Chr( 9 ))
					source = Replace( source, |&slash;|, "\")
					
					Call rtf.AppendText( source )
					
				Case "NOTESRICHTEXTITEM"
					Call rtf.AppendRTItem( source )
					
				Case "NOTESDOCUMENT", "NOTESDATABASE", "NOTESVIEW"
					Call rtf.AppendDocLink( source, getLinkComment( source ))
					
				Case "NOTESDATETIME":
					Call rtf.AppendText( source.lsLocalTime ) 
					
				Case UCase( "NotesRichTextParagraphStyle" ):
					Call rtf.Appendparagraphstyle(source)
					
				Case UCase( "NotesRichTextStyle" ):
					Call rtf.Appendstyle(source)
	
				Case Else
					If IsScalar( source ) Then
						Call rtf.AppendText( CStr( source ))
					End If
			End Select
		End if
done:
		Exit Function
eh:
		Error Err, getErrorInfo( Me )
	End Function		
	
	%REM
		Function insert
		Same as 'append' (just added to keep the same naming as in the AbstractMemo class)

	Public Function insert( source As Variant )
		Call me.append( source )
	End Function
	%END REM
End Class

%REM
	Class Common
	Description: Comments for Class
%END REM
Public Class AbstractParams As AbstractObject
	Private p List As String
	
	Sub New( params As String )
		Dim v As Variant
		Dim value As String
		Dim param As String
		
		v = Split( params, ";" )
		ForAll entry In v
			If entry <> "" Then
				param = Trim( LCase( StrLeft( entry, "=" )))
				value = Trim( StrRight( entry, "=" ))
				p( param ) = decode( value )
			End If
		End ForAll
		
	End Sub
	
	Public Function count As Integer
		Dim c As Integer
		ForAll entry In p
			If entry <> "" Then
				c = c+1
			End If
		End ForAll
		count = c
	End Function
	
	%REM
		Function getList
	%END REM
	Public Function getList() As Variant
		getList = p	
	End Function
	
	
	%REM
		Function hasParam
		Description: Comments for Function
	%END REM
	Public Function hasParam( param As String ) As Boolean
		hasParam = IsElement( p( LCase( param )))
	End Function
	
	Public Function getParam( param As String ) As String
		If hasParam( param ) Then
			getParam = p( LCase( param ))
		Else
			getParam = ""
		End If
	End Function
	
%REM
	Convert a date to a string in a standarized format
%END REM
	Private Function cDate( d As Variant ) As String
		cDate = Format( d, "yyyy-mm-dd hh:nn:ss" )
	End Function
	
	%REM
		Function cToDate
		convert a string to date
	%END REM
	Private Function cToDate( d As String ) As Variant
		Dim v As Variant
		Dim dd As Variant
		Dim dt As Variant
		cToDate = ""
		If d = "" Then Exit Function
		
		v = Split( StrLeft( d, " " ), "-" )
		dd = DateNumber( v(0), v(1), v(2) )
		
		v = Split( StrRight( d, " " ), ":" )
		dt = TimeNumber( v(0), v(1), v(2) )
		
		cToDate = dd+dt
		
	End Function
	
	%REM
		Function setParam
		Description: Comments for Function
	%END REM
	Public Function setParam( param As String, value As String )
		p( LCase( param )) = value
	End Function

	Public Function add( param As String, value As String )
		Call setParam( param, value )
	End Function

	%REM
		Function toString
		Description: Comments for Function
	%END REM
	Public Function toString() As String
		Dim s As String
		ForAll entry In p
			s = s & ListTag( entry ) & "=" & encode( entry ) & ";"
		End ForAll	
		toString = s
	End Function
	
	%REM
		Function encode
		Description: Comments for Function
	%END REM
	Function encode( source As String ) As String
		Dim s As String
		s = source
		s = Replace( s, ";", "<semi>" )
		s = Replace( s, "=", "<equal>" )
		s = Replace( s, Chr( 10 ), "<br>" )
		s = Replace( s, Chr( 13 ), "" )
		s = Replace( s, Chr( 9 ), "<tab>" )
		
		encode = s
	End Function
	
	%REM
		Function decode
		Description: Comments for Function
	%END REM
	Function decode( source As String ) As String
		Dim s As String
		s = source
		s = Replace( s, "<semi>", ";" )
		s = Replace( s, "<equal>", "=" )
		s = Replace( s, "<br>", Chr( 10 ))
		s = Replace( s, "<tab>", Chr( 9 ))
		
		decode = s
		
	End Function
	
	%REM
		Function getAll
		Returns an array with all the parameter names
	%END REM
	Public Function getAll() As Variant
		Dim v As Variant
		Dim c As Integer
		ReDim v( 0 )
		
		ForAll entry In p
			ReDim Preserve v( c )
			v( c ) = ListTag( entry )
			c = c+1
		End ForAll
		getAll = v
	End Function
	
End Class
'++LotusScript Development Environment:2:1:trimCollection:6:8
%REM
Removes invalid entries from a collection (e.g. deleted documents)
options: 
1 - removes conflicts
%END REM
Public Function trimCollection( coll As NotesDocumentCollection, options As Integer ) As NotesDocumentCollection
	On Error GoTo eh
	Dim doc As NotesDocument
	Dim nextDoc As NotesDocument
	
	Set trimCollection = coll
	
	If coll Is Nothing Then Exit Function
	If coll.Count = 0 Then Exit Function
	
	
	Set doc = coll.GetFirstDocument
	Do Until doc Is Nothing
		Set nextDoc = coll.GetNextDocument( doc )
		
		If Not doc.IsValid Then Call coll.DeleteDocument( doc ) : GoTo NEXTDOC
		If doc.IsDeleted Then Call coll.DeleteDocument( doc ) : GoTo NEXTDOC
		If doc.UniversalID = "" Then Call coll.DeleteDocument( doc ) : GoTo NEXTDOC
		If ( options And 1 ) = 1 Then
			If doc.HasItem( "$Conflict" ) Then Call coll.DeleteDocument( doc ) : GoTo NEXTDOC 
		End If
		
NEXTDOC:
		Set doc = nextDoc
	Loop
	
	
	Set trimCollection = coll
	
		
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( "" )
End Function








'++LotusScript Development Environment:2:1:getErrorInfo:31:8
%REM Sample code
Use this in ALL subs/functions/methods

From a method in a class
	Function foo()
		On Error Goto EH
			'<Your code here>
	EH:
		Error Err, getErrorInfo( Me )
	End Function

From a module level sub/function
	Sub foo()
		On Error Goto EH
			'<Your code here>
	EH:
		Error Err, getErrorInfo( "" )
	End Sub

From an agent
	Sub Initialize()
		On Error Goto EH
		Dim session As New NotesSession
			'<Your code here>
	EH:
		Error Err, getErrorInfo( session.CurrentAgent )
	End Sub

%END REM

Public Function getErrorInfo( obj As Variant )
	
	'Getthreadinfo( 2 )/Getthreadinfo( 11 ) only works when running on a server
	'Typename( me ) gives the classname of the initated class - even if the error occurced in another level
	
	Dim session As New NotesSession
	Dim module As String
	If session.IsOnServer Then module = ", module: " & Getthreadinfo( 11 ) 
	
	Dim object As String	
	Select Case Typename( obj )
	Case "STRING":	object = obj
	Case "NOTESAGENT": object = "agent: " & obj.name
	Case Else
		object = "class: " & Typename( obj )
	End Select
	If object <> "" Then object = ", " & object
	
	getErrorInfo = Error & " " & Chr( 10 ) & Getthreadinfo( 10 ) & ", line: " & Erl & object & module
	
%REM Getthreadinfo const
public const LSI_THREAD_LINE=0
public const LSI_THREAD_PROC=1
public const LSI_THREAD_MODULE=2
public const LSI_THREAD_VERSION=3
public const LSI_THREAD_LANGUAGE=4
public const LSI_THREAD_COUNTRY=5
public const LSI_THREAD_TICKS=6
public const LSI_THREAD_TICKS_PER_SEC=7
public const LSI_THREAD_PROCESS_ID=8
public const LSI_THREAD_TASK_ID=9
public const LSI_THREAD_CALLPROC=10
public const LSI_THREAD_CALLMODULE=11
%END REM
End Function






'++LotusScript Development Environment:2:1:cList:4:8
%REM
	Convert any datatype to a Notes multivalue
%END REM
Public Function cList( source As Variant ) As Variant
	On Error GoTo eh
	Dim v( 0 ) As Variant
	
	If Isarray( source ) Then
		cList = source
	Elseif Isobject( source ) Then
		Select Case Typename( source )
		Case "STRINGS":
			v( 0 ) = source.getValue()
			cList = v
		Case "ARRAY"
			cList = source.elements
		End Select
	Else
		v( 0 ) = source
		cList = v
	End If
	
		
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( "" )
End Function




'++LotusScript Development Environment:2:1:CacheManager:5:8
%REM
	Function CacheManager
	Description: Comments for Function
%END REM
Static Public Function CacheManager() As CacheManagerObject
	Static cache As CacheManagerObject
	If cache Is Nothing Then
		Set cache = New CacheManagerObject
	End If
	Set CacheManager = cache
End Function
















'++LotusScript Development Environment:2:1:hasProfile:5:8
%REM
	Function hasProfile
	Description: Comments for Function
%END REM
Public Function hasProfile( db As NotesDatabase, profilename As String ) As Boolean
	On Error GoTo eh
	Dim coll As NotesDocumentCollection
	Set coll = db.GetProfileDocCollection(profilename)
	hasProfile = ( coll.Count > 0 )
		
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( "" )
End Function



'++LotusScript Development Environment:2:1:getLinkComment:1:8
Public Function getLinkComment( link As Variant ) As String
	On Error GoTo eh
	Dim session As New NotesSession
	getLinkComment = "Click to open link from " & session.commonUsername 'default text
	
	If Not IsObject( link ) Then Exit Function
	If link Is Nothing Then Exit Function
	
	Dim doc As NotesDocument
	
	Select Case TypeName( link )
		
	Case "NOTESDOCUMENT":
		Dim s As String
		s = link.subject( 0 )
		If s = "" Then s = link.title( 0 )
		If s = "" Then s = link.form( 0 )
		If link.parentView Is Nothing Then		
			getLinkComment = |Application '| & link.parentDatabase.title & |', Document '| & s & |'|
		Else
			getLinkComment = |Application '| & link.parentDatabase.title & |', View '| & link.parentView.name & |', Document '| & s & |'|
		End If
		
	Case "NOTESVIEW":
		getLinkComment = |Application '| & link.parent.title & |', View '| & link.name &  |'|
		
	Case "NOTESDATABASE":
		getLinkComment = |Application '| & link.title & |'|
		
	End Select
	
		
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( "" )
End Function












'++LotusScript Development Environment:2:1:cString:1:8
Public Function cString( source As Variant ) As String
	On Error GoTo eh
	Dim value As String
	
	If IsNull( source ) Then
		cString = ""
		Exit function
	End if
	
	Select Case Typename( source )
	Case "STRING":
		value = source
	Case "STRINGS":
		If source Is Nothing Then
			value = ""
		Else
			value = source.toString()
		End If
	Case Else:
		If Isarray( source ) Then
			'value = Join( source ) '7.12.2010 Doesn't work on some none string arrays (e.g. an array of doubles)
			Forall entry In source
				value = value & Cstr( entry )
			End Forall
		Else
			If IsNull( source ) Then
				value = "NULL"
			Else
				value = CStr( source )
			End If
		End If
	End Select
	
	cString = value
	
done:
	Exit Function
eh: 
	cString = Error 
	Resume done 
	'Error Err, getErrorInfo( "" )
End Function




'++LotusScript Development Environment:2:1:SystemLog:1:8
Static Public Function SystemLog() As SystemLogObject
	Static logs As SystemLogObject
	If logs Is Nothing Then
		Dim l As New AbstractLog()
		Set logs = New SystemLogObject()
		Call logs.set( l )
	End If
	Set SystemLog = logs
End Function





'++LotusScript Development Environment:2:1:parseParams:1:8
Public Function parseParams( s As String, p1 As Variant, p2 As Variant, p3 As Variant, p4 As Variant ) As String
	On Error GoTo eh
	Dim params( 3 ) As String
	params( 0 ) = cString( p1 )
	params( 1 ) = cString( p2 )
	params( 2 ) = cString( p3 )
	params( 3 ) = cString( p4 )
	
	parseParams = parseParam( s, params )
		
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( "" )
End Function


'++LotusScript Development Environment:2:1:parseParam:1:8
Public Function parseParam( s As String, params As Variant ) As String
	On Error GoTo eh
	Dim i As Long
	Dim value As String
	value = s
	
	If Isarray( params ) Then
		For i = 0 To Ubound( params )
			value = Replace( value, "%" & i+1, Cstr( params( i )))
		Next
	Else
		value = Replace( value, "%1", Cstr( params ))
	End If
	
	parseParam = value
		
done:
	Exit Function
eh: 
	Error Err, getErrorInfo( "" )
End Function















































